
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model School
 * 
 */
export type School = $Result.DefaultSelection<Prisma.$SchoolPayload>
/**
 * Model Region
 * 
 */
export type Region = $Result.DefaultSelection<Prisma.$RegionPayload>
/**
 * Model ChoiceQuestion
 * 
 */
export type ChoiceQuestion = $Result.DefaultSelection<Prisma.$ChoiceQuestionPayload>
/**
 * Model ChoiceAnswer
 * 
 */
export type ChoiceAnswer = $Result.DefaultSelection<Prisma.$ChoiceAnswerPayload>
/**
 * Model ChoiceAnswerApply
 * 
 */
export type ChoiceAnswerApply = $Result.DefaultSelection<Prisma.$ChoiceAnswerApplyPayload>
/**
 * Model WriteQuestion
 * 
 */
export type WriteQuestion = $Result.DefaultSelection<Prisma.$WriteQuestionPayload>
/**
 * Model WriteQuestionApply
 * 
 */
export type WriteQuestionApply = $Result.DefaultSelection<Prisma.$WriteQuestionApplyPayload>
/**
 * Model Training
 * 
 */
export type Training = $Result.DefaultSelection<Prisma.$TrainingPayload>
/**
 * Model TrainingApply
 * 
 */
export type TrainingApply = $Result.DefaultSelection<Prisma.$TrainingApplyPayload>
/**
 * Model CheckTrainingApply
 * 
 */
export type CheckTrainingApply = $Result.DefaultSelection<Prisma.$CheckTrainingApplyPayload>
/**
 * Model Lesson
 * 
 */
export type Lesson = $Result.DefaultSelection<Prisma.$LessonPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model TaskCriteria
 * 
 */
export type TaskCriteria = $Result.DefaultSelection<Prisma.$TaskCriteriaPayload>
/**
 * Model TaskApply
 * 
 */
export type TaskApply = $Result.DefaultSelection<Prisma.$TaskApplyPayload>
/**
 * Model CheckWithTaskCriterias
 * 
 */
export type CheckWithTaskCriterias = $Result.DefaultSelection<Prisma.$CheckWithTaskCriteriasPayload>
/**
 * Model Teacher
 * 
 */
export type Teacher = $Result.DefaultSelection<Prisma.$TeacherPayload>
/**
 * Model TeacherPersonalInfo
 * 
 */
export type TeacherPersonalInfo = $Result.DefaultSelection<Prisma.$TeacherPersonalInfoPayload>
/**
 * Model TeacherWorkplace
 * 
 */
export type TeacherWorkplace = $Result.DefaultSelection<Prisma.$TeacherWorkplacePayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Schools
 * const schools = await prisma.school.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Schools
   * const schools = await prisma.school.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.school`: Exposes CRUD operations for the **School** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schools
    * const schools = await prisma.school.findMany()
    * ```
    */
  get school(): Prisma.SchoolDelegate<ExtArgs>;

  /**
   * `prisma.region`: Exposes CRUD operations for the **Region** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regions
    * const regions = await prisma.region.findMany()
    * ```
    */
  get region(): Prisma.RegionDelegate<ExtArgs>;

  /**
   * `prisma.choiceQuestion`: Exposes CRUD operations for the **ChoiceQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChoiceQuestions
    * const choiceQuestions = await prisma.choiceQuestion.findMany()
    * ```
    */
  get choiceQuestion(): Prisma.ChoiceQuestionDelegate<ExtArgs>;

  /**
   * `prisma.choiceAnswer`: Exposes CRUD operations for the **ChoiceAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChoiceAnswers
    * const choiceAnswers = await prisma.choiceAnswer.findMany()
    * ```
    */
  get choiceAnswer(): Prisma.ChoiceAnswerDelegate<ExtArgs>;

  /**
   * `prisma.choiceAnswerApply`: Exposes CRUD operations for the **ChoiceAnswerApply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChoiceAnswerApplies
    * const choiceAnswerApplies = await prisma.choiceAnswerApply.findMany()
    * ```
    */
  get choiceAnswerApply(): Prisma.ChoiceAnswerApplyDelegate<ExtArgs>;

  /**
   * `prisma.writeQuestion`: Exposes CRUD operations for the **WriteQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WriteQuestions
    * const writeQuestions = await prisma.writeQuestion.findMany()
    * ```
    */
  get writeQuestion(): Prisma.WriteQuestionDelegate<ExtArgs>;

  /**
   * `prisma.writeQuestionApply`: Exposes CRUD operations for the **WriteQuestionApply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WriteQuestionApplies
    * const writeQuestionApplies = await prisma.writeQuestionApply.findMany()
    * ```
    */
  get writeQuestionApply(): Prisma.WriteQuestionApplyDelegate<ExtArgs>;

  /**
   * `prisma.training`: Exposes CRUD operations for the **Training** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trainings
    * const trainings = await prisma.training.findMany()
    * ```
    */
  get training(): Prisma.TrainingDelegate<ExtArgs>;

  /**
   * `prisma.trainingApply`: Exposes CRUD operations for the **TrainingApply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingApplies
    * const trainingApplies = await prisma.trainingApply.findMany()
    * ```
    */
  get trainingApply(): Prisma.TrainingApplyDelegate<ExtArgs>;

  /**
   * `prisma.checkTrainingApply`: Exposes CRUD operations for the **CheckTrainingApply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CheckTrainingApplies
    * const checkTrainingApplies = await prisma.checkTrainingApply.findMany()
    * ```
    */
  get checkTrainingApply(): Prisma.CheckTrainingApplyDelegate<ExtArgs>;

  /**
   * `prisma.lesson`: Exposes CRUD operations for the **Lesson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lessons
    * const lessons = await prisma.lesson.findMany()
    * ```
    */
  get lesson(): Prisma.LessonDelegate<ExtArgs>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs>;

  /**
   * `prisma.taskCriteria`: Exposes CRUD operations for the **TaskCriteria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskCriteria
    * const taskCriteria = await prisma.taskCriteria.findMany()
    * ```
    */
  get taskCriteria(): Prisma.TaskCriteriaDelegate<ExtArgs>;

  /**
   * `prisma.taskApply`: Exposes CRUD operations for the **TaskApply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskApplies
    * const taskApplies = await prisma.taskApply.findMany()
    * ```
    */
  get taskApply(): Prisma.TaskApplyDelegate<ExtArgs>;

  /**
   * `prisma.checkWithTaskCriterias`: Exposes CRUD operations for the **CheckWithTaskCriterias** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CheckWithTaskCriterias
    * const checkWithTaskCriterias = await prisma.checkWithTaskCriterias.findMany()
    * ```
    */
  get checkWithTaskCriterias(): Prisma.CheckWithTaskCriteriasDelegate<ExtArgs>;

  /**
   * `prisma.teacher`: Exposes CRUD operations for the **Teacher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teacher.findMany()
    * ```
    */
  get teacher(): Prisma.TeacherDelegate<ExtArgs>;

  /**
   * `prisma.teacherPersonalInfo`: Exposes CRUD operations for the **TeacherPersonalInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherPersonalInfos
    * const teacherPersonalInfos = await prisma.teacherPersonalInfo.findMany()
    * ```
    */
  get teacherPersonalInfo(): Prisma.TeacherPersonalInfoDelegate<ExtArgs>;

  /**
   * `prisma.teacherWorkplace`: Exposes CRUD operations for the **TeacherWorkplace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherWorkplaces
    * const teacherWorkplaces = await prisma.teacherWorkplace.findMany()
    * ```
    */
  get teacherWorkplace(): Prisma.TeacherWorkplaceDelegate<ExtArgs>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.5.2
   * Query Engine version: aebc046ce8b88ebbcb45efe31cbe7d06fd6abc0a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    School: 'School',
    Region: 'Region',
    ChoiceQuestion: 'ChoiceQuestion',
    ChoiceAnswer: 'ChoiceAnswer',
    ChoiceAnswerApply: 'ChoiceAnswerApply',
    WriteQuestion: 'WriteQuestion',
    WriteQuestionApply: 'WriteQuestionApply',
    Training: 'Training',
    TrainingApply: 'TrainingApply',
    CheckTrainingApply: 'CheckTrainingApply',
    Lesson: 'Lesson',
    Task: 'Task',
    TaskCriteria: 'TaskCriteria',
    TaskApply: 'TaskApply',
    CheckWithTaskCriterias: 'CheckWithTaskCriterias',
    Teacher: 'Teacher',
    TeacherPersonalInfo: 'TeacherPersonalInfo',
    TeacherWorkplace: 'TeacherWorkplace',
    Admin: 'Admin'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'school' | 'region' | 'choiceQuestion' | 'choiceAnswer' | 'choiceAnswerApply' | 'writeQuestion' | 'writeQuestionApply' | 'training' | 'trainingApply' | 'checkTrainingApply' | 'lesson' | 'task' | 'taskCriteria' | 'taskApply' | 'checkWithTaskCriterias' | 'teacher' | 'teacherPersonalInfo' | 'teacherWorkplace' | 'admin'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      School: {
        payload: Prisma.$SchoolPayload<ExtArgs>
        fields: Prisma.SchoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findFirst: {
            args: Prisma.SchoolFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findMany: {
            args: Prisma.SchoolFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          create: {
            args: Prisma.SchoolCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          createMany: {
            args: Prisma.SchoolCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SchoolDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          update: {
            args: Prisma.SchoolUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          deleteMany: {
            args: Prisma.SchoolDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SchoolUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          aggregate: {
            args: Prisma.SchoolAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSchool>
          }
          groupBy: {
            args: Prisma.SchoolGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SchoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolCountArgs<ExtArgs>,
            result: $Utils.Optional<SchoolCountAggregateOutputType> | number
          }
        }
      }
      Region: {
        payload: Prisma.$RegionPayload<ExtArgs>
        fields: Prisma.RegionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findFirst: {
            args: Prisma.RegionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findMany: {
            args: Prisma.RegionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          create: {
            args: Prisma.RegionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          createMany: {
            args: Prisma.RegionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RegionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          update: {
            args: Prisma.RegionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          deleteMany: {
            args: Prisma.RegionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RegionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RegionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          aggregate: {
            args: Prisma.RegionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRegion>
          }
          groupBy: {
            args: Prisma.RegionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RegionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegionCountArgs<ExtArgs>,
            result: $Utils.Optional<RegionCountAggregateOutputType> | number
          }
        }
      }
      ChoiceQuestion: {
        payload: Prisma.$ChoiceQuestionPayload<ExtArgs>
        fields: Prisma.ChoiceQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChoiceQuestionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChoiceQuestionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceQuestionPayload>
          }
          findFirst: {
            args: Prisma.ChoiceQuestionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChoiceQuestionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceQuestionPayload>
          }
          findMany: {
            args: Prisma.ChoiceQuestionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceQuestionPayload>[]
          }
          create: {
            args: Prisma.ChoiceQuestionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceQuestionPayload>
          }
          createMany: {
            args: Prisma.ChoiceQuestionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ChoiceQuestionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceQuestionPayload>
          }
          update: {
            args: Prisma.ChoiceQuestionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceQuestionPayload>
          }
          deleteMany: {
            args: Prisma.ChoiceQuestionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ChoiceQuestionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ChoiceQuestionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceQuestionPayload>
          }
          aggregate: {
            args: Prisma.ChoiceQuestionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateChoiceQuestion>
          }
          groupBy: {
            args: Prisma.ChoiceQuestionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ChoiceQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChoiceQuestionCountArgs<ExtArgs>,
            result: $Utils.Optional<ChoiceQuestionCountAggregateOutputType> | number
          }
        }
      }
      ChoiceAnswer: {
        payload: Prisma.$ChoiceAnswerPayload<ExtArgs>
        fields: Prisma.ChoiceAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChoiceAnswerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChoiceAnswerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceAnswerPayload>
          }
          findFirst: {
            args: Prisma.ChoiceAnswerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChoiceAnswerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceAnswerPayload>
          }
          findMany: {
            args: Prisma.ChoiceAnswerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceAnswerPayload>[]
          }
          create: {
            args: Prisma.ChoiceAnswerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceAnswerPayload>
          }
          createMany: {
            args: Prisma.ChoiceAnswerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ChoiceAnswerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceAnswerPayload>
          }
          update: {
            args: Prisma.ChoiceAnswerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceAnswerPayload>
          }
          deleteMany: {
            args: Prisma.ChoiceAnswerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ChoiceAnswerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ChoiceAnswerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceAnswerPayload>
          }
          aggregate: {
            args: Prisma.ChoiceAnswerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateChoiceAnswer>
          }
          groupBy: {
            args: Prisma.ChoiceAnswerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ChoiceAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChoiceAnswerCountArgs<ExtArgs>,
            result: $Utils.Optional<ChoiceAnswerCountAggregateOutputType> | number
          }
        }
      }
      ChoiceAnswerApply: {
        payload: Prisma.$ChoiceAnswerApplyPayload<ExtArgs>
        fields: Prisma.ChoiceAnswerApplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChoiceAnswerApplyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceAnswerApplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChoiceAnswerApplyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceAnswerApplyPayload>
          }
          findFirst: {
            args: Prisma.ChoiceAnswerApplyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceAnswerApplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChoiceAnswerApplyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceAnswerApplyPayload>
          }
          findMany: {
            args: Prisma.ChoiceAnswerApplyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceAnswerApplyPayload>[]
          }
          create: {
            args: Prisma.ChoiceAnswerApplyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceAnswerApplyPayload>
          }
          createMany: {
            args: Prisma.ChoiceAnswerApplyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ChoiceAnswerApplyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceAnswerApplyPayload>
          }
          update: {
            args: Prisma.ChoiceAnswerApplyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceAnswerApplyPayload>
          }
          deleteMany: {
            args: Prisma.ChoiceAnswerApplyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ChoiceAnswerApplyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ChoiceAnswerApplyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoiceAnswerApplyPayload>
          }
          aggregate: {
            args: Prisma.ChoiceAnswerApplyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateChoiceAnswerApply>
          }
          groupBy: {
            args: Prisma.ChoiceAnswerApplyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ChoiceAnswerApplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChoiceAnswerApplyCountArgs<ExtArgs>,
            result: $Utils.Optional<ChoiceAnswerApplyCountAggregateOutputType> | number
          }
        }
      }
      WriteQuestion: {
        payload: Prisma.$WriteQuestionPayload<ExtArgs>
        fields: Prisma.WriteQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WriteQuestionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WriteQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WriteQuestionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WriteQuestionPayload>
          }
          findFirst: {
            args: Prisma.WriteQuestionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WriteQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WriteQuestionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WriteQuestionPayload>
          }
          findMany: {
            args: Prisma.WriteQuestionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WriteQuestionPayload>[]
          }
          create: {
            args: Prisma.WriteQuestionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WriteQuestionPayload>
          }
          createMany: {
            args: Prisma.WriteQuestionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WriteQuestionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WriteQuestionPayload>
          }
          update: {
            args: Prisma.WriteQuestionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WriteQuestionPayload>
          }
          deleteMany: {
            args: Prisma.WriteQuestionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WriteQuestionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WriteQuestionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WriteQuestionPayload>
          }
          aggregate: {
            args: Prisma.WriteQuestionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWriteQuestion>
          }
          groupBy: {
            args: Prisma.WriteQuestionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WriteQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WriteQuestionCountArgs<ExtArgs>,
            result: $Utils.Optional<WriteQuestionCountAggregateOutputType> | number
          }
        }
      }
      WriteQuestionApply: {
        payload: Prisma.$WriteQuestionApplyPayload<ExtArgs>
        fields: Prisma.WriteQuestionApplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WriteQuestionApplyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WriteQuestionApplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WriteQuestionApplyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WriteQuestionApplyPayload>
          }
          findFirst: {
            args: Prisma.WriteQuestionApplyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WriteQuestionApplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WriteQuestionApplyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WriteQuestionApplyPayload>
          }
          findMany: {
            args: Prisma.WriteQuestionApplyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WriteQuestionApplyPayload>[]
          }
          create: {
            args: Prisma.WriteQuestionApplyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WriteQuestionApplyPayload>
          }
          createMany: {
            args: Prisma.WriteQuestionApplyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WriteQuestionApplyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WriteQuestionApplyPayload>
          }
          update: {
            args: Prisma.WriteQuestionApplyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WriteQuestionApplyPayload>
          }
          deleteMany: {
            args: Prisma.WriteQuestionApplyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WriteQuestionApplyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WriteQuestionApplyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WriteQuestionApplyPayload>
          }
          aggregate: {
            args: Prisma.WriteQuestionApplyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWriteQuestionApply>
          }
          groupBy: {
            args: Prisma.WriteQuestionApplyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WriteQuestionApplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.WriteQuestionApplyCountArgs<ExtArgs>,
            result: $Utils.Optional<WriteQuestionApplyCountAggregateOutputType> | number
          }
        }
      }
      Training: {
        payload: Prisma.$TrainingPayload<ExtArgs>
        fields: Prisma.TrainingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          findFirst: {
            args: Prisma.TrainingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          findMany: {
            args: Prisma.TrainingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>[]
          }
          create: {
            args: Prisma.TrainingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          createMany: {
            args: Prisma.TrainingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TrainingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          update: {
            args: Prisma.TrainingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          deleteMany: {
            args: Prisma.TrainingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TrainingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          aggregate: {
            args: Prisma.TrainingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTraining>
          }
          groupBy: {
            args: Prisma.TrainingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TrainingGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingCountArgs<ExtArgs>,
            result: $Utils.Optional<TrainingCountAggregateOutputType> | number
          }
        }
      }
      TrainingApply: {
        payload: Prisma.$TrainingApplyPayload<ExtArgs>
        fields: Prisma.TrainingApplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingApplyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingApplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingApplyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingApplyPayload>
          }
          findFirst: {
            args: Prisma.TrainingApplyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingApplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingApplyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingApplyPayload>
          }
          findMany: {
            args: Prisma.TrainingApplyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingApplyPayload>[]
          }
          create: {
            args: Prisma.TrainingApplyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingApplyPayload>
          }
          createMany: {
            args: Prisma.TrainingApplyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TrainingApplyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingApplyPayload>
          }
          update: {
            args: Prisma.TrainingApplyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingApplyPayload>
          }
          deleteMany: {
            args: Prisma.TrainingApplyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingApplyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TrainingApplyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrainingApplyPayload>
          }
          aggregate: {
            args: Prisma.TrainingApplyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTrainingApply>
          }
          groupBy: {
            args: Prisma.TrainingApplyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TrainingApplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingApplyCountArgs<ExtArgs>,
            result: $Utils.Optional<TrainingApplyCountAggregateOutputType> | number
          }
        }
      }
      CheckTrainingApply: {
        payload: Prisma.$CheckTrainingApplyPayload<ExtArgs>
        fields: Prisma.CheckTrainingApplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CheckTrainingApplyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckTrainingApplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CheckTrainingApplyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckTrainingApplyPayload>
          }
          findFirst: {
            args: Prisma.CheckTrainingApplyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckTrainingApplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CheckTrainingApplyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckTrainingApplyPayload>
          }
          findMany: {
            args: Prisma.CheckTrainingApplyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckTrainingApplyPayload>[]
          }
          create: {
            args: Prisma.CheckTrainingApplyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckTrainingApplyPayload>
          }
          createMany: {
            args: Prisma.CheckTrainingApplyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CheckTrainingApplyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckTrainingApplyPayload>
          }
          update: {
            args: Prisma.CheckTrainingApplyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckTrainingApplyPayload>
          }
          deleteMany: {
            args: Prisma.CheckTrainingApplyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CheckTrainingApplyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CheckTrainingApplyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckTrainingApplyPayload>
          }
          aggregate: {
            args: Prisma.CheckTrainingApplyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCheckTrainingApply>
          }
          groupBy: {
            args: Prisma.CheckTrainingApplyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CheckTrainingApplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CheckTrainingApplyCountArgs<ExtArgs>,
            result: $Utils.Optional<CheckTrainingApplyCountAggregateOutputType> | number
          }
        }
      }
      Lesson: {
        payload: Prisma.$LessonPayload<ExtArgs>
        fields: Prisma.LessonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findFirst: {
            args: Prisma.LessonFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findMany: {
            args: Prisma.LessonFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          create: {
            args: Prisma.LessonCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          createMany: {
            args: Prisma.LessonCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LessonDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          update: {
            args: Prisma.LessonUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          deleteMany: {
            args: Prisma.LessonDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LessonUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LessonUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          aggregate: {
            args: Prisma.LessonAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLesson>
          }
          groupBy: {
            args: Prisma.LessonGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LessonGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonCountArgs<ExtArgs>,
            result: $Utils.Optional<LessonCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>,
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      TaskCriteria: {
        payload: Prisma.$TaskCriteriaPayload<ExtArgs>
        fields: Prisma.TaskCriteriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskCriteriaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskCriteriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskCriteriaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskCriteriaPayload>
          }
          findFirst: {
            args: Prisma.TaskCriteriaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskCriteriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskCriteriaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskCriteriaPayload>
          }
          findMany: {
            args: Prisma.TaskCriteriaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskCriteriaPayload>[]
          }
          create: {
            args: Prisma.TaskCriteriaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskCriteriaPayload>
          }
          createMany: {
            args: Prisma.TaskCriteriaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TaskCriteriaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskCriteriaPayload>
          }
          update: {
            args: Prisma.TaskCriteriaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskCriteriaPayload>
          }
          deleteMany: {
            args: Prisma.TaskCriteriaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TaskCriteriaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TaskCriteriaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskCriteriaPayload>
          }
          aggregate: {
            args: Prisma.TaskCriteriaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTaskCriteria>
          }
          groupBy: {
            args: Prisma.TaskCriteriaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TaskCriteriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCriteriaCountArgs<ExtArgs>,
            result: $Utils.Optional<TaskCriteriaCountAggregateOutputType> | number
          }
        }
      }
      TaskApply: {
        payload: Prisma.$TaskApplyPayload<ExtArgs>
        fields: Prisma.TaskApplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskApplyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskApplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskApplyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskApplyPayload>
          }
          findFirst: {
            args: Prisma.TaskApplyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskApplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskApplyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskApplyPayload>
          }
          findMany: {
            args: Prisma.TaskApplyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskApplyPayload>[]
          }
          create: {
            args: Prisma.TaskApplyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskApplyPayload>
          }
          createMany: {
            args: Prisma.TaskApplyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TaskApplyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskApplyPayload>
          }
          update: {
            args: Prisma.TaskApplyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskApplyPayload>
          }
          deleteMany: {
            args: Prisma.TaskApplyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TaskApplyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TaskApplyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TaskApplyPayload>
          }
          aggregate: {
            args: Prisma.TaskApplyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTaskApply>
          }
          groupBy: {
            args: Prisma.TaskApplyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TaskApplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskApplyCountArgs<ExtArgs>,
            result: $Utils.Optional<TaskApplyCountAggregateOutputType> | number
          }
        }
      }
      CheckWithTaskCriterias: {
        payload: Prisma.$CheckWithTaskCriteriasPayload<ExtArgs>
        fields: Prisma.CheckWithTaskCriteriasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CheckWithTaskCriteriasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckWithTaskCriteriasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CheckWithTaskCriteriasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckWithTaskCriteriasPayload>
          }
          findFirst: {
            args: Prisma.CheckWithTaskCriteriasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckWithTaskCriteriasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CheckWithTaskCriteriasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckWithTaskCriteriasPayload>
          }
          findMany: {
            args: Prisma.CheckWithTaskCriteriasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckWithTaskCriteriasPayload>[]
          }
          create: {
            args: Prisma.CheckWithTaskCriteriasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckWithTaskCriteriasPayload>
          }
          createMany: {
            args: Prisma.CheckWithTaskCriteriasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CheckWithTaskCriteriasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckWithTaskCriteriasPayload>
          }
          update: {
            args: Prisma.CheckWithTaskCriteriasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckWithTaskCriteriasPayload>
          }
          deleteMany: {
            args: Prisma.CheckWithTaskCriteriasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CheckWithTaskCriteriasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CheckWithTaskCriteriasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckWithTaskCriteriasPayload>
          }
          aggregate: {
            args: Prisma.CheckWithTaskCriteriasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCheckWithTaskCriterias>
          }
          groupBy: {
            args: Prisma.CheckWithTaskCriteriasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CheckWithTaskCriteriasGroupByOutputType>[]
          }
          count: {
            args: Prisma.CheckWithTaskCriteriasCountArgs<ExtArgs>,
            result: $Utils.Optional<CheckWithTaskCriteriasCountAggregateOutputType> | number
          }
        }
      }
      Teacher: {
        payload: Prisma.$TeacherPayload<ExtArgs>
        fields: Prisma.TeacherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findFirst: {
            args: Prisma.TeacherFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findMany: {
            args: Prisma.TeacherFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          create: {
            args: Prisma.TeacherCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          createMany: {
            args: Prisma.TeacherCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TeacherDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          update: {
            args: Prisma.TeacherUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          deleteMany: {
            args: Prisma.TeacherDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TeacherUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          aggregate: {
            args: Prisma.TeacherAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTeacher>
          }
          groupBy: {
            args: Prisma.TeacherGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TeacherGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherCountArgs<ExtArgs>,
            result: $Utils.Optional<TeacherCountAggregateOutputType> | number
          }
        }
      }
      TeacherPersonalInfo: {
        payload: Prisma.$TeacherPersonalInfoPayload<ExtArgs>
        fields: Prisma.TeacherPersonalInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherPersonalInfoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherPersonalInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherPersonalInfoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherPersonalInfoPayload>
          }
          findFirst: {
            args: Prisma.TeacherPersonalInfoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherPersonalInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherPersonalInfoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherPersonalInfoPayload>
          }
          findMany: {
            args: Prisma.TeacherPersonalInfoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherPersonalInfoPayload>[]
          }
          create: {
            args: Prisma.TeacherPersonalInfoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherPersonalInfoPayload>
          }
          createMany: {
            args: Prisma.TeacherPersonalInfoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TeacherPersonalInfoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherPersonalInfoPayload>
          }
          update: {
            args: Prisma.TeacherPersonalInfoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherPersonalInfoPayload>
          }
          deleteMany: {
            args: Prisma.TeacherPersonalInfoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherPersonalInfoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TeacherPersonalInfoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherPersonalInfoPayload>
          }
          aggregate: {
            args: Prisma.TeacherPersonalInfoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTeacherPersonalInfo>
          }
          groupBy: {
            args: Prisma.TeacherPersonalInfoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TeacherPersonalInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherPersonalInfoCountArgs<ExtArgs>,
            result: $Utils.Optional<TeacherPersonalInfoCountAggregateOutputType> | number
          }
        }
      }
      TeacherWorkplace: {
        payload: Prisma.$TeacherWorkplacePayload<ExtArgs>
        fields: Prisma.TeacherWorkplaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherWorkplaceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkplacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherWorkplaceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkplacePayload>
          }
          findFirst: {
            args: Prisma.TeacherWorkplaceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkplacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherWorkplaceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkplacePayload>
          }
          findMany: {
            args: Prisma.TeacherWorkplaceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkplacePayload>[]
          }
          create: {
            args: Prisma.TeacherWorkplaceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkplacePayload>
          }
          createMany: {
            args: Prisma.TeacherWorkplaceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TeacherWorkplaceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkplacePayload>
          }
          update: {
            args: Prisma.TeacherWorkplaceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkplacePayload>
          }
          deleteMany: {
            args: Prisma.TeacherWorkplaceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherWorkplaceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TeacherWorkplaceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherWorkplacePayload>
          }
          aggregate: {
            args: Prisma.TeacherWorkplaceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTeacherWorkplace>
          }
          groupBy: {
            args: Prisma.TeacherWorkplaceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TeacherWorkplaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherWorkplaceCountArgs<ExtArgs>,
            result: $Utils.Optional<TeacherWorkplaceCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>,
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SchoolCountOutputType
   */

  export type SchoolCountOutputType = {
    teachers_workplaces: number
  }

  export type SchoolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teachers_workplaces?: boolean | SchoolCountOutputTypeCountTeachers_workplacesArgs
  }

  // Custom InputTypes

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolCountOutputType
     */
    select?: SchoolCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountTeachers_workplacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWorkplaceWhereInput
  }



  /**
   * Count Type RegionCountOutputType
   */

  export type RegionCountOutputType = {
    schools: number
  }

  export type RegionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | RegionCountOutputTypeCountSchoolsArgs
  }

  // Custom InputTypes

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCountOutputType
     */
    select?: RegionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountSchoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
  }



  /**
   * Count Type ChoiceQuestionCountOutputType
   */

  export type ChoiceQuestionCountOutputType = {
    answers: number
  }

  export type ChoiceQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | ChoiceQuestionCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes

  /**
   * ChoiceQuestionCountOutputType without action
   */
  export type ChoiceQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceQuestionCountOutputType
     */
    select?: ChoiceQuestionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ChoiceQuestionCountOutputType without action
   */
  export type ChoiceQuestionCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoiceAnswerWhereInput
  }



  /**
   * Count Type ChoiceAnswerCountOutputType
   */

  export type ChoiceAnswerCountOutputType = {
    choice_answer_applys: number
  }

  export type ChoiceAnswerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    choice_answer_applys?: boolean | ChoiceAnswerCountOutputTypeCountChoice_answer_applysArgs
  }

  // Custom InputTypes

  /**
   * ChoiceAnswerCountOutputType without action
   */
  export type ChoiceAnswerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceAnswerCountOutputType
     */
    select?: ChoiceAnswerCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ChoiceAnswerCountOutputType without action
   */
  export type ChoiceAnswerCountOutputTypeCountChoice_answer_applysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoiceAnswerApplyWhereInput
  }



  /**
   * Count Type WriteQuestionCountOutputType
   */

  export type WriteQuestionCountOutputType = {
    question_applys: number
  }

  export type WriteQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question_applys?: boolean | WriteQuestionCountOutputTypeCountQuestion_applysArgs
  }

  // Custom InputTypes

  /**
   * WriteQuestionCountOutputType without action
   */
  export type WriteQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WriteQuestionCountOutputType
     */
    select?: WriteQuestionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * WriteQuestionCountOutputType without action
   */
  export type WriteQuestionCountOutputTypeCountQuestion_applysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WriteQuestionApplyWhereInput
  }



  /**
   * Count Type TrainingCountOutputType
   */

  export type TrainingCountOutputType = {
    training_applys: number
  }

  export type TrainingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training_applys?: boolean | TrainingCountOutputTypeCountTraining_applysArgs
  }

  // Custom InputTypes

  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCountOutputType
     */
    select?: TrainingCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeCountTraining_applysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingApplyWhereInput
  }



  /**
   * Count Type TrainingApplyCountOutputType
   */

  export type TrainingApplyCountOutputType = {
    checking_applys: number
  }

  export type TrainingApplyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checking_applys?: boolean | TrainingApplyCountOutputTypeCountChecking_applysArgs
  }

  // Custom InputTypes

  /**
   * TrainingApplyCountOutputType without action
   */
  export type TrainingApplyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingApplyCountOutputType
     */
    select?: TrainingApplyCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TrainingApplyCountOutputType without action
   */
  export type TrainingApplyCountOutputTypeCountChecking_applysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckTrainingApplyWhereInput
  }



  /**
   * Count Type LessonCountOutputType
   */

  export type LessonCountOutputType = {
    tasks: number
  }

  export type LessonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | LessonCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCountOutputType
     */
    select?: LessonCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }



  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    criterias: number
    task_applys: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    criterias?: boolean | TaskCountOutputTypeCountCriteriasArgs
    task_applys?: boolean | TaskCountOutputTypeCountTask_applysArgs
  }

  // Custom InputTypes

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountCriteriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskCriteriaWhereInput
  }


  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountTask_applysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskApplyWhereInput
  }



  /**
   * Count Type TaskCriteriaCountOutputType
   */

  export type TaskCriteriaCountOutputType = {
    checks_criterias: number
  }

  export type TaskCriteriaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checks_criterias?: boolean | TaskCriteriaCountOutputTypeCountChecks_criteriasArgs
  }

  // Custom InputTypes

  /**
   * TaskCriteriaCountOutputType without action
   */
  export type TaskCriteriaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCriteriaCountOutputType
     */
    select?: TaskCriteriaCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TaskCriteriaCountOutputType without action
   */
  export type TaskCriteriaCountOutputTypeCountChecks_criteriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckWithTaskCriteriasWhereInput
  }



  /**
   * Count Type TaskApplyCountOutputType
   */

  export type TaskApplyCountOutputType = {
    check_task_criterias: number
  }

  export type TaskApplyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    check_task_criterias?: boolean | TaskApplyCountOutputTypeCountCheck_task_criteriasArgs
  }

  // Custom InputTypes

  /**
   * TaskApplyCountOutputType without action
   */
  export type TaskApplyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskApplyCountOutputType
     */
    select?: TaskApplyCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TaskApplyCountOutputType without action
   */
  export type TaskApplyCountOutputTypeCountCheck_task_criteriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckWithTaskCriteriasWhereInput
  }



  /**
   * Count Type TeacherCountOutputType
   */

  export type TeacherCountOutputType = {
    task_applys: number
    teacher_training_applys: number
    write_question_applys: number
    choice_answer_applys: number
    teacher_personal_info: number
    teacher_workplace: number
  }

  export type TeacherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task_applys?: boolean | TeacherCountOutputTypeCountTask_applysArgs
    teacher_training_applys?: boolean | TeacherCountOutputTypeCountTeacher_training_applysArgs
    write_question_applys?: boolean | TeacherCountOutputTypeCountWrite_question_applysArgs
    choice_answer_applys?: boolean | TeacherCountOutputTypeCountChoice_answer_applysArgs
    teacher_personal_info?: boolean | TeacherCountOutputTypeCountTeacher_personal_infoArgs
    teacher_workplace?: boolean | TeacherCountOutputTypeCountTeacher_workplaceArgs
  }

  // Custom InputTypes

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherCountOutputType
     */
    select?: TeacherCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountTask_applysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskApplyWhereInput
  }


  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountTeacher_training_applysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingApplyWhereInput
  }


  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountWrite_question_applysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WriteQuestionApplyWhereInput
  }


  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountChoice_answer_applysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoiceAnswerApplyWhereInput
  }


  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountTeacher_personal_infoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherPersonalInfoWhereInput
  }


  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountTeacher_workplaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWorkplaceWhereInput
  }



  /**
   * Models
   */

  /**
   * Model School
   */

  export type AggregateSchool = {
    _count: SchoolCountAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  export type SchoolMinAggregateOutputType = {
    id: string | null
    name: string | null
    region_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SchoolMaxAggregateOutputType = {
    id: string | null
    name: string | null
    region_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SchoolCountAggregateOutputType = {
    id: number
    name: number
    region_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SchoolMinAggregateInputType = {
    id?: true
    name?: true
    region_id?: true
    created_at?: true
    updated_at?: true
  }

  export type SchoolMaxAggregateInputType = {
    id?: true
    name?: true
    region_id?: true
    created_at?: true
    updated_at?: true
  }

  export type SchoolCountAggregateInputType = {
    id?: true
    name?: true
    region_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SchoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which School to aggregate.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schools
    **/
    _count?: true | SchoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolMaxAggregateInputType
  }

  export type GetSchoolAggregateType<T extends SchoolAggregateArgs> = {
        [P in keyof T & keyof AggregateSchool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchool[P]>
      : GetScalarType<T[P], AggregateSchool[P]>
  }




  export type SchoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithAggregationInput | SchoolOrderByWithAggregationInput[]
    by: SchoolScalarFieldEnum[] | SchoolScalarFieldEnum
    having?: SchoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolCountAggregateInputType | true
    _min?: SchoolMinAggregateInputType
    _max?: SchoolMaxAggregateInputType
  }

  export type SchoolGroupByOutputType = {
    id: string
    name: string
    region_id: string
    created_at: Date
    updated_at: Date
    _count: SchoolCountAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  type GetSchoolGroupByPayload<T extends SchoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolGroupByOutputType[P]>
        }
      >
    >


  export type SchoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    region_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
    teachers_workplaces?: boolean | School$teachers_workplacesArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectScalar = {
    id?: boolean
    name?: boolean
    region_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type SchoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
    teachers_workplaces?: boolean | School$teachers_workplacesArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SchoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "School"
    objects: {
      region: Prisma.$RegionPayload<ExtArgs>
      teachers_workplaces: Prisma.$TeacherWorkplacePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      region_id: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["school"]>
    composites: {}
  }


  type SchoolGetPayload<S extends boolean | null | undefined | SchoolDefaultArgs> = $Result.GetResult<Prisma.$SchoolPayload, S>

  type SchoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SchoolFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SchoolCountAggregateInputType | true
    }

  export interface SchoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['School'], meta: { name: 'School' } }
    /**
     * Find zero or one School that matches the filter.
     * @param {SchoolFindUniqueArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SchoolFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SchoolFindUniqueArgs<ExtArgs>>
    ): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one School that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SchoolFindUniqueOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SchoolFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SchoolFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first School that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SchoolFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SchoolFindFirstArgs<ExtArgs>>
    ): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first School that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SchoolFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SchoolFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Schools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schools
     * const schools = await prisma.school.findMany()
     * 
     * // Get first 10 Schools
     * const schools = await prisma.school.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolWithIdOnly = await prisma.school.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SchoolFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SchoolFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a School.
     * @param {SchoolCreateArgs} args - Arguments to create a School.
     * @example
     * // Create one School
     * const School = await prisma.school.create({
     *   data: {
     *     // ... data to create a School
     *   }
     * })
     * 
    **/
    create<T extends SchoolCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SchoolCreateArgs<ExtArgs>>
    ): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Schools.
     *     @param {SchoolCreateManyArgs} args - Arguments to create many Schools.
     *     @example
     *     // Create many Schools
     *     const school = await prisma.school.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SchoolCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SchoolCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a School.
     * @param {SchoolDeleteArgs} args - Arguments to delete one School.
     * @example
     * // Delete one School
     * const School = await prisma.school.delete({
     *   where: {
     *     // ... filter to delete one School
     *   }
     * })
     * 
    **/
    delete<T extends SchoolDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SchoolDeleteArgs<ExtArgs>>
    ): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one School.
     * @param {SchoolUpdateArgs} args - Arguments to update one School.
     * @example
     * // Update one School
     * const school = await prisma.school.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SchoolUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SchoolUpdateArgs<ExtArgs>>
    ): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Schools.
     * @param {SchoolDeleteManyArgs} args - Arguments to filter Schools to delete.
     * @example
     * // Delete a few Schools
     * const { count } = await prisma.school.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SchoolDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SchoolDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SchoolUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SchoolUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one School.
     * @param {SchoolUpsertArgs} args - Arguments to update or create a School.
     * @example
     * // Update or create a School
     * const school = await prisma.school.upsert({
     *   create: {
     *     // ... data to create a School
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the School we want to update
     *   }
     * })
    **/
    upsert<T extends SchoolUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SchoolUpsertArgs<ExtArgs>>
    ): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolCountArgs} args - Arguments to filter Schools to count.
     * @example
     * // Count the number of Schools
     * const count = await prisma.school.count({
     *   where: {
     *     // ... the filter for the Schools we want to count
     *   }
     * })
    **/
    count<T extends SchoolCountArgs>(
      args?: Subset<T, SchoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolAggregateArgs>(args: Subset<T, SchoolAggregateArgs>): Prisma.PrismaPromise<GetSchoolAggregateType<T>>

    /**
     * Group by School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolGroupByArgs['orderBy'] }
        : { orderBy?: SchoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the School model
   */
  readonly fields: SchoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for School.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    region<T extends RegionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegionDefaultArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    teachers_workplaces<T extends School$teachers_workplacesArgs<ExtArgs> = {}>(args?: Subset<T, School$teachers_workplacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherWorkplacePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the School model
   */ 
  interface SchoolFieldRefs {
    readonly id: FieldRef<"School", 'String'>
    readonly name: FieldRef<"School", 'String'>
    readonly region_id: FieldRef<"School", 'String'>
    readonly created_at: FieldRef<"School", 'DateTime'>
    readonly updated_at: FieldRef<"School", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * School findUnique
   */
  export type SchoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }


  /**
   * School findUniqueOrThrow
   */
  export type SchoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }


  /**
   * School findFirst
   */
  export type SchoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }


  /**
   * School findFirstOrThrow
   */
  export type SchoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }


  /**
   * School findMany
   */
  export type SchoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which Schools to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }


  /**
   * School create
   */
  export type SchoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to create a School.
     */
    data: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
  }


  /**
   * School createMany
   */
  export type SchoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * School update
   */
  export type SchoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to update a School.
     */
    data: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
    /**
     * Choose, which School to update.
     */
    where: SchoolWhereUniqueInput
  }


  /**
   * School updateMany
   */
  export type SchoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
  }


  /**
   * School upsert
   */
  export type SchoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The filter to search for the School to update in case it exists.
     */
    where: SchoolWhereUniqueInput
    /**
     * In case the School found by the `where` argument doesn't exist, create a new School with this data.
     */
    create: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
    /**
     * In case the School was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
  }


  /**
   * School delete
   */
  export type SchoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter which School to delete.
     */
    where: SchoolWhereUniqueInput
  }


  /**
   * School deleteMany
   */
  export type SchoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schools to delete
     */
    where?: SchoolWhereInput
  }


  /**
   * School.teachers_workplaces
   */
  export type School$teachers_workplacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkplace
     */
    select?: TeacherWorkplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherWorkplaceInclude<ExtArgs> | null
    where?: TeacherWorkplaceWhereInput
    orderBy?: TeacherWorkplaceOrderByWithRelationInput | TeacherWorkplaceOrderByWithRelationInput[]
    cursor?: TeacherWorkplaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherWorkplaceScalarFieldEnum | TeacherWorkplaceScalarFieldEnum[]
  }


  /**
   * School without action
   */
  export type SchoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
  }



  /**
   * Model Region
   */

  export type AggregateRegion = {
    _count: RegionCountAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  export type RegionMinAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RegionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RegionCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type RegionMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type RegionMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type RegionCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type RegionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Region to aggregate.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Regions
    **/
    _count?: true | RegionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionMaxAggregateInputType
  }

  export type GetRegionAggregateType<T extends RegionAggregateArgs> = {
        [P in keyof T & keyof AggregateRegion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegion[P]>
      : GetScalarType<T[P], AggregateRegion[P]>
  }




  export type RegionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionWhereInput
    orderBy?: RegionOrderByWithAggregationInput | RegionOrderByWithAggregationInput[]
    by: RegionScalarFieldEnum[] | RegionScalarFieldEnum
    having?: RegionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionCountAggregateInputType | true
    _min?: RegionMinAggregateInputType
    _max?: RegionMaxAggregateInputType
  }

  export type RegionGroupByOutputType = {
    id: string
    name: string
    created_at: Date
    updated_at: Date
    _count: RegionCountAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  type GetRegionGroupByPayload<T extends RegionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionGroupByOutputType[P]>
            : GetScalarType<T[P], RegionGroupByOutputType[P]>
        }
      >
    >


  export type RegionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    schools?: boolean | Region$schoolsArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["region"]>

  export type RegionSelectScalar = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type RegionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | Region$schoolsArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RegionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Region"
    objects: {
      schools: Prisma.$SchoolPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["region"]>
    composites: {}
  }


  type RegionGetPayload<S extends boolean | null | undefined | RegionDefaultArgs> = $Result.GetResult<Prisma.$RegionPayload, S>

  type RegionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RegionFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RegionCountAggregateInputType | true
    }

  export interface RegionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Region'], meta: { name: 'Region' } }
    /**
     * Find zero or one Region that matches the filter.
     * @param {RegionFindUniqueArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RegionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RegionFindUniqueArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Region that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RegionFindUniqueOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RegionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RegionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Region that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RegionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RegionFindFirstArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Region that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RegionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RegionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Regions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regions
     * const regions = await prisma.region.findMany()
     * 
     * // Get first 10 Regions
     * const regions = await prisma.region.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regionWithIdOnly = await prisma.region.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RegionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RegionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Region.
     * @param {RegionCreateArgs} args - Arguments to create a Region.
     * @example
     * // Create one Region
     * const Region = await prisma.region.create({
     *   data: {
     *     // ... data to create a Region
     *   }
     * })
     * 
    **/
    create<T extends RegionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RegionCreateArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Regions.
     *     @param {RegionCreateManyArgs} args - Arguments to create many Regions.
     *     @example
     *     // Create many Regions
     *     const region = await prisma.region.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RegionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RegionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Region.
     * @param {RegionDeleteArgs} args - Arguments to delete one Region.
     * @example
     * // Delete one Region
     * const Region = await prisma.region.delete({
     *   where: {
     *     // ... filter to delete one Region
     *   }
     * })
     * 
    **/
    delete<T extends RegionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RegionDeleteArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Region.
     * @param {RegionUpdateArgs} args - Arguments to update one Region.
     * @example
     * // Update one Region
     * const region = await prisma.region.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RegionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RegionUpdateArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Regions.
     * @param {RegionDeleteManyArgs} args - Arguments to filter Regions to delete.
     * @example
     * // Delete a few Regions
     * const { count } = await prisma.region.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RegionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RegionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regions
     * const region = await prisma.region.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RegionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RegionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Region.
     * @param {RegionUpsertArgs} args - Arguments to update or create a Region.
     * @example
     * // Update or create a Region
     * const region = await prisma.region.upsert({
     *   create: {
     *     // ... data to create a Region
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Region we want to update
     *   }
     * })
    **/
    upsert<T extends RegionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RegionUpsertArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCountArgs} args - Arguments to filter Regions to count.
     * @example
     * // Count the number of Regions
     * const count = await prisma.region.count({
     *   where: {
     *     // ... the filter for the Regions we want to count
     *   }
     * })
    **/
    count<T extends RegionCountArgs>(
      args?: Subset<T, RegionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionAggregateArgs>(args: Subset<T, RegionAggregateArgs>): Prisma.PrismaPromise<GetRegionAggregateType<T>>

    /**
     * Group by Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionGroupByArgs['orderBy'] }
        : { orderBy?: RegionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Region model
   */
  readonly fields: RegionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Region.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    schools<T extends Region$schoolsArgs<ExtArgs> = {}>(args?: Subset<T, Region$schoolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Region model
   */ 
  interface RegionFieldRefs {
    readonly id: FieldRef<"Region", 'String'>
    readonly name: FieldRef<"Region", 'String'>
    readonly created_at: FieldRef<"Region", 'DateTime'>
    readonly updated_at: FieldRef<"Region", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Region findUnique
   */
  export type RegionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }


  /**
   * Region findUniqueOrThrow
   */
  export type RegionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }


  /**
   * Region findFirst
   */
  export type RegionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }


  /**
   * Region findFirstOrThrow
   */
  export type RegionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }


  /**
   * Region findMany
   */
  export type RegionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Regions to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }


  /**
   * Region create
   */
  export type RegionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to create a Region.
     */
    data: XOR<RegionCreateInput, RegionUncheckedCreateInput>
  }


  /**
   * Region createMany
   */
  export type RegionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Regions.
     */
    data: RegionCreateManyInput | RegionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Region update
   */
  export type RegionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to update a Region.
     */
    data: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
    /**
     * Choose, which Region to update.
     */
    where: RegionWhereUniqueInput
  }


  /**
   * Region updateMany
   */
  export type RegionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Regions.
     */
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyInput>
    /**
     * Filter which Regions to update
     */
    where?: RegionWhereInput
  }


  /**
   * Region upsert
   */
  export type RegionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The filter to search for the Region to update in case it exists.
     */
    where: RegionWhereUniqueInput
    /**
     * In case the Region found by the `where` argument doesn't exist, create a new Region with this data.
     */
    create: XOR<RegionCreateInput, RegionUncheckedCreateInput>
    /**
     * In case the Region was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
  }


  /**
   * Region delete
   */
  export type RegionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter which Region to delete.
     */
    where: RegionWhereUniqueInput
  }


  /**
   * Region deleteMany
   */
  export type RegionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Regions to delete
     */
    where?: RegionWhereInput
  }


  /**
   * Region.schools
   */
  export type Region$schoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    cursor?: SchoolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }


  /**
   * Region without action
   */
  export type RegionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
  }



  /**
   * Model ChoiceQuestion
   */

  export type AggregateChoiceQuestion = {
    _count: ChoiceQuestionCountAggregateOutputType | null
    _min: ChoiceQuestionMinAggregateOutputType | null
    _max: ChoiceQuestionMaxAggregateOutputType | null
  }

  export type ChoiceQuestionMinAggregateOutputType = {
    id: string | null
    text: string | null
    description: string | null
    correct_choice: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChoiceQuestionMaxAggregateOutputType = {
    id: string | null
    text: string | null
    description: string | null
    correct_choice: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChoiceQuestionCountAggregateOutputType = {
    id: number
    text: number
    description: number
    correct_choice: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ChoiceQuestionMinAggregateInputType = {
    id?: true
    text?: true
    description?: true
    correct_choice?: true
    created_at?: true
    updated_at?: true
  }

  export type ChoiceQuestionMaxAggregateInputType = {
    id?: true
    text?: true
    description?: true
    correct_choice?: true
    created_at?: true
    updated_at?: true
  }

  export type ChoiceQuestionCountAggregateInputType = {
    id?: true
    text?: true
    description?: true
    correct_choice?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ChoiceQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChoiceQuestion to aggregate.
     */
    where?: ChoiceQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoiceQuestions to fetch.
     */
    orderBy?: ChoiceQuestionOrderByWithRelationInput | ChoiceQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChoiceQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoiceQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoiceQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChoiceQuestions
    **/
    _count?: true | ChoiceQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChoiceQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChoiceQuestionMaxAggregateInputType
  }

  export type GetChoiceQuestionAggregateType<T extends ChoiceQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateChoiceQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChoiceQuestion[P]>
      : GetScalarType<T[P], AggregateChoiceQuestion[P]>
  }




  export type ChoiceQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoiceQuestionWhereInput
    orderBy?: ChoiceQuestionOrderByWithAggregationInput | ChoiceQuestionOrderByWithAggregationInput[]
    by: ChoiceQuestionScalarFieldEnum[] | ChoiceQuestionScalarFieldEnum
    having?: ChoiceQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChoiceQuestionCountAggregateInputType | true
    _min?: ChoiceQuestionMinAggregateInputType
    _max?: ChoiceQuestionMaxAggregateInputType
  }

  export type ChoiceQuestionGroupByOutputType = {
    id: string
    text: string
    description: string | null
    correct_choice: string
    created_at: Date
    updated_at: Date
    _count: ChoiceQuestionCountAggregateOutputType | null
    _min: ChoiceQuestionMinAggregateOutputType | null
    _max: ChoiceQuestionMaxAggregateOutputType | null
  }

  type GetChoiceQuestionGroupByPayload<T extends ChoiceQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChoiceQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChoiceQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChoiceQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], ChoiceQuestionGroupByOutputType[P]>
        }
      >
    >


  export type ChoiceQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    description?: boolean
    correct_choice?: boolean
    created_at?: boolean
    updated_at?: boolean
    answers?: boolean | ChoiceQuestion$answersArgs<ExtArgs>
    _count?: boolean | ChoiceQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["choiceQuestion"]>

  export type ChoiceQuestionSelectScalar = {
    id?: boolean
    text?: boolean
    description?: boolean
    correct_choice?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ChoiceQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | ChoiceQuestion$answersArgs<ExtArgs>
    _count?: boolean | ChoiceQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ChoiceQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChoiceQuestion"
    objects: {
      answers: Prisma.$ChoiceAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      text: string
      description: string | null
      correct_choice: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["choiceQuestion"]>
    composites: {}
  }


  type ChoiceQuestionGetPayload<S extends boolean | null | undefined | ChoiceQuestionDefaultArgs> = $Result.GetResult<Prisma.$ChoiceQuestionPayload, S>

  type ChoiceQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChoiceQuestionFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ChoiceQuestionCountAggregateInputType | true
    }

  export interface ChoiceQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChoiceQuestion'], meta: { name: 'ChoiceQuestion' } }
    /**
     * Find zero or one ChoiceQuestion that matches the filter.
     * @param {ChoiceQuestionFindUniqueArgs} args - Arguments to find a ChoiceQuestion
     * @example
     * // Get one ChoiceQuestion
     * const choiceQuestion = await prisma.choiceQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChoiceQuestionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ChoiceQuestionFindUniqueArgs<ExtArgs>>
    ): Prisma__ChoiceQuestionClient<$Result.GetResult<Prisma.$ChoiceQuestionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ChoiceQuestion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChoiceQuestionFindUniqueOrThrowArgs} args - Arguments to find a ChoiceQuestion
     * @example
     * // Get one ChoiceQuestion
     * const choiceQuestion = await prisma.choiceQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChoiceQuestionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ChoiceQuestionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ChoiceQuestionClient<$Result.GetResult<Prisma.$ChoiceQuestionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ChoiceQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceQuestionFindFirstArgs} args - Arguments to find a ChoiceQuestion
     * @example
     * // Get one ChoiceQuestion
     * const choiceQuestion = await prisma.choiceQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChoiceQuestionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ChoiceQuestionFindFirstArgs<ExtArgs>>
    ): Prisma__ChoiceQuestionClient<$Result.GetResult<Prisma.$ChoiceQuestionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ChoiceQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceQuestionFindFirstOrThrowArgs} args - Arguments to find a ChoiceQuestion
     * @example
     * // Get one ChoiceQuestion
     * const choiceQuestion = await prisma.choiceQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChoiceQuestionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ChoiceQuestionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ChoiceQuestionClient<$Result.GetResult<Prisma.$ChoiceQuestionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ChoiceQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceQuestionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChoiceQuestions
     * const choiceQuestions = await prisma.choiceQuestion.findMany()
     * 
     * // Get first 10 ChoiceQuestions
     * const choiceQuestions = await prisma.choiceQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const choiceQuestionWithIdOnly = await prisma.choiceQuestion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChoiceQuestionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChoiceQuestionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoiceQuestionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ChoiceQuestion.
     * @param {ChoiceQuestionCreateArgs} args - Arguments to create a ChoiceQuestion.
     * @example
     * // Create one ChoiceQuestion
     * const ChoiceQuestion = await prisma.choiceQuestion.create({
     *   data: {
     *     // ... data to create a ChoiceQuestion
     *   }
     * })
     * 
    **/
    create<T extends ChoiceQuestionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ChoiceQuestionCreateArgs<ExtArgs>>
    ): Prisma__ChoiceQuestionClient<$Result.GetResult<Prisma.$ChoiceQuestionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ChoiceQuestions.
     *     @param {ChoiceQuestionCreateManyArgs} args - Arguments to create many ChoiceQuestions.
     *     @example
     *     // Create many ChoiceQuestions
     *     const choiceQuestion = await prisma.choiceQuestion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChoiceQuestionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChoiceQuestionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChoiceQuestion.
     * @param {ChoiceQuestionDeleteArgs} args - Arguments to delete one ChoiceQuestion.
     * @example
     * // Delete one ChoiceQuestion
     * const ChoiceQuestion = await prisma.choiceQuestion.delete({
     *   where: {
     *     // ... filter to delete one ChoiceQuestion
     *   }
     * })
     * 
    **/
    delete<T extends ChoiceQuestionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ChoiceQuestionDeleteArgs<ExtArgs>>
    ): Prisma__ChoiceQuestionClient<$Result.GetResult<Prisma.$ChoiceQuestionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ChoiceQuestion.
     * @param {ChoiceQuestionUpdateArgs} args - Arguments to update one ChoiceQuestion.
     * @example
     * // Update one ChoiceQuestion
     * const choiceQuestion = await prisma.choiceQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChoiceQuestionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ChoiceQuestionUpdateArgs<ExtArgs>>
    ): Prisma__ChoiceQuestionClient<$Result.GetResult<Prisma.$ChoiceQuestionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ChoiceQuestions.
     * @param {ChoiceQuestionDeleteManyArgs} args - Arguments to filter ChoiceQuestions to delete.
     * @example
     * // Delete a few ChoiceQuestions
     * const { count } = await prisma.choiceQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChoiceQuestionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChoiceQuestionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChoiceQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChoiceQuestions
     * const choiceQuestion = await prisma.choiceQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChoiceQuestionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ChoiceQuestionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChoiceQuestion.
     * @param {ChoiceQuestionUpsertArgs} args - Arguments to update or create a ChoiceQuestion.
     * @example
     * // Update or create a ChoiceQuestion
     * const choiceQuestion = await prisma.choiceQuestion.upsert({
     *   create: {
     *     // ... data to create a ChoiceQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChoiceQuestion we want to update
     *   }
     * })
    **/
    upsert<T extends ChoiceQuestionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ChoiceQuestionUpsertArgs<ExtArgs>>
    ): Prisma__ChoiceQuestionClient<$Result.GetResult<Prisma.$ChoiceQuestionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ChoiceQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceQuestionCountArgs} args - Arguments to filter ChoiceQuestions to count.
     * @example
     * // Count the number of ChoiceQuestions
     * const count = await prisma.choiceQuestion.count({
     *   where: {
     *     // ... the filter for the ChoiceQuestions we want to count
     *   }
     * })
    **/
    count<T extends ChoiceQuestionCountArgs>(
      args?: Subset<T, ChoiceQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChoiceQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChoiceQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChoiceQuestionAggregateArgs>(args: Subset<T, ChoiceQuestionAggregateArgs>): Prisma.PrismaPromise<GetChoiceQuestionAggregateType<T>>

    /**
     * Group by ChoiceQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChoiceQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChoiceQuestionGroupByArgs['orderBy'] }
        : { orderBy?: ChoiceQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChoiceQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChoiceQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChoiceQuestion model
   */
  readonly fields: ChoiceQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChoiceQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChoiceQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    answers<T extends ChoiceQuestion$answersArgs<ExtArgs> = {}>(args?: Subset<T, ChoiceQuestion$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoiceAnswerPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ChoiceQuestion model
   */ 
  interface ChoiceQuestionFieldRefs {
    readonly id: FieldRef<"ChoiceQuestion", 'String'>
    readonly text: FieldRef<"ChoiceQuestion", 'String'>
    readonly description: FieldRef<"ChoiceQuestion", 'String'>
    readonly correct_choice: FieldRef<"ChoiceQuestion", 'String'>
    readonly created_at: FieldRef<"ChoiceQuestion", 'DateTime'>
    readonly updated_at: FieldRef<"ChoiceQuestion", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ChoiceQuestion findUnique
   */
  export type ChoiceQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceQuestion
     */
    select?: ChoiceQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ChoiceQuestion to fetch.
     */
    where: ChoiceQuestionWhereUniqueInput
  }


  /**
   * ChoiceQuestion findUniqueOrThrow
   */
  export type ChoiceQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceQuestion
     */
    select?: ChoiceQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ChoiceQuestion to fetch.
     */
    where: ChoiceQuestionWhereUniqueInput
  }


  /**
   * ChoiceQuestion findFirst
   */
  export type ChoiceQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceQuestion
     */
    select?: ChoiceQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ChoiceQuestion to fetch.
     */
    where?: ChoiceQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoiceQuestions to fetch.
     */
    orderBy?: ChoiceQuestionOrderByWithRelationInput | ChoiceQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChoiceQuestions.
     */
    cursor?: ChoiceQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoiceQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoiceQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChoiceQuestions.
     */
    distinct?: ChoiceQuestionScalarFieldEnum | ChoiceQuestionScalarFieldEnum[]
  }


  /**
   * ChoiceQuestion findFirstOrThrow
   */
  export type ChoiceQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceQuestion
     */
    select?: ChoiceQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ChoiceQuestion to fetch.
     */
    where?: ChoiceQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoiceQuestions to fetch.
     */
    orderBy?: ChoiceQuestionOrderByWithRelationInput | ChoiceQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChoiceQuestions.
     */
    cursor?: ChoiceQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoiceQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoiceQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChoiceQuestions.
     */
    distinct?: ChoiceQuestionScalarFieldEnum | ChoiceQuestionScalarFieldEnum[]
  }


  /**
   * ChoiceQuestion findMany
   */
  export type ChoiceQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceQuestion
     */
    select?: ChoiceQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ChoiceQuestions to fetch.
     */
    where?: ChoiceQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoiceQuestions to fetch.
     */
    orderBy?: ChoiceQuestionOrderByWithRelationInput | ChoiceQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChoiceQuestions.
     */
    cursor?: ChoiceQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoiceQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoiceQuestions.
     */
    skip?: number
    distinct?: ChoiceQuestionScalarFieldEnum | ChoiceQuestionScalarFieldEnum[]
  }


  /**
   * ChoiceQuestion create
   */
  export type ChoiceQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceQuestion
     */
    select?: ChoiceQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a ChoiceQuestion.
     */
    data: XOR<ChoiceQuestionCreateInput, ChoiceQuestionUncheckedCreateInput>
  }


  /**
   * ChoiceQuestion createMany
   */
  export type ChoiceQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChoiceQuestions.
     */
    data: ChoiceQuestionCreateManyInput | ChoiceQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ChoiceQuestion update
   */
  export type ChoiceQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceQuestion
     */
    select?: ChoiceQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a ChoiceQuestion.
     */
    data: XOR<ChoiceQuestionUpdateInput, ChoiceQuestionUncheckedUpdateInput>
    /**
     * Choose, which ChoiceQuestion to update.
     */
    where: ChoiceQuestionWhereUniqueInput
  }


  /**
   * ChoiceQuestion updateMany
   */
  export type ChoiceQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChoiceQuestions.
     */
    data: XOR<ChoiceQuestionUpdateManyMutationInput, ChoiceQuestionUncheckedUpdateManyInput>
    /**
     * Filter which ChoiceQuestions to update
     */
    where?: ChoiceQuestionWhereInput
  }


  /**
   * ChoiceQuestion upsert
   */
  export type ChoiceQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceQuestion
     */
    select?: ChoiceQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the ChoiceQuestion to update in case it exists.
     */
    where: ChoiceQuestionWhereUniqueInput
    /**
     * In case the ChoiceQuestion found by the `where` argument doesn't exist, create a new ChoiceQuestion with this data.
     */
    create: XOR<ChoiceQuestionCreateInput, ChoiceQuestionUncheckedCreateInput>
    /**
     * In case the ChoiceQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChoiceQuestionUpdateInput, ChoiceQuestionUncheckedUpdateInput>
  }


  /**
   * ChoiceQuestion delete
   */
  export type ChoiceQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceQuestion
     */
    select?: ChoiceQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceQuestionInclude<ExtArgs> | null
    /**
     * Filter which ChoiceQuestion to delete.
     */
    where: ChoiceQuestionWhereUniqueInput
  }


  /**
   * ChoiceQuestion deleteMany
   */
  export type ChoiceQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChoiceQuestions to delete
     */
    where?: ChoiceQuestionWhereInput
  }


  /**
   * ChoiceQuestion.answers
   */
  export type ChoiceQuestion$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceAnswer
     */
    select?: ChoiceAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceAnswerInclude<ExtArgs> | null
    where?: ChoiceAnswerWhereInput
    orderBy?: ChoiceAnswerOrderByWithRelationInput | ChoiceAnswerOrderByWithRelationInput[]
    cursor?: ChoiceAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChoiceAnswerScalarFieldEnum | ChoiceAnswerScalarFieldEnum[]
  }


  /**
   * ChoiceQuestion without action
   */
  export type ChoiceQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceQuestion
     */
    select?: ChoiceQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceQuestionInclude<ExtArgs> | null
  }



  /**
   * Model ChoiceAnswer
   */

  export type AggregateChoiceAnswer = {
    _count: ChoiceAnswerCountAggregateOutputType | null
    _min: ChoiceAnswerMinAggregateOutputType | null
    _max: ChoiceAnswerMaxAggregateOutputType | null
  }

  export type ChoiceAnswerMinAggregateOutputType = {
    id: string | null
    questionId: string | null
    key: string | null
    value: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChoiceAnswerMaxAggregateOutputType = {
    id: string | null
    questionId: string | null
    key: string | null
    value: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChoiceAnswerCountAggregateOutputType = {
    id: number
    questionId: number
    key: number
    value: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ChoiceAnswerMinAggregateInputType = {
    id?: true
    questionId?: true
    key?: true
    value?: true
    created_at?: true
    updated_at?: true
  }

  export type ChoiceAnswerMaxAggregateInputType = {
    id?: true
    questionId?: true
    key?: true
    value?: true
    created_at?: true
    updated_at?: true
  }

  export type ChoiceAnswerCountAggregateInputType = {
    id?: true
    questionId?: true
    key?: true
    value?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ChoiceAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChoiceAnswer to aggregate.
     */
    where?: ChoiceAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoiceAnswers to fetch.
     */
    orderBy?: ChoiceAnswerOrderByWithRelationInput | ChoiceAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChoiceAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoiceAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoiceAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChoiceAnswers
    **/
    _count?: true | ChoiceAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChoiceAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChoiceAnswerMaxAggregateInputType
  }

  export type GetChoiceAnswerAggregateType<T extends ChoiceAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateChoiceAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChoiceAnswer[P]>
      : GetScalarType<T[P], AggregateChoiceAnswer[P]>
  }




  export type ChoiceAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoiceAnswerWhereInput
    orderBy?: ChoiceAnswerOrderByWithAggregationInput | ChoiceAnswerOrderByWithAggregationInput[]
    by: ChoiceAnswerScalarFieldEnum[] | ChoiceAnswerScalarFieldEnum
    having?: ChoiceAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChoiceAnswerCountAggregateInputType | true
    _min?: ChoiceAnswerMinAggregateInputType
    _max?: ChoiceAnswerMaxAggregateInputType
  }

  export type ChoiceAnswerGroupByOutputType = {
    id: string
    questionId: string
    key: string
    value: string
    created_at: Date
    updated_at: Date
    _count: ChoiceAnswerCountAggregateOutputType | null
    _min: ChoiceAnswerMinAggregateOutputType | null
    _max: ChoiceAnswerMaxAggregateOutputType | null
  }

  type GetChoiceAnswerGroupByPayload<T extends ChoiceAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChoiceAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChoiceAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChoiceAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], ChoiceAnswerGroupByOutputType[P]>
        }
      >
    >


  export type ChoiceAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    key?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
    question?: boolean | ChoiceQuestionDefaultArgs<ExtArgs>
    choice_answer_applys?: boolean | ChoiceAnswer$choice_answer_applysArgs<ExtArgs>
    _count?: boolean | ChoiceAnswerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["choiceAnswer"]>

  export type ChoiceAnswerSelectScalar = {
    id?: boolean
    questionId?: boolean
    key?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ChoiceAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | ChoiceQuestionDefaultArgs<ExtArgs>
    choice_answer_applys?: boolean | ChoiceAnswer$choice_answer_applysArgs<ExtArgs>
    _count?: boolean | ChoiceAnswerCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ChoiceAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChoiceAnswer"
    objects: {
      question: Prisma.$ChoiceQuestionPayload<ExtArgs>
      choice_answer_applys: Prisma.$ChoiceAnswerApplyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      questionId: string
      key: string
      value: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["choiceAnswer"]>
    composites: {}
  }


  type ChoiceAnswerGetPayload<S extends boolean | null | undefined | ChoiceAnswerDefaultArgs> = $Result.GetResult<Prisma.$ChoiceAnswerPayload, S>

  type ChoiceAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChoiceAnswerFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ChoiceAnswerCountAggregateInputType | true
    }

  export interface ChoiceAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChoiceAnswer'], meta: { name: 'ChoiceAnswer' } }
    /**
     * Find zero or one ChoiceAnswer that matches the filter.
     * @param {ChoiceAnswerFindUniqueArgs} args - Arguments to find a ChoiceAnswer
     * @example
     * // Get one ChoiceAnswer
     * const choiceAnswer = await prisma.choiceAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChoiceAnswerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ChoiceAnswerFindUniqueArgs<ExtArgs>>
    ): Prisma__ChoiceAnswerClient<$Result.GetResult<Prisma.$ChoiceAnswerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ChoiceAnswer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChoiceAnswerFindUniqueOrThrowArgs} args - Arguments to find a ChoiceAnswer
     * @example
     * // Get one ChoiceAnswer
     * const choiceAnswer = await prisma.choiceAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChoiceAnswerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ChoiceAnswerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ChoiceAnswerClient<$Result.GetResult<Prisma.$ChoiceAnswerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ChoiceAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceAnswerFindFirstArgs} args - Arguments to find a ChoiceAnswer
     * @example
     * // Get one ChoiceAnswer
     * const choiceAnswer = await prisma.choiceAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChoiceAnswerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ChoiceAnswerFindFirstArgs<ExtArgs>>
    ): Prisma__ChoiceAnswerClient<$Result.GetResult<Prisma.$ChoiceAnswerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ChoiceAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceAnswerFindFirstOrThrowArgs} args - Arguments to find a ChoiceAnswer
     * @example
     * // Get one ChoiceAnswer
     * const choiceAnswer = await prisma.choiceAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChoiceAnswerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ChoiceAnswerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ChoiceAnswerClient<$Result.GetResult<Prisma.$ChoiceAnswerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ChoiceAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceAnswerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChoiceAnswers
     * const choiceAnswers = await prisma.choiceAnswer.findMany()
     * 
     * // Get first 10 ChoiceAnswers
     * const choiceAnswers = await prisma.choiceAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const choiceAnswerWithIdOnly = await prisma.choiceAnswer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChoiceAnswerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChoiceAnswerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoiceAnswerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ChoiceAnswer.
     * @param {ChoiceAnswerCreateArgs} args - Arguments to create a ChoiceAnswer.
     * @example
     * // Create one ChoiceAnswer
     * const ChoiceAnswer = await prisma.choiceAnswer.create({
     *   data: {
     *     // ... data to create a ChoiceAnswer
     *   }
     * })
     * 
    **/
    create<T extends ChoiceAnswerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ChoiceAnswerCreateArgs<ExtArgs>>
    ): Prisma__ChoiceAnswerClient<$Result.GetResult<Prisma.$ChoiceAnswerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ChoiceAnswers.
     *     @param {ChoiceAnswerCreateManyArgs} args - Arguments to create many ChoiceAnswers.
     *     @example
     *     // Create many ChoiceAnswers
     *     const choiceAnswer = await prisma.choiceAnswer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChoiceAnswerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChoiceAnswerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChoiceAnswer.
     * @param {ChoiceAnswerDeleteArgs} args - Arguments to delete one ChoiceAnswer.
     * @example
     * // Delete one ChoiceAnswer
     * const ChoiceAnswer = await prisma.choiceAnswer.delete({
     *   where: {
     *     // ... filter to delete one ChoiceAnswer
     *   }
     * })
     * 
    **/
    delete<T extends ChoiceAnswerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ChoiceAnswerDeleteArgs<ExtArgs>>
    ): Prisma__ChoiceAnswerClient<$Result.GetResult<Prisma.$ChoiceAnswerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ChoiceAnswer.
     * @param {ChoiceAnswerUpdateArgs} args - Arguments to update one ChoiceAnswer.
     * @example
     * // Update one ChoiceAnswer
     * const choiceAnswer = await prisma.choiceAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChoiceAnswerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ChoiceAnswerUpdateArgs<ExtArgs>>
    ): Prisma__ChoiceAnswerClient<$Result.GetResult<Prisma.$ChoiceAnswerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ChoiceAnswers.
     * @param {ChoiceAnswerDeleteManyArgs} args - Arguments to filter ChoiceAnswers to delete.
     * @example
     * // Delete a few ChoiceAnswers
     * const { count } = await prisma.choiceAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChoiceAnswerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChoiceAnswerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChoiceAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChoiceAnswers
     * const choiceAnswer = await prisma.choiceAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChoiceAnswerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ChoiceAnswerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChoiceAnswer.
     * @param {ChoiceAnswerUpsertArgs} args - Arguments to update or create a ChoiceAnswer.
     * @example
     * // Update or create a ChoiceAnswer
     * const choiceAnswer = await prisma.choiceAnswer.upsert({
     *   create: {
     *     // ... data to create a ChoiceAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChoiceAnswer we want to update
     *   }
     * })
    **/
    upsert<T extends ChoiceAnswerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ChoiceAnswerUpsertArgs<ExtArgs>>
    ): Prisma__ChoiceAnswerClient<$Result.GetResult<Prisma.$ChoiceAnswerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ChoiceAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceAnswerCountArgs} args - Arguments to filter ChoiceAnswers to count.
     * @example
     * // Count the number of ChoiceAnswers
     * const count = await prisma.choiceAnswer.count({
     *   where: {
     *     // ... the filter for the ChoiceAnswers we want to count
     *   }
     * })
    **/
    count<T extends ChoiceAnswerCountArgs>(
      args?: Subset<T, ChoiceAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChoiceAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChoiceAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChoiceAnswerAggregateArgs>(args: Subset<T, ChoiceAnswerAggregateArgs>): Prisma.PrismaPromise<GetChoiceAnswerAggregateType<T>>

    /**
     * Group by ChoiceAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChoiceAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChoiceAnswerGroupByArgs['orderBy'] }
        : { orderBy?: ChoiceAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChoiceAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChoiceAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChoiceAnswer model
   */
  readonly fields: ChoiceAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChoiceAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChoiceAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    question<T extends ChoiceQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChoiceQuestionDefaultArgs<ExtArgs>>): Prisma__ChoiceQuestionClient<$Result.GetResult<Prisma.$ChoiceQuestionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    choice_answer_applys<T extends ChoiceAnswer$choice_answer_applysArgs<ExtArgs> = {}>(args?: Subset<T, ChoiceAnswer$choice_answer_applysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoiceAnswerApplyPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ChoiceAnswer model
   */ 
  interface ChoiceAnswerFieldRefs {
    readonly id: FieldRef<"ChoiceAnswer", 'String'>
    readonly questionId: FieldRef<"ChoiceAnswer", 'String'>
    readonly key: FieldRef<"ChoiceAnswer", 'String'>
    readonly value: FieldRef<"ChoiceAnswer", 'String'>
    readonly created_at: FieldRef<"ChoiceAnswer", 'DateTime'>
    readonly updated_at: FieldRef<"ChoiceAnswer", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ChoiceAnswer findUnique
   */
  export type ChoiceAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceAnswer
     */
    select?: ChoiceAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceAnswerInclude<ExtArgs> | null
    /**
     * Filter, which ChoiceAnswer to fetch.
     */
    where: ChoiceAnswerWhereUniqueInput
  }


  /**
   * ChoiceAnswer findUniqueOrThrow
   */
  export type ChoiceAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceAnswer
     */
    select?: ChoiceAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceAnswerInclude<ExtArgs> | null
    /**
     * Filter, which ChoiceAnswer to fetch.
     */
    where: ChoiceAnswerWhereUniqueInput
  }


  /**
   * ChoiceAnswer findFirst
   */
  export type ChoiceAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceAnswer
     */
    select?: ChoiceAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceAnswerInclude<ExtArgs> | null
    /**
     * Filter, which ChoiceAnswer to fetch.
     */
    where?: ChoiceAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoiceAnswers to fetch.
     */
    orderBy?: ChoiceAnswerOrderByWithRelationInput | ChoiceAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChoiceAnswers.
     */
    cursor?: ChoiceAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoiceAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoiceAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChoiceAnswers.
     */
    distinct?: ChoiceAnswerScalarFieldEnum | ChoiceAnswerScalarFieldEnum[]
  }


  /**
   * ChoiceAnswer findFirstOrThrow
   */
  export type ChoiceAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceAnswer
     */
    select?: ChoiceAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceAnswerInclude<ExtArgs> | null
    /**
     * Filter, which ChoiceAnswer to fetch.
     */
    where?: ChoiceAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoiceAnswers to fetch.
     */
    orderBy?: ChoiceAnswerOrderByWithRelationInput | ChoiceAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChoiceAnswers.
     */
    cursor?: ChoiceAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoiceAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoiceAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChoiceAnswers.
     */
    distinct?: ChoiceAnswerScalarFieldEnum | ChoiceAnswerScalarFieldEnum[]
  }


  /**
   * ChoiceAnswer findMany
   */
  export type ChoiceAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceAnswer
     */
    select?: ChoiceAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceAnswerInclude<ExtArgs> | null
    /**
     * Filter, which ChoiceAnswers to fetch.
     */
    where?: ChoiceAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoiceAnswers to fetch.
     */
    orderBy?: ChoiceAnswerOrderByWithRelationInput | ChoiceAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChoiceAnswers.
     */
    cursor?: ChoiceAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoiceAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoiceAnswers.
     */
    skip?: number
    distinct?: ChoiceAnswerScalarFieldEnum | ChoiceAnswerScalarFieldEnum[]
  }


  /**
   * ChoiceAnswer create
   */
  export type ChoiceAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceAnswer
     */
    select?: ChoiceAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a ChoiceAnswer.
     */
    data: XOR<ChoiceAnswerCreateInput, ChoiceAnswerUncheckedCreateInput>
  }


  /**
   * ChoiceAnswer createMany
   */
  export type ChoiceAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChoiceAnswers.
     */
    data: ChoiceAnswerCreateManyInput | ChoiceAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ChoiceAnswer update
   */
  export type ChoiceAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceAnswer
     */
    select?: ChoiceAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a ChoiceAnswer.
     */
    data: XOR<ChoiceAnswerUpdateInput, ChoiceAnswerUncheckedUpdateInput>
    /**
     * Choose, which ChoiceAnswer to update.
     */
    where: ChoiceAnswerWhereUniqueInput
  }


  /**
   * ChoiceAnswer updateMany
   */
  export type ChoiceAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChoiceAnswers.
     */
    data: XOR<ChoiceAnswerUpdateManyMutationInput, ChoiceAnswerUncheckedUpdateManyInput>
    /**
     * Filter which ChoiceAnswers to update
     */
    where?: ChoiceAnswerWhereInput
  }


  /**
   * ChoiceAnswer upsert
   */
  export type ChoiceAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceAnswer
     */
    select?: ChoiceAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the ChoiceAnswer to update in case it exists.
     */
    where: ChoiceAnswerWhereUniqueInput
    /**
     * In case the ChoiceAnswer found by the `where` argument doesn't exist, create a new ChoiceAnswer with this data.
     */
    create: XOR<ChoiceAnswerCreateInput, ChoiceAnswerUncheckedCreateInput>
    /**
     * In case the ChoiceAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChoiceAnswerUpdateInput, ChoiceAnswerUncheckedUpdateInput>
  }


  /**
   * ChoiceAnswer delete
   */
  export type ChoiceAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceAnswer
     */
    select?: ChoiceAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceAnswerInclude<ExtArgs> | null
    /**
     * Filter which ChoiceAnswer to delete.
     */
    where: ChoiceAnswerWhereUniqueInput
  }


  /**
   * ChoiceAnswer deleteMany
   */
  export type ChoiceAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChoiceAnswers to delete
     */
    where?: ChoiceAnswerWhereInput
  }


  /**
   * ChoiceAnswer.choice_answer_applys
   */
  export type ChoiceAnswer$choice_answer_applysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceAnswerApply
     */
    select?: ChoiceAnswerApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceAnswerApplyInclude<ExtArgs> | null
    where?: ChoiceAnswerApplyWhereInput
    orderBy?: ChoiceAnswerApplyOrderByWithRelationInput | ChoiceAnswerApplyOrderByWithRelationInput[]
    cursor?: ChoiceAnswerApplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChoiceAnswerApplyScalarFieldEnum | ChoiceAnswerApplyScalarFieldEnum[]
  }


  /**
   * ChoiceAnswer without action
   */
  export type ChoiceAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceAnswer
     */
    select?: ChoiceAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceAnswerInclude<ExtArgs> | null
  }



  /**
   * Model ChoiceAnswerApply
   */

  export type AggregateChoiceAnswerApply = {
    _count: ChoiceAnswerApplyCountAggregateOutputType | null
    _min: ChoiceAnswerApplyMinAggregateOutputType | null
    _max: ChoiceAnswerApplyMaxAggregateOutputType | null
  }

  export type ChoiceAnswerApplyMinAggregateOutputType = {
    id: string | null
    teacherId: string | null
    answerId: string | null
    key: string | null
    is_correct: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChoiceAnswerApplyMaxAggregateOutputType = {
    id: string | null
    teacherId: string | null
    answerId: string | null
    key: string | null
    is_correct: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChoiceAnswerApplyCountAggregateOutputType = {
    id: number
    teacherId: number
    answerId: number
    key: number
    is_correct: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ChoiceAnswerApplyMinAggregateInputType = {
    id?: true
    teacherId?: true
    answerId?: true
    key?: true
    is_correct?: true
    created_at?: true
    updated_at?: true
  }

  export type ChoiceAnswerApplyMaxAggregateInputType = {
    id?: true
    teacherId?: true
    answerId?: true
    key?: true
    is_correct?: true
    created_at?: true
    updated_at?: true
  }

  export type ChoiceAnswerApplyCountAggregateInputType = {
    id?: true
    teacherId?: true
    answerId?: true
    key?: true
    is_correct?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ChoiceAnswerApplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChoiceAnswerApply to aggregate.
     */
    where?: ChoiceAnswerApplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoiceAnswerApplies to fetch.
     */
    orderBy?: ChoiceAnswerApplyOrderByWithRelationInput | ChoiceAnswerApplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChoiceAnswerApplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoiceAnswerApplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoiceAnswerApplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChoiceAnswerApplies
    **/
    _count?: true | ChoiceAnswerApplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChoiceAnswerApplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChoiceAnswerApplyMaxAggregateInputType
  }

  export type GetChoiceAnswerApplyAggregateType<T extends ChoiceAnswerApplyAggregateArgs> = {
        [P in keyof T & keyof AggregateChoiceAnswerApply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChoiceAnswerApply[P]>
      : GetScalarType<T[P], AggregateChoiceAnswerApply[P]>
  }




  export type ChoiceAnswerApplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoiceAnswerApplyWhereInput
    orderBy?: ChoiceAnswerApplyOrderByWithAggregationInput | ChoiceAnswerApplyOrderByWithAggregationInput[]
    by: ChoiceAnswerApplyScalarFieldEnum[] | ChoiceAnswerApplyScalarFieldEnum
    having?: ChoiceAnswerApplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChoiceAnswerApplyCountAggregateInputType | true
    _min?: ChoiceAnswerApplyMinAggregateInputType
    _max?: ChoiceAnswerApplyMaxAggregateInputType
  }

  export type ChoiceAnswerApplyGroupByOutputType = {
    id: string
    teacherId: string
    answerId: string
    key: string
    is_correct: boolean | null
    created_at: Date
    updated_at: Date
    _count: ChoiceAnswerApplyCountAggregateOutputType | null
    _min: ChoiceAnswerApplyMinAggregateOutputType | null
    _max: ChoiceAnswerApplyMaxAggregateOutputType | null
  }

  type GetChoiceAnswerApplyGroupByPayload<T extends ChoiceAnswerApplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChoiceAnswerApplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChoiceAnswerApplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChoiceAnswerApplyGroupByOutputType[P]>
            : GetScalarType<T[P], ChoiceAnswerApplyGroupByOutputType[P]>
        }
      >
    >


  export type ChoiceAnswerApplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    answerId?: boolean
    key?: boolean
    is_correct?: boolean
    created_at?: boolean
    updated_at?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    answer?: boolean | ChoiceAnswerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["choiceAnswerApply"]>

  export type ChoiceAnswerApplySelectScalar = {
    id?: boolean
    teacherId?: boolean
    answerId?: boolean
    key?: boolean
    is_correct?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ChoiceAnswerApplyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    answer?: boolean | ChoiceAnswerDefaultArgs<ExtArgs>
  }


  export type $ChoiceAnswerApplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChoiceAnswerApply"
    objects: {
      teacher: Prisma.$TeacherPayload<ExtArgs>
      answer: Prisma.$ChoiceAnswerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teacherId: string
      answerId: string
      key: string
      is_correct: boolean | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["choiceAnswerApply"]>
    composites: {}
  }


  type ChoiceAnswerApplyGetPayload<S extends boolean | null | undefined | ChoiceAnswerApplyDefaultArgs> = $Result.GetResult<Prisma.$ChoiceAnswerApplyPayload, S>

  type ChoiceAnswerApplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChoiceAnswerApplyFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ChoiceAnswerApplyCountAggregateInputType | true
    }

  export interface ChoiceAnswerApplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChoiceAnswerApply'], meta: { name: 'ChoiceAnswerApply' } }
    /**
     * Find zero or one ChoiceAnswerApply that matches the filter.
     * @param {ChoiceAnswerApplyFindUniqueArgs} args - Arguments to find a ChoiceAnswerApply
     * @example
     * // Get one ChoiceAnswerApply
     * const choiceAnswerApply = await prisma.choiceAnswerApply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChoiceAnswerApplyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ChoiceAnswerApplyFindUniqueArgs<ExtArgs>>
    ): Prisma__ChoiceAnswerApplyClient<$Result.GetResult<Prisma.$ChoiceAnswerApplyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ChoiceAnswerApply that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChoiceAnswerApplyFindUniqueOrThrowArgs} args - Arguments to find a ChoiceAnswerApply
     * @example
     * // Get one ChoiceAnswerApply
     * const choiceAnswerApply = await prisma.choiceAnswerApply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChoiceAnswerApplyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ChoiceAnswerApplyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ChoiceAnswerApplyClient<$Result.GetResult<Prisma.$ChoiceAnswerApplyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ChoiceAnswerApply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceAnswerApplyFindFirstArgs} args - Arguments to find a ChoiceAnswerApply
     * @example
     * // Get one ChoiceAnswerApply
     * const choiceAnswerApply = await prisma.choiceAnswerApply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChoiceAnswerApplyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ChoiceAnswerApplyFindFirstArgs<ExtArgs>>
    ): Prisma__ChoiceAnswerApplyClient<$Result.GetResult<Prisma.$ChoiceAnswerApplyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ChoiceAnswerApply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceAnswerApplyFindFirstOrThrowArgs} args - Arguments to find a ChoiceAnswerApply
     * @example
     * // Get one ChoiceAnswerApply
     * const choiceAnswerApply = await prisma.choiceAnswerApply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChoiceAnswerApplyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ChoiceAnswerApplyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ChoiceAnswerApplyClient<$Result.GetResult<Prisma.$ChoiceAnswerApplyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ChoiceAnswerApplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceAnswerApplyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChoiceAnswerApplies
     * const choiceAnswerApplies = await prisma.choiceAnswerApply.findMany()
     * 
     * // Get first 10 ChoiceAnswerApplies
     * const choiceAnswerApplies = await prisma.choiceAnswerApply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const choiceAnswerApplyWithIdOnly = await prisma.choiceAnswerApply.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChoiceAnswerApplyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChoiceAnswerApplyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoiceAnswerApplyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ChoiceAnswerApply.
     * @param {ChoiceAnswerApplyCreateArgs} args - Arguments to create a ChoiceAnswerApply.
     * @example
     * // Create one ChoiceAnswerApply
     * const ChoiceAnswerApply = await prisma.choiceAnswerApply.create({
     *   data: {
     *     // ... data to create a ChoiceAnswerApply
     *   }
     * })
     * 
    **/
    create<T extends ChoiceAnswerApplyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ChoiceAnswerApplyCreateArgs<ExtArgs>>
    ): Prisma__ChoiceAnswerApplyClient<$Result.GetResult<Prisma.$ChoiceAnswerApplyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ChoiceAnswerApplies.
     *     @param {ChoiceAnswerApplyCreateManyArgs} args - Arguments to create many ChoiceAnswerApplies.
     *     @example
     *     // Create many ChoiceAnswerApplies
     *     const choiceAnswerApply = await prisma.choiceAnswerApply.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChoiceAnswerApplyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChoiceAnswerApplyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChoiceAnswerApply.
     * @param {ChoiceAnswerApplyDeleteArgs} args - Arguments to delete one ChoiceAnswerApply.
     * @example
     * // Delete one ChoiceAnswerApply
     * const ChoiceAnswerApply = await prisma.choiceAnswerApply.delete({
     *   where: {
     *     // ... filter to delete one ChoiceAnswerApply
     *   }
     * })
     * 
    **/
    delete<T extends ChoiceAnswerApplyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ChoiceAnswerApplyDeleteArgs<ExtArgs>>
    ): Prisma__ChoiceAnswerApplyClient<$Result.GetResult<Prisma.$ChoiceAnswerApplyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ChoiceAnswerApply.
     * @param {ChoiceAnswerApplyUpdateArgs} args - Arguments to update one ChoiceAnswerApply.
     * @example
     * // Update one ChoiceAnswerApply
     * const choiceAnswerApply = await prisma.choiceAnswerApply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChoiceAnswerApplyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ChoiceAnswerApplyUpdateArgs<ExtArgs>>
    ): Prisma__ChoiceAnswerApplyClient<$Result.GetResult<Prisma.$ChoiceAnswerApplyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ChoiceAnswerApplies.
     * @param {ChoiceAnswerApplyDeleteManyArgs} args - Arguments to filter ChoiceAnswerApplies to delete.
     * @example
     * // Delete a few ChoiceAnswerApplies
     * const { count } = await prisma.choiceAnswerApply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChoiceAnswerApplyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChoiceAnswerApplyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChoiceAnswerApplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceAnswerApplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChoiceAnswerApplies
     * const choiceAnswerApply = await prisma.choiceAnswerApply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChoiceAnswerApplyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ChoiceAnswerApplyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChoiceAnswerApply.
     * @param {ChoiceAnswerApplyUpsertArgs} args - Arguments to update or create a ChoiceAnswerApply.
     * @example
     * // Update or create a ChoiceAnswerApply
     * const choiceAnswerApply = await prisma.choiceAnswerApply.upsert({
     *   create: {
     *     // ... data to create a ChoiceAnswerApply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChoiceAnswerApply we want to update
     *   }
     * })
    **/
    upsert<T extends ChoiceAnswerApplyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ChoiceAnswerApplyUpsertArgs<ExtArgs>>
    ): Prisma__ChoiceAnswerApplyClient<$Result.GetResult<Prisma.$ChoiceAnswerApplyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ChoiceAnswerApplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceAnswerApplyCountArgs} args - Arguments to filter ChoiceAnswerApplies to count.
     * @example
     * // Count the number of ChoiceAnswerApplies
     * const count = await prisma.choiceAnswerApply.count({
     *   where: {
     *     // ... the filter for the ChoiceAnswerApplies we want to count
     *   }
     * })
    **/
    count<T extends ChoiceAnswerApplyCountArgs>(
      args?: Subset<T, ChoiceAnswerApplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChoiceAnswerApplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChoiceAnswerApply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceAnswerApplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChoiceAnswerApplyAggregateArgs>(args: Subset<T, ChoiceAnswerApplyAggregateArgs>): Prisma.PrismaPromise<GetChoiceAnswerApplyAggregateType<T>>

    /**
     * Group by ChoiceAnswerApply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoiceAnswerApplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChoiceAnswerApplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChoiceAnswerApplyGroupByArgs['orderBy'] }
        : { orderBy?: ChoiceAnswerApplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChoiceAnswerApplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChoiceAnswerApplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChoiceAnswerApply model
   */
  readonly fields: ChoiceAnswerApplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChoiceAnswerApply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChoiceAnswerApplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    answer<T extends ChoiceAnswerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChoiceAnswerDefaultArgs<ExtArgs>>): Prisma__ChoiceAnswerClient<$Result.GetResult<Prisma.$ChoiceAnswerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ChoiceAnswerApply model
   */ 
  interface ChoiceAnswerApplyFieldRefs {
    readonly id: FieldRef<"ChoiceAnswerApply", 'String'>
    readonly teacherId: FieldRef<"ChoiceAnswerApply", 'String'>
    readonly answerId: FieldRef<"ChoiceAnswerApply", 'String'>
    readonly key: FieldRef<"ChoiceAnswerApply", 'String'>
    readonly is_correct: FieldRef<"ChoiceAnswerApply", 'Boolean'>
    readonly created_at: FieldRef<"ChoiceAnswerApply", 'DateTime'>
    readonly updated_at: FieldRef<"ChoiceAnswerApply", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ChoiceAnswerApply findUnique
   */
  export type ChoiceAnswerApplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceAnswerApply
     */
    select?: ChoiceAnswerApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceAnswerApplyInclude<ExtArgs> | null
    /**
     * Filter, which ChoiceAnswerApply to fetch.
     */
    where: ChoiceAnswerApplyWhereUniqueInput
  }


  /**
   * ChoiceAnswerApply findUniqueOrThrow
   */
  export type ChoiceAnswerApplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceAnswerApply
     */
    select?: ChoiceAnswerApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceAnswerApplyInclude<ExtArgs> | null
    /**
     * Filter, which ChoiceAnswerApply to fetch.
     */
    where: ChoiceAnswerApplyWhereUniqueInput
  }


  /**
   * ChoiceAnswerApply findFirst
   */
  export type ChoiceAnswerApplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceAnswerApply
     */
    select?: ChoiceAnswerApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceAnswerApplyInclude<ExtArgs> | null
    /**
     * Filter, which ChoiceAnswerApply to fetch.
     */
    where?: ChoiceAnswerApplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoiceAnswerApplies to fetch.
     */
    orderBy?: ChoiceAnswerApplyOrderByWithRelationInput | ChoiceAnswerApplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChoiceAnswerApplies.
     */
    cursor?: ChoiceAnswerApplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoiceAnswerApplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoiceAnswerApplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChoiceAnswerApplies.
     */
    distinct?: ChoiceAnswerApplyScalarFieldEnum | ChoiceAnswerApplyScalarFieldEnum[]
  }


  /**
   * ChoiceAnswerApply findFirstOrThrow
   */
  export type ChoiceAnswerApplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceAnswerApply
     */
    select?: ChoiceAnswerApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceAnswerApplyInclude<ExtArgs> | null
    /**
     * Filter, which ChoiceAnswerApply to fetch.
     */
    where?: ChoiceAnswerApplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoiceAnswerApplies to fetch.
     */
    orderBy?: ChoiceAnswerApplyOrderByWithRelationInput | ChoiceAnswerApplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChoiceAnswerApplies.
     */
    cursor?: ChoiceAnswerApplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoiceAnswerApplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoiceAnswerApplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChoiceAnswerApplies.
     */
    distinct?: ChoiceAnswerApplyScalarFieldEnum | ChoiceAnswerApplyScalarFieldEnum[]
  }


  /**
   * ChoiceAnswerApply findMany
   */
  export type ChoiceAnswerApplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceAnswerApply
     */
    select?: ChoiceAnswerApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceAnswerApplyInclude<ExtArgs> | null
    /**
     * Filter, which ChoiceAnswerApplies to fetch.
     */
    where?: ChoiceAnswerApplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoiceAnswerApplies to fetch.
     */
    orderBy?: ChoiceAnswerApplyOrderByWithRelationInput | ChoiceAnswerApplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChoiceAnswerApplies.
     */
    cursor?: ChoiceAnswerApplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoiceAnswerApplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoiceAnswerApplies.
     */
    skip?: number
    distinct?: ChoiceAnswerApplyScalarFieldEnum | ChoiceAnswerApplyScalarFieldEnum[]
  }


  /**
   * ChoiceAnswerApply create
   */
  export type ChoiceAnswerApplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceAnswerApply
     */
    select?: ChoiceAnswerApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceAnswerApplyInclude<ExtArgs> | null
    /**
     * The data needed to create a ChoiceAnswerApply.
     */
    data: XOR<ChoiceAnswerApplyCreateInput, ChoiceAnswerApplyUncheckedCreateInput>
  }


  /**
   * ChoiceAnswerApply createMany
   */
  export type ChoiceAnswerApplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChoiceAnswerApplies.
     */
    data: ChoiceAnswerApplyCreateManyInput | ChoiceAnswerApplyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ChoiceAnswerApply update
   */
  export type ChoiceAnswerApplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceAnswerApply
     */
    select?: ChoiceAnswerApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceAnswerApplyInclude<ExtArgs> | null
    /**
     * The data needed to update a ChoiceAnswerApply.
     */
    data: XOR<ChoiceAnswerApplyUpdateInput, ChoiceAnswerApplyUncheckedUpdateInput>
    /**
     * Choose, which ChoiceAnswerApply to update.
     */
    where: ChoiceAnswerApplyWhereUniqueInput
  }


  /**
   * ChoiceAnswerApply updateMany
   */
  export type ChoiceAnswerApplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChoiceAnswerApplies.
     */
    data: XOR<ChoiceAnswerApplyUpdateManyMutationInput, ChoiceAnswerApplyUncheckedUpdateManyInput>
    /**
     * Filter which ChoiceAnswerApplies to update
     */
    where?: ChoiceAnswerApplyWhereInput
  }


  /**
   * ChoiceAnswerApply upsert
   */
  export type ChoiceAnswerApplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceAnswerApply
     */
    select?: ChoiceAnswerApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceAnswerApplyInclude<ExtArgs> | null
    /**
     * The filter to search for the ChoiceAnswerApply to update in case it exists.
     */
    where: ChoiceAnswerApplyWhereUniqueInput
    /**
     * In case the ChoiceAnswerApply found by the `where` argument doesn't exist, create a new ChoiceAnswerApply with this data.
     */
    create: XOR<ChoiceAnswerApplyCreateInput, ChoiceAnswerApplyUncheckedCreateInput>
    /**
     * In case the ChoiceAnswerApply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChoiceAnswerApplyUpdateInput, ChoiceAnswerApplyUncheckedUpdateInput>
  }


  /**
   * ChoiceAnswerApply delete
   */
  export type ChoiceAnswerApplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceAnswerApply
     */
    select?: ChoiceAnswerApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceAnswerApplyInclude<ExtArgs> | null
    /**
     * Filter which ChoiceAnswerApply to delete.
     */
    where: ChoiceAnswerApplyWhereUniqueInput
  }


  /**
   * ChoiceAnswerApply deleteMany
   */
  export type ChoiceAnswerApplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChoiceAnswerApplies to delete
     */
    where?: ChoiceAnswerApplyWhereInput
  }


  /**
   * ChoiceAnswerApply without action
   */
  export type ChoiceAnswerApplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceAnswerApply
     */
    select?: ChoiceAnswerApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceAnswerApplyInclude<ExtArgs> | null
  }



  /**
   * Model WriteQuestion
   */

  export type AggregateWriteQuestion = {
    _count: WriteQuestionCountAggregateOutputType | null
    _min: WriteQuestionMinAggregateOutputType | null
    _max: WriteQuestionMaxAggregateOutputType | null
  }

  export type WriteQuestionMinAggregateOutputType = {
    id: string | null
    text: string | null
    correct_answer: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WriteQuestionMaxAggregateOutputType = {
    id: string | null
    text: string | null
    correct_answer: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WriteQuestionCountAggregateOutputType = {
    id: number
    text: number
    correct_answer: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type WriteQuestionMinAggregateInputType = {
    id?: true
    text?: true
    correct_answer?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type WriteQuestionMaxAggregateInputType = {
    id?: true
    text?: true
    correct_answer?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type WriteQuestionCountAggregateInputType = {
    id?: true
    text?: true
    correct_answer?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type WriteQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WriteQuestion to aggregate.
     */
    where?: WriteQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WriteQuestions to fetch.
     */
    orderBy?: WriteQuestionOrderByWithRelationInput | WriteQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WriteQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WriteQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WriteQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WriteQuestions
    **/
    _count?: true | WriteQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WriteQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WriteQuestionMaxAggregateInputType
  }

  export type GetWriteQuestionAggregateType<T extends WriteQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateWriteQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWriteQuestion[P]>
      : GetScalarType<T[P], AggregateWriteQuestion[P]>
  }




  export type WriteQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WriteQuestionWhereInput
    orderBy?: WriteQuestionOrderByWithAggregationInput | WriteQuestionOrderByWithAggregationInput[]
    by: WriteQuestionScalarFieldEnum[] | WriteQuestionScalarFieldEnum
    having?: WriteQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WriteQuestionCountAggregateInputType | true
    _min?: WriteQuestionMinAggregateInputType
    _max?: WriteQuestionMaxAggregateInputType
  }

  export type WriteQuestionGroupByOutputType = {
    id: string
    text: string
    correct_answer: string
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: WriteQuestionCountAggregateOutputType | null
    _min: WriteQuestionMinAggregateOutputType | null
    _max: WriteQuestionMaxAggregateOutputType | null
  }

  type GetWriteQuestionGroupByPayload<T extends WriteQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WriteQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WriteQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WriteQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], WriteQuestionGroupByOutputType[P]>
        }
      >
    >


  export type WriteQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    correct_answer?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    question_applys?: boolean | WriteQuestion$question_applysArgs<ExtArgs>
    _count?: boolean | WriteQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["writeQuestion"]>

  export type WriteQuestionSelectScalar = {
    id?: boolean
    text?: boolean
    correct_answer?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type WriteQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question_applys?: boolean | WriteQuestion$question_applysArgs<ExtArgs>
    _count?: boolean | WriteQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $WriteQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WriteQuestion"
    objects: {
      question_applys: Prisma.$WriteQuestionApplyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      text: string
      correct_answer: string
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["writeQuestion"]>
    composites: {}
  }


  type WriteQuestionGetPayload<S extends boolean | null | undefined | WriteQuestionDefaultArgs> = $Result.GetResult<Prisma.$WriteQuestionPayload, S>

  type WriteQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WriteQuestionFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: WriteQuestionCountAggregateInputType | true
    }

  export interface WriteQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WriteQuestion'], meta: { name: 'WriteQuestion' } }
    /**
     * Find zero or one WriteQuestion that matches the filter.
     * @param {WriteQuestionFindUniqueArgs} args - Arguments to find a WriteQuestion
     * @example
     * // Get one WriteQuestion
     * const writeQuestion = await prisma.writeQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WriteQuestionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WriteQuestionFindUniqueArgs<ExtArgs>>
    ): Prisma__WriteQuestionClient<$Result.GetResult<Prisma.$WriteQuestionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one WriteQuestion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WriteQuestionFindUniqueOrThrowArgs} args - Arguments to find a WriteQuestion
     * @example
     * // Get one WriteQuestion
     * const writeQuestion = await prisma.writeQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WriteQuestionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WriteQuestionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WriteQuestionClient<$Result.GetResult<Prisma.$WriteQuestionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first WriteQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WriteQuestionFindFirstArgs} args - Arguments to find a WriteQuestion
     * @example
     * // Get one WriteQuestion
     * const writeQuestion = await prisma.writeQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WriteQuestionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WriteQuestionFindFirstArgs<ExtArgs>>
    ): Prisma__WriteQuestionClient<$Result.GetResult<Prisma.$WriteQuestionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first WriteQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WriteQuestionFindFirstOrThrowArgs} args - Arguments to find a WriteQuestion
     * @example
     * // Get one WriteQuestion
     * const writeQuestion = await prisma.writeQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WriteQuestionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WriteQuestionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WriteQuestionClient<$Result.GetResult<Prisma.$WriteQuestionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more WriteQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WriteQuestionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WriteQuestions
     * const writeQuestions = await prisma.writeQuestion.findMany()
     * 
     * // Get first 10 WriteQuestions
     * const writeQuestions = await prisma.writeQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const writeQuestionWithIdOnly = await prisma.writeQuestion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WriteQuestionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WriteQuestionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WriteQuestionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a WriteQuestion.
     * @param {WriteQuestionCreateArgs} args - Arguments to create a WriteQuestion.
     * @example
     * // Create one WriteQuestion
     * const WriteQuestion = await prisma.writeQuestion.create({
     *   data: {
     *     // ... data to create a WriteQuestion
     *   }
     * })
     * 
    **/
    create<T extends WriteQuestionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WriteQuestionCreateArgs<ExtArgs>>
    ): Prisma__WriteQuestionClient<$Result.GetResult<Prisma.$WriteQuestionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many WriteQuestions.
     *     @param {WriteQuestionCreateManyArgs} args - Arguments to create many WriteQuestions.
     *     @example
     *     // Create many WriteQuestions
     *     const writeQuestion = await prisma.writeQuestion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WriteQuestionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WriteQuestionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WriteQuestion.
     * @param {WriteQuestionDeleteArgs} args - Arguments to delete one WriteQuestion.
     * @example
     * // Delete one WriteQuestion
     * const WriteQuestion = await prisma.writeQuestion.delete({
     *   where: {
     *     // ... filter to delete one WriteQuestion
     *   }
     * })
     * 
    **/
    delete<T extends WriteQuestionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WriteQuestionDeleteArgs<ExtArgs>>
    ): Prisma__WriteQuestionClient<$Result.GetResult<Prisma.$WriteQuestionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one WriteQuestion.
     * @param {WriteQuestionUpdateArgs} args - Arguments to update one WriteQuestion.
     * @example
     * // Update one WriteQuestion
     * const writeQuestion = await prisma.writeQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WriteQuestionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WriteQuestionUpdateArgs<ExtArgs>>
    ): Prisma__WriteQuestionClient<$Result.GetResult<Prisma.$WriteQuestionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more WriteQuestions.
     * @param {WriteQuestionDeleteManyArgs} args - Arguments to filter WriteQuestions to delete.
     * @example
     * // Delete a few WriteQuestions
     * const { count } = await prisma.writeQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WriteQuestionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WriteQuestionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WriteQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WriteQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WriteQuestions
     * const writeQuestion = await prisma.writeQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WriteQuestionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WriteQuestionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WriteQuestion.
     * @param {WriteQuestionUpsertArgs} args - Arguments to update or create a WriteQuestion.
     * @example
     * // Update or create a WriteQuestion
     * const writeQuestion = await prisma.writeQuestion.upsert({
     *   create: {
     *     // ... data to create a WriteQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WriteQuestion we want to update
     *   }
     * })
    **/
    upsert<T extends WriteQuestionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WriteQuestionUpsertArgs<ExtArgs>>
    ): Prisma__WriteQuestionClient<$Result.GetResult<Prisma.$WriteQuestionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of WriteQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WriteQuestionCountArgs} args - Arguments to filter WriteQuestions to count.
     * @example
     * // Count the number of WriteQuestions
     * const count = await prisma.writeQuestion.count({
     *   where: {
     *     // ... the filter for the WriteQuestions we want to count
     *   }
     * })
    **/
    count<T extends WriteQuestionCountArgs>(
      args?: Subset<T, WriteQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WriteQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WriteQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WriteQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WriteQuestionAggregateArgs>(args: Subset<T, WriteQuestionAggregateArgs>): Prisma.PrismaPromise<GetWriteQuestionAggregateType<T>>

    /**
     * Group by WriteQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WriteQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WriteQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WriteQuestionGroupByArgs['orderBy'] }
        : { orderBy?: WriteQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WriteQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWriteQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WriteQuestion model
   */
  readonly fields: WriteQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WriteQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WriteQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    question_applys<T extends WriteQuestion$question_applysArgs<ExtArgs> = {}>(args?: Subset<T, WriteQuestion$question_applysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WriteQuestionApplyPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the WriteQuestion model
   */ 
  interface WriteQuestionFieldRefs {
    readonly id: FieldRef<"WriteQuestion", 'String'>
    readonly text: FieldRef<"WriteQuestion", 'String'>
    readonly correct_answer: FieldRef<"WriteQuestion", 'String'>
    readonly is_active: FieldRef<"WriteQuestion", 'Boolean'>
    readonly created_at: FieldRef<"WriteQuestion", 'DateTime'>
    readonly updated_at: FieldRef<"WriteQuestion", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * WriteQuestion findUnique
   */
  export type WriteQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WriteQuestion
     */
    select?: WriteQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WriteQuestionInclude<ExtArgs> | null
    /**
     * Filter, which WriteQuestion to fetch.
     */
    where: WriteQuestionWhereUniqueInput
  }


  /**
   * WriteQuestion findUniqueOrThrow
   */
  export type WriteQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WriteQuestion
     */
    select?: WriteQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WriteQuestionInclude<ExtArgs> | null
    /**
     * Filter, which WriteQuestion to fetch.
     */
    where: WriteQuestionWhereUniqueInput
  }


  /**
   * WriteQuestion findFirst
   */
  export type WriteQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WriteQuestion
     */
    select?: WriteQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WriteQuestionInclude<ExtArgs> | null
    /**
     * Filter, which WriteQuestion to fetch.
     */
    where?: WriteQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WriteQuestions to fetch.
     */
    orderBy?: WriteQuestionOrderByWithRelationInput | WriteQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WriteQuestions.
     */
    cursor?: WriteQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WriteQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WriteQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WriteQuestions.
     */
    distinct?: WriteQuestionScalarFieldEnum | WriteQuestionScalarFieldEnum[]
  }


  /**
   * WriteQuestion findFirstOrThrow
   */
  export type WriteQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WriteQuestion
     */
    select?: WriteQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WriteQuestionInclude<ExtArgs> | null
    /**
     * Filter, which WriteQuestion to fetch.
     */
    where?: WriteQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WriteQuestions to fetch.
     */
    orderBy?: WriteQuestionOrderByWithRelationInput | WriteQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WriteQuestions.
     */
    cursor?: WriteQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WriteQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WriteQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WriteQuestions.
     */
    distinct?: WriteQuestionScalarFieldEnum | WriteQuestionScalarFieldEnum[]
  }


  /**
   * WriteQuestion findMany
   */
  export type WriteQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WriteQuestion
     */
    select?: WriteQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WriteQuestionInclude<ExtArgs> | null
    /**
     * Filter, which WriteQuestions to fetch.
     */
    where?: WriteQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WriteQuestions to fetch.
     */
    orderBy?: WriteQuestionOrderByWithRelationInput | WriteQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WriteQuestions.
     */
    cursor?: WriteQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WriteQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WriteQuestions.
     */
    skip?: number
    distinct?: WriteQuestionScalarFieldEnum | WriteQuestionScalarFieldEnum[]
  }


  /**
   * WriteQuestion create
   */
  export type WriteQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WriteQuestion
     */
    select?: WriteQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WriteQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a WriteQuestion.
     */
    data: XOR<WriteQuestionCreateInput, WriteQuestionUncheckedCreateInput>
  }


  /**
   * WriteQuestion createMany
   */
  export type WriteQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WriteQuestions.
     */
    data: WriteQuestionCreateManyInput | WriteQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * WriteQuestion update
   */
  export type WriteQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WriteQuestion
     */
    select?: WriteQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WriteQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a WriteQuestion.
     */
    data: XOR<WriteQuestionUpdateInput, WriteQuestionUncheckedUpdateInput>
    /**
     * Choose, which WriteQuestion to update.
     */
    where: WriteQuestionWhereUniqueInput
  }


  /**
   * WriteQuestion updateMany
   */
  export type WriteQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WriteQuestions.
     */
    data: XOR<WriteQuestionUpdateManyMutationInput, WriteQuestionUncheckedUpdateManyInput>
    /**
     * Filter which WriteQuestions to update
     */
    where?: WriteQuestionWhereInput
  }


  /**
   * WriteQuestion upsert
   */
  export type WriteQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WriteQuestion
     */
    select?: WriteQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WriteQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the WriteQuestion to update in case it exists.
     */
    where: WriteQuestionWhereUniqueInput
    /**
     * In case the WriteQuestion found by the `where` argument doesn't exist, create a new WriteQuestion with this data.
     */
    create: XOR<WriteQuestionCreateInput, WriteQuestionUncheckedCreateInput>
    /**
     * In case the WriteQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WriteQuestionUpdateInput, WriteQuestionUncheckedUpdateInput>
  }


  /**
   * WriteQuestion delete
   */
  export type WriteQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WriteQuestion
     */
    select?: WriteQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WriteQuestionInclude<ExtArgs> | null
    /**
     * Filter which WriteQuestion to delete.
     */
    where: WriteQuestionWhereUniqueInput
  }


  /**
   * WriteQuestion deleteMany
   */
  export type WriteQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WriteQuestions to delete
     */
    where?: WriteQuestionWhereInput
  }


  /**
   * WriteQuestion.question_applys
   */
  export type WriteQuestion$question_applysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WriteQuestionApply
     */
    select?: WriteQuestionApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WriteQuestionApplyInclude<ExtArgs> | null
    where?: WriteQuestionApplyWhereInput
    orderBy?: WriteQuestionApplyOrderByWithRelationInput | WriteQuestionApplyOrderByWithRelationInput[]
    cursor?: WriteQuestionApplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WriteQuestionApplyScalarFieldEnum | WriteQuestionApplyScalarFieldEnum[]
  }


  /**
   * WriteQuestion without action
   */
  export type WriteQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WriteQuestion
     */
    select?: WriteQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WriteQuestionInclude<ExtArgs> | null
  }



  /**
   * Model WriteQuestionApply
   */

  export type AggregateWriteQuestionApply = {
    _count: WriteQuestionApplyCountAggregateOutputType | null
    _min: WriteQuestionApplyMinAggregateOutputType | null
    _max: WriteQuestionApplyMaxAggregateOutputType | null
  }

  export type WriteQuestionApplyMinAggregateOutputType = {
    id: string | null
    questionId: string | null
    teacherId: string | null
    value: string | null
    is_correct: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WriteQuestionApplyMaxAggregateOutputType = {
    id: string | null
    questionId: string | null
    teacherId: string | null
    value: string | null
    is_correct: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WriteQuestionApplyCountAggregateOutputType = {
    id: number
    questionId: number
    teacherId: number
    value: number
    is_correct: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type WriteQuestionApplyMinAggregateInputType = {
    id?: true
    questionId?: true
    teacherId?: true
    value?: true
    is_correct?: true
    created_at?: true
    updated_at?: true
  }

  export type WriteQuestionApplyMaxAggregateInputType = {
    id?: true
    questionId?: true
    teacherId?: true
    value?: true
    is_correct?: true
    created_at?: true
    updated_at?: true
  }

  export type WriteQuestionApplyCountAggregateInputType = {
    id?: true
    questionId?: true
    teacherId?: true
    value?: true
    is_correct?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type WriteQuestionApplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WriteQuestionApply to aggregate.
     */
    where?: WriteQuestionApplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WriteQuestionApplies to fetch.
     */
    orderBy?: WriteQuestionApplyOrderByWithRelationInput | WriteQuestionApplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WriteQuestionApplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WriteQuestionApplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WriteQuestionApplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WriteQuestionApplies
    **/
    _count?: true | WriteQuestionApplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WriteQuestionApplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WriteQuestionApplyMaxAggregateInputType
  }

  export type GetWriteQuestionApplyAggregateType<T extends WriteQuestionApplyAggregateArgs> = {
        [P in keyof T & keyof AggregateWriteQuestionApply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWriteQuestionApply[P]>
      : GetScalarType<T[P], AggregateWriteQuestionApply[P]>
  }




  export type WriteQuestionApplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WriteQuestionApplyWhereInput
    orderBy?: WriteQuestionApplyOrderByWithAggregationInput | WriteQuestionApplyOrderByWithAggregationInput[]
    by: WriteQuestionApplyScalarFieldEnum[] | WriteQuestionApplyScalarFieldEnum
    having?: WriteQuestionApplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WriteQuestionApplyCountAggregateInputType | true
    _min?: WriteQuestionApplyMinAggregateInputType
    _max?: WriteQuestionApplyMaxAggregateInputType
  }

  export type WriteQuestionApplyGroupByOutputType = {
    id: string
    questionId: string
    teacherId: string
    value: string
    is_correct: boolean | null
    created_at: Date
    updated_at: Date
    _count: WriteQuestionApplyCountAggregateOutputType | null
    _min: WriteQuestionApplyMinAggregateOutputType | null
    _max: WriteQuestionApplyMaxAggregateOutputType | null
  }

  type GetWriteQuestionApplyGroupByPayload<T extends WriteQuestionApplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WriteQuestionApplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WriteQuestionApplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WriteQuestionApplyGroupByOutputType[P]>
            : GetScalarType<T[P], WriteQuestionApplyGroupByOutputType[P]>
        }
      >
    >


  export type WriteQuestionApplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    teacherId?: boolean
    value?: boolean
    is_correct?: boolean
    created_at?: boolean
    updated_at?: boolean
    question?: boolean | WriteQuestionDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["writeQuestionApply"]>

  export type WriteQuestionApplySelectScalar = {
    id?: boolean
    questionId?: boolean
    teacherId?: boolean
    value?: boolean
    is_correct?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type WriteQuestionApplyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | WriteQuestionDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }


  export type $WriteQuestionApplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WriteQuestionApply"
    objects: {
      question: Prisma.$WriteQuestionPayload<ExtArgs>
      teacher: Prisma.$TeacherPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      questionId: string
      teacherId: string
      value: string
      is_correct: boolean | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["writeQuestionApply"]>
    composites: {}
  }


  type WriteQuestionApplyGetPayload<S extends boolean | null | undefined | WriteQuestionApplyDefaultArgs> = $Result.GetResult<Prisma.$WriteQuestionApplyPayload, S>

  type WriteQuestionApplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WriteQuestionApplyFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: WriteQuestionApplyCountAggregateInputType | true
    }

  export interface WriteQuestionApplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WriteQuestionApply'], meta: { name: 'WriteQuestionApply' } }
    /**
     * Find zero or one WriteQuestionApply that matches the filter.
     * @param {WriteQuestionApplyFindUniqueArgs} args - Arguments to find a WriteQuestionApply
     * @example
     * // Get one WriteQuestionApply
     * const writeQuestionApply = await prisma.writeQuestionApply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WriteQuestionApplyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WriteQuestionApplyFindUniqueArgs<ExtArgs>>
    ): Prisma__WriteQuestionApplyClient<$Result.GetResult<Prisma.$WriteQuestionApplyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one WriteQuestionApply that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WriteQuestionApplyFindUniqueOrThrowArgs} args - Arguments to find a WriteQuestionApply
     * @example
     * // Get one WriteQuestionApply
     * const writeQuestionApply = await prisma.writeQuestionApply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WriteQuestionApplyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WriteQuestionApplyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WriteQuestionApplyClient<$Result.GetResult<Prisma.$WriteQuestionApplyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first WriteQuestionApply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WriteQuestionApplyFindFirstArgs} args - Arguments to find a WriteQuestionApply
     * @example
     * // Get one WriteQuestionApply
     * const writeQuestionApply = await prisma.writeQuestionApply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WriteQuestionApplyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WriteQuestionApplyFindFirstArgs<ExtArgs>>
    ): Prisma__WriteQuestionApplyClient<$Result.GetResult<Prisma.$WriteQuestionApplyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first WriteQuestionApply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WriteQuestionApplyFindFirstOrThrowArgs} args - Arguments to find a WriteQuestionApply
     * @example
     * // Get one WriteQuestionApply
     * const writeQuestionApply = await prisma.writeQuestionApply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WriteQuestionApplyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WriteQuestionApplyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WriteQuestionApplyClient<$Result.GetResult<Prisma.$WriteQuestionApplyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more WriteQuestionApplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WriteQuestionApplyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WriteQuestionApplies
     * const writeQuestionApplies = await prisma.writeQuestionApply.findMany()
     * 
     * // Get first 10 WriteQuestionApplies
     * const writeQuestionApplies = await prisma.writeQuestionApply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const writeQuestionApplyWithIdOnly = await prisma.writeQuestionApply.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WriteQuestionApplyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WriteQuestionApplyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WriteQuestionApplyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a WriteQuestionApply.
     * @param {WriteQuestionApplyCreateArgs} args - Arguments to create a WriteQuestionApply.
     * @example
     * // Create one WriteQuestionApply
     * const WriteQuestionApply = await prisma.writeQuestionApply.create({
     *   data: {
     *     // ... data to create a WriteQuestionApply
     *   }
     * })
     * 
    **/
    create<T extends WriteQuestionApplyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WriteQuestionApplyCreateArgs<ExtArgs>>
    ): Prisma__WriteQuestionApplyClient<$Result.GetResult<Prisma.$WriteQuestionApplyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many WriteQuestionApplies.
     *     @param {WriteQuestionApplyCreateManyArgs} args - Arguments to create many WriteQuestionApplies.
     *     @example
     *     // Create many WriteQuestionApplies
     *     const writeQuestionApply = await prisma.writeQuestionApply.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WriteQuestionApplyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WriteQuestionApplyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WriteQuestionApply.
     * @param {WriteQuestionApplyDeleteArgs} args - Arguments to delete one WriteQuestionApply.
     * @example
     * // Delete one WriteQuestionApply
     * const WriteQuestionApply = await prisma.writeQuestionApply.delete({
     *   where: {
     *     // ... filter to delete one WriteQuestionApply
     *   }
     * })
     * 
    **/
    delete<T extends WriteQuestionApplyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WriteQuestionApplyDeleteArgs<ExtArgs>>
    ): Prisma__WriteQuestionApplyClient<$Result.GetResult<Prisma.$WriteQuestionApplyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one WriteQuestionApply.
     * @param {WriteQuestionApplyUpdateArgs} args - Arguments to update one WriteQuestionApply.
     * @example
     * // Update one WriteQuestionApply
     * const writeQuestionApply = await prisma.writeQuestionApply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WriteQuestionApplyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WriteQuestionApplyUpdateArgs<ExtArgs>>
    ): Prisma__WriteQuestionApplyClient<$Result.GetResult<Prisma.$WriteQuestionApplyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more WriteQuestionApplies.
     * @param {WriteQuestionApplyDeleteManyArgs} args - Arguments to filter WriteQuestionApplies to delete.
     * @example
     * // Delete a few WriteQuestionApplies
     * const { count } = await prisma.writeQuestionApply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WriteQuestionApplyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WriteQuestionApplyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WriteQuestionApplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WriteQuestionApplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WriteQuestionApplies
     * const writeQuestionApply = await prisma.writeQuestionApply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WriteQuestionApplyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WriteQuestionApplyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WriteQuestionApply.
     * @param {WriteQuestionApplyUpsertArgs} args - Arguments to update or create a WriteQuestionApply.
     * @example
     * // Update or create a WriteQuestionApply
     * const writeQuestionApply = await prisma.writeQuestionApply.upsert({
     *   create: {
     *     // ... data to create a WriteQuestionApply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WriteQuestionApply we want to update
     *   }
     * })
    **/
    upsert<T extends WriteQuestionApplyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WriteQuestionApplyUpsertArgs<ExtArgs>>
    ): Prisma__WriteQuestionApplyClient<$Result.GetResult<Prisma.$WriteQuestionApplyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of WriteQuestionApplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WriteQuestionApplyCountArgs} args - Arguments to filter WriteQuestionApplies to count.
     * @example
     * // Count the number of WriteQuestionApplies
     * const count = await prisma.writeQuestionApply.count({
     *   where: {
     *     // ... the filter for the WriteQuestionApplies we want to count
     *   }
     * })
    **/
    count<T extends WriteQuestionApplyCountArgs>(
      args?: Subset<T, WriteQuestionApplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WriteQuestionApplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WriteQuestionApply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WriteQuestionApplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WriteQuestionApplyAggregateArgs>(args: Subset<T, WriteQuestionApplyAggregateArgs>): Prisma.PrismaPromise<GetWriteQuestionApplyAggregateType<T>>

    /**
     * Group by WriteQuestionApply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WriteQuestionApplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WriteQuestionApplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WriteQuestionApplyGroupByArgs['orderBy'] }
        : { orderBy?: WriteQuestionApplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WriteQuestionApplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWriteQuestionApplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WriteQuestionApply model
   */
  readonly fields: WriteQuestionApplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WriteQuestionApply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WriteQuestionApplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    question<T extends WriteQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WriteQuestionDefaultArgs<ExtArgs>>): Prisma__WriteQuestionClient<$Result.GetResult<Prisma.$WriteQuestionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the WriteQuestionApply model
   */ 
  interface WriteQuestionApplyFieldRefs {
    readonly id: FieldRef<"WriteQuestionApply", 'String'>
    readonly questionId: FieldRef<"WriteQuestionApply", 'String'>
    readonly teacherId: FieldRef<"WriteQuestionApply", 'String'>
    readonly value: FieldRef<"WriteQuestionApply", 'String'>
    readonly is_correct: FieldRef<"WriteQuestionApply", 'Boolean'>
    readonly created_at: FieldRef<"WriteQuestionApply", 'DateTime'>
    readonly updated_at: FieldRef<"WriteQuestionApply", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * WriteQuestionApply findUnique
   */
  export type WriteQuestionApplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WriteQuestionApply
     */
    select?: WriteQuestionApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WriteQuestionApplyInclude<ExtArgs> | null
    /**
     * Filter, which WriteQuestionApply to fetch.
     */
    where: WriteQuestionApplyWhereUniqueInput
  }


  /**
   * WriteQuestionApply findUniqueOrThrow
   */
  export type WriteQuestionApplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WriteQuestionApply
     */
    select?: WriteQuestionApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WriteQuestionApplyInclude<ExtArgs> | null
    /**
     * Filter, which WriteQuestionApply to fetch.
     */
    where: WriteQuestionApplyWhereUniqueInput
  }


  /**
   * WriteQuestionApply findFirst
   */
  export type WriteQuestionApplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WriteQuestionApply
     */
    select?: WriteQuestionApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WriteQuestionApplyInclude<ExtArgs> | null
    /**
     * Filter, which WriteQuestionApply to fetch.
     */
    where?: WriteQuestionApplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WriteQuestionApplies to fetch.
     */
    orderBy?: WriteQuestionApplyOrderByWithRelationInput | WriteQuestionApplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WriteQuestionApplies.
     */
    cursor?: WriteQuestionApplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WriteQuestionApplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WriteQuestionApplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WriteQuestionApplies.
     */
    distinct?: WriteQuestionApplyScalarFieldEnum | WriteQuestionApplyScalarFieldEnum[]
  }


  /**
   * WriteQuestionApply findFirstOrThrow
   */
  export type WriteQuestionApplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WriteQuestionApply
     */
    select?: WriteQuestionApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WriteQuestionApplyInclude<ExtArgs> | null
    /**
     * Filter, which WriteQuestionApply to fetch.
     */
    where?: WriteQuestionApplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WriteQuestionApplies to fetch.
     */
    orderBy?: WriteQuestionApplyOrderByWithRelationInput | WriteQuestionApplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WriteQuestionApplies.
     */
    cursor?: WriteQuestionApplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WriteQuestionApplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WriteQuestionApplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WriteQuestionApplies.
     */
    distinct?: WriteQuestionApplyScalarFieldEnum | WriteQuestionApplyScalarFieldEnum[]
  }


  /**
   * WriteQuestionApply findMany
   */
  export type WriteQuestionApplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WriteQuestionApply
     */
    select?: WriteQuestionApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WriteQuestionApplyInclude<ExtArgs> | null
    /**
     * Filter, which WriteQuestionApplies to fetch.
     */
    where?: WriteQuestionApplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WriteQuestionApplies to fetch.
     */
    orderBy?: WriteQuestionApplyOrderByWithRelationInput | WriteQuestionApplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WriteQuestionApplies.
     */
    cursor?: WriteQuestionApplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WriteQuestionApplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WriteQuestionApplies.
     */
    skip?: number
    distinct?: WriteQuestionApplyScalarFieldEnum | WriteQuestionApplyScalarFieldEnum[]
  }


  /**
   * WriteQuestionApply create
   */
  export type WriteQuestionApplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WriteQuestionApply
     */
    select?: WriteQuestionApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WriteQuestionApplyInclude<ExtArgs> | null
    /**
     * The data needed to create a WriteQuestionApply.
     */
    data: XOR<WriteQuestionApplyCreateInput, WriteQuestionApplyUncheckedCreateInput>
  }


  /**
   * WriteQuestionApply createMany
   */
  export type WriteQuestionApplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WriteQuestionApplies.
     */
    data: WriteQuestionApplyCreateManyInput | WriteQuestionApplyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * WriteQuestionApply update
   */
  export type WriteQuestionApplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WriteQuestionApply
     */
    select?: WriteQuestionApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WriteQuestionApplyInclude<ExtArgs> | null
    /**
     * The data needed to update a WriteQuestionApply.
     */
    data: XOR<WriteQuestionApplyUpdateInput, WriteQuestionApplyUncheckedUpdateInput>
    /**
     * Choose, which WriteQuestionApply to update.
     */
    where: WriteQuestionApplyWhereUniqueInput
  }


  /**
   * WriteQuestionApply updateMany
   */
  export type WriteQuestionApplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WriteQuestionApplies.
     */
    data: XOR<WriteQuestionApplyUpdateManyMutationInput, WriteQuestionApplyUncheckedUpdateManyInput>
    /**
     * Filter which WriteQuestionApplies to update
     */
    where?: WriteQuestionApplyWhereInput
  }


  /**
   * WriteQuestionApply upsert
   */
  export type WriteQuestionApplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WriteQuestionApply
     */
    select?: WriteQuestionApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WriteQuestionApplyInclude<ExtArgs> | null
    /**
     * The filter to search for the WriteQuestionApply to update in case it exists.
     */
    where: WriteQuestionApplyWhereUniqueInput
    /**
     * In case the WriteQuestionApply found by the `where` argument doesn't exist, create a new WriteQuestionApply with this data.
     */
    create: XOR<WriteQuestionApplyCreateInput, WriteQuestionApplyUncheckedCreateInput>
    /**
     * In case the WriteQuestionApply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WriteQuestionApplyUpdateInput, WriteQuestionApplyUncheckedUpdateInput>
  }


  /**
   * WriteQuestionApply delete
   */
  export type WriteQuestionApplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WriteQuestionApply
     */
    select?: WriteQuestionApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WriteQuestionApplyInclude<ExtArgs> | null
    /**
     * Filter which WriteQuestionApply to delete.
     */
    where: WriteQuestionApplyWhereUniqueInput
  }


  /**
   * WriteQuestionApply deleteMany
   */
  export type WriteQuestionApplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WriteQuestionApplies to delete
     */
    where?: WriteQuestionApplyWhereInput
  }


  /**
   * WriteQuestionApply without action
   */
  export type WriteQuestionApplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WriteQuestionApply
     */
    select?: WriteQuestionApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WriteQuestionApplyInclude<ExtArgs> | null
  }



  /**
   * Model Training
   */

  export type AggregateTraining = {
    _count: TrainingCountAggregateOutputType | null
    _avg: TrainingAvgAggregateOutputType | null
    _sum: TrainingSumAggregateOutputType | null
    _min: TrainingMinAggregateOutputType | null
    _max: TrainingMaxAggregateOutputType | null
  }

  export type TrainingAvgAggregateOutputType = {
    max_score: number | null
    pass_score: number | null
  }

  export type TrainingSumAggregateOutputType = {
    max_score: number | null
    pass_score: number | null
  }

  export type TrainingMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    subject: string | null
    max_score: number | null
    pass_score: number | null
    file: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TrainingMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    subject: string | null
    max_score: number | null
    pass_score: number | null
    file: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TrainingCountAggregateOutputType = {
    id: number
    title: number
    description: number
    subject: number
    max_score: number
    pass_score: number
    file: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TrainingAvgAggregateInputType = {
    max_score?: true
    pass_score?: true
  }

  export type TrainingSumAggregateInputType = {
    max_score?: true
    pass_score?: true
  }

  export type TrainingMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    subject?: true
    max_score?: true
    pass_score?: true
    file?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type TrainingMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    subject?: true
    max_score?: true
    pass_score?: true
    file?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type TrainingCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    subject?: true
    max_score?: true
    pass_score?: true
    file?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TrainingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Training to aggregate.
     */
    where?: TrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainings to fetch.
     */
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trainings
    **/
    _count?: true | TrainingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingMaxAggregateInputType
  }

  export type GetTrainingAggregateType<T extends TrainingAggregateArgs> = {
        [P in keyof T & keyof AggregateTraining]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTraining[P]>
      : GetScalarType<T[P], AggregateTraining[P]>
  }




  export type TrainingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingWhereInput
    orderBy?: TrainingOrderByWithAggregationInput | TrainingOrderByWithAggregationInput[]
    by: TrainingScalarFieldEnum[] | TrainingScalarFieldEnum
    having?: TrainingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingCountAggregateInputType | true
    _avg?: TrainingAvgAggregateInputType
    _sum?: TrainingSumAggregateInputType
    _min?: TrainingMinAggregateInputType
    _max?: TrainingMaxAggregateInputType
  }

  export type TrainingGroupByOutputType = {
    id: string
    title: string
    description: string | null
    subject: string | null
    max_score: number | null
    pass_score: number | null
    file: string | null
    is_active: boolean | null
    created_at: Date
    updated_at: Date
    _count: TrainingCountAggregateOutputType | null
    _avg: TrainingAvgAggregateOutputType | null
    _sum: TrainingSumAggregateOutputType | null
    _min: TrainingMinAggregateOutputType | null
    _max: TrainingMaxAggregateOutputType | null
  }

  type GetTrainingGroupByPayload<T extends TrainingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingGroupByOutputType[P]>
        }
      >
    >


  export type TrainingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    subject?: boolean
    max_score?: boolean
    pass_score?: boolean
    file?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    training_applys?: boolean | Training$training_applysArgs<ExtArgs>
    _count?: boolean | TrainingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["training"]>

  export type TrainingSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    subject?: boolean
    max_score?: boolean
    pass_score?: boolean
    file?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TrainingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training_applys?: boolean | Training$training_applysArgs<ExtArgs>
    _count?: boolean | TrainingCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TrainingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Training"
    objects: {
      training_applys: Prisma.$TrainingApplyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      subject: string | null
      max_score: number | null
      pass_score: number | null
      file: string | null
      is_active: boolean | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["training"]>
    composites: {}
  }


  type TrainingGetPayload<S extends boolean | null | undefined | TrainingDefaultArgs> = $Result.GetResult<Prisma.$TrainingPayload, S>

  type TrainingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrainingFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: TrainingCountAggregateInputType | true
    }

  export interface TrainingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Training'], meta: { name: 'Training' } }
    /**
     * Find zero or one Training that matches the filter.
     * @param {TrainingFindUniqueArgs} args - Arguments to find a Training
     * @example
     * // Get one Training
     * const training = await prisma.training.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TrainingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingFindUniqueArgs<ExtArgs>>
    ): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Training that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TrainingFindUniqueOrThrowArgs} args - Arguments to find a Training
     * @example
     * // Get one Training
     * const training = await prisma.training.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TrainingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Training that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFindFirstArgs} args - Arguments to find a Training
     * @example
     * // Get one Training
     * const training = await prisma.training.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TrainingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingFindFirstArgs<ExtArgs>>
    ): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Training that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFindFirstOrThrowArgs} args - Arguments to find a Training
     * @example
     * // Get one Training
     * const training = await prisma.training.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TrainingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Trainings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trainings
     * const trainings = await prisma.training.findMany()
     * 
     * // Get first 10 Trainings
     * const trainings = await prisma.training.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingWithIdOnly = await prisma.training.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TrainingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Training.
     * @param {TrainingCreateArgs} args - Arguments to create a Training.
     * @example
     * // Create one Training
     * const Training = await prisma.training.create({
     *   data: {
     *     // ... data to create a Training
     *   }
     * })
     * 
    **/
    create<T extends TrainingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingCreateArgs<ExtArgs>>
    ): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Trainings.
     *     @param {TrainingCreateManyArgs} args - Arguments to create many Trainings.
     *     @example
     *     // Create many Trainings
     *     const training = await prisma.training.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TrainingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Training.
     * @param {TrainingDeleteArgs} args - Arguments to delete one Training.
     * @example
     * // Delete one Training
     * const Training = await prisma.training.delete({
     *   where: {
     *     // ... filter to delete one Training
     *   }
     * })
     * 
    **/
    delete<T extends TrainingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingDeleteArgs<ExtArgs>>
    ): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Training.
     * @param {TrainingUpdateArgs} args - Arguments to update one Training.
     * @example
     * // Update one Training
     * const training = await prisma.training.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TrainingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingUpdateArgs<ExtArgs>>
    ): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Trainings.
     * @param {TrainingDeleteManyArgs} args - Arguments to filter Trainings to delete.
     * @example
     * // Delete a few Trainings
     * const { count } = await prisma.training.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TrainingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trainings
     * const training = await prisma.training.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TrainingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Training.
     * @param {TrainingUpsertArgs} args - Arguments to update or create a Training.
     * @example
     * // Update or create a Training
     * const training = await prisma.training.upsert({
     *   create: {
     *     // ... data to create a Training
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Training we want to update
     *   }
     * })
    **/
    upsert<T extends TrainingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingUpsertArgs<ExtArgs>>
    ): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingCountArgs} args - Arguments to filter Trainings to count.
     * @example
     * // Count the number of Trainings
     * const count = await prisma.training.count({
     *   where: {
     *     // ... the filter for the Trainings we want to count
     *   }
     * })
    **/
    count<T extends TrainingCountArgs>(
      args?: Subset<T, TrainingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Training.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingAggregateArgs>(args: Subset<T, TrainingAggregateArgs>): Prisma.PrismaPromise<GetTrainingAggregateType<T>>

    /**
     * Group by Training.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingGroupByArgs['orderBy'] }
        : { orderBy?: TrainingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Training model
   */
  readonly fields: TrainingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Training.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    training_applys<T extends Training$training_applysArgs<ExtArgs> = {}>(args?: Subset<T, Training$training_applysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingApplyPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Training model
   */ 
  interface TrainingFieldRefs {
    readonly id: FieldRef<"Training", 'String'>
    readonly title: FieldRef<"Training", 'String'>
    readonly description: FieldRef<"Training", 'String'>
    readonly subject: FieldRef<"Training", 'String'>
    readonly max_score: FieldRef<"Training", 'Int'>
    readonly pass_score: FieldRef<"Training", 'Int'>
    readonly file: FieldRef<"Training", 'String'>
    readonly is_active: FieldRef<"Training", 'Boolean'>
    readonly created_at: FieldRef<"Training", 'DateTime'>
    readonly updated_at: FieldRef<"Training", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Training findUnique
   */
  export type TrainingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter, which Training to fetch.
     */
    where: TrainingWhereUniqueInput
  }


  /**
   * Training findUniqueOrThrow
   */
  export type TrainingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter, which Training to fetch.
     */
    where: TrainingWhereUniqueInput
  }


  /**
   * Training findFirst
   */
  export type TrainingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter, which Training to fetch.
     */
    where?: TrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainings to fetch.
     */
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trainings.
     */
    cursor?: TrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trainings.
     */
    distinct?: TrainingScalarFieldEnum | TrainingScalarFieldEnum[]
  }


  /**
   * Training findFirstOrThrow
   */
  export type TrainingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter, which Training to fetch.
     */
    where?: TrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainings to fetch.
     */
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trainings.
     */
    cursor?: TrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trainings.
     */
    distinct?: TrainingScalarFieldEnum | TrainingScalarFieldEnum[]
  }


  /**
   * Training findMany
   */
  export type TrainingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter, which Trainings to fetch.
     */
    where?: TrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainings to fetch.
     */
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trainings.
     */
    cursor?: TrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainings.
     */
    skip?: number
    distinct?: TrainingScalarFieldEnum | TrainingScalarFieldEnum[]
  }


  /**
   * Training create
   */
  export type TrainingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * The data needed to create a Training.
     */
    data: XOR<TrainingCreateInput, TrainingUncheckedCreateInput>
  }


  /**
   * Training createMany
   */
  export type TrainingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trainings.
     */
    data: TrainingCreateManyInput | TrainingCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Training update
   */
  export type TrainingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * The data needed to update a Training.
     */
    data: XOR<TrainingUpdateInput, TrainingUncheckedUpdateInput>
    /**
     * Choose, which Training to update.
     */
    where: TrainingWhereUniqueInput
  }


  /**
   * Training updateMany
   */
  export type TrainingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trainings.
     */
    data: XOR<TrainingUpdateManyMutationInput, TrainingUncheckedUpdateManyInput>
    /**
     * Filter which Trainings to update
     */
    where?: TrainingWhereInput
  }


  /**
   * Training upsert
   */
  export type TrainingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * The filter to search for the Training to update in case it exists.
     */
    where: TrainingWhereUniqueInput
    /**
     * In case the Training found by the `where` argument doesn't exist, create a new Training with this data.
     */
    create: XOR<TrainingCreateInput, TrainingUncheckedCreateInput>
    /**
     * In case the Training was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingUpdateInput, TrainingUncheckedUpdateInput>
  }


  /**
   * Training delete
   */
  export type TrainingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter which Training to delete.
     */
    where: TrainingWhereUniqueInput
  }


  /**
   * Training deleteMany
   */
  export type TrainingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trainings to delete
     */
    where?: TrainingWhereInput
  }


  /**
   * Training.training_applys
   */
  export type Training$training_applysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingApply
     */
    select?: TrainingApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingApplyInclude<ExtArgs> | null
    where?: TrainingApplyWhereInput
    orderBy?: TrainingApplyOrderByWithRelationInput | TrainingApplyOrderByWithRelationInput[]
    cursor?: TrainingApplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingApplyScalarFieldEnum | TrainingApplyScalarFieldEnum[]
  }


  /**
   * Training without action
   */
  export type TrainingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingInclude<ExtArgs> | null
  }



  /**
   * Model TrainingApply
   */

  export type AggregateTrainingApply = {
    _count: TrainingApplyCountAggregateOutputType | null
    _min: TrainingApplyMinAggregateOutputType | null
    _max: TrainingApplyMaxAggregateOutputType | null
  }

  export type TrainingApplyMinAggregateOutputType = {
    id: string | null
    trainingId: string | null
    teacherId: string | null
    text: string | null
    file: string | null
    is_seen: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TrainingApplyMaxAggregateOutputType = {
    id: string | null
    trainingId: string | null
    teacherId: string | null
    text: string | null
    file: string | null
    is_seen: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TrainingApplyCountAggregateOutputType = {
    id: number
    trainingId: number
    teacherId: number
    text: number
    file: number
    is_seen: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TrainingApplyMinAggregateInputType = {
    id?: true
    trainingId?: true
    teacherId?: true
    text?: true
    file?: true
    is_seen?: true
    created_at?: true
    updated_at?: true
  }

  export type TrainingApplyMaxAggregateInputType = {
    id?: true
    trainingId?: true
    teacherId?: true
    text?: true
    file?: true
    is_seen?: true
    created_at?: true
    updated_at?: true
  }

  export type TrainingApplyCountAggregateInputType = {
    id?: true
    trainingId?: true
    teacherId?: true
    text?: true
    file?: true
    is_seen?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TrainingApplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingApply to aggregate.
     */
    where?: TrainingApplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingApplies to fetch.
     */
    orderBy?: TrainingApplyOrderByWithRelationInput | TrainingApplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingApplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingApplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingApplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingApplies
    **/
    _count?: true | TrainingApplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingApplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingApplyMaxAggregateInputType
  }

  export type GetTrainingApplyAggregateType<T extends TrainingApplyAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingApply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingApply[P]>
      : GetScalarType<T[P], AggregateTrainingApply[P]>
  }




  export type TrainingApplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingApplyWhereInput
    orderBy?: TrainingApplyOrderByWithAggregationInput | TrainingApplyOrderByWithAggregationInput[]
    by: TrainingApplyScalarFieldEnum[] | TrainingApplyScalarFieldEnum
    having?: TrainingApplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingApplyCountAggregateInputType | true
    _min?: TrainingApplyMinAggregateInputType
    _max?: TrainingApplyMaxAggregateInputType
  }

  export type TrainingApplyGroupByOutputType = {
    id: string
    trainingId: string
    teacherId: string
    text: string | null
    file: string | null
    is_seen: boolean | null
    created_at: Date
    updated_at: Date
    _count: TrainingApplyCountAggregateOutputType | null
    _min: TrainingApplyMinAggregateOutputType | null
    _max: TrainingApplyMaxAggregateOutputType | null
  }

  type GetTrainingApplyGroupByPayload<T extends TrainingApplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingApplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingApplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingApplyGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingApplyGroupByOutputType[P]>
        }
      >
    >


  export type TrainingApplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    teacherId?: boolean
    text?: boolean
    file?: boolean
    is_seen?: boolean
    created_at?: boolean
    updated_at?: boolean
    train?: boolean | TrainingDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    checking_applys?: boolean | TrainingApply$checking_applysArgs<ExtArgs>
    _count?: boolean | TrainingApplyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingApply"]>

  export type TrainingApplySelectScalar = {
    id?: boolean
    trainingId?: boolean
    teacherId?: boolean
    text?: boolean
    file?: boolean
    is_seen?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TrainingApplyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    train?: boolean | TrainingDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    checking_applys?: boolean | TrainingApply$checking_applysArgs<ExtArgs>
    _count?: boolean | TrainingApplyCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TrainingApplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingApply"
    objects: {
      train: Prisma.$TrainingPayload<ExtArgs>
      teacher: Prisma.$TeacherPayload<ExtArgs>
      checking_applys: Prisma.$CheckTrainingApplyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trainingId: string
      teacherId: string
      text: string | null
      file: string | null
      is_seen: boolean | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["trainingApply"]>
    composites: {}
  }


  type TrainingApplyGetPayload<S extends boolean | null | undefined | TrainingApplyDefaultArgs> = $Result.GetResult<Prisma.$TrainingApplyPayload, S>

  type TrainingApplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrainingApplyFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: TrainingApplyCountAggregateInputType | true
    }

  export interface TrainingApplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingApply'], meta: { name: 'TrainingApply' } }
    /**
     * Find zero or one TrainingApply that matches the filter.
     * @param {TrainingApplyFindUniqueArgs} args - Arguments to find a TrainingApply
     * @example
     * // Get one TrainingApply
     * const trainingApply = await prisma.trainingApply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TrainingApplyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingApplyFindUniqueArgs<ExtArgs>>
    ): Prisma__TrainingApplyClient<$Result.GetResult<Prisma.$TrainingApplyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TrainingApply that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TrainingApplyFindUniqueOrThrowArgs} args - Arguments to find a TrainingApply
     * @example
     * // Get one TrainingApply
     * const trainingApply = await prisma.trainingApply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TrainingApplyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingApplyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TrainingApplyClient<$Result.GetResult<Prisma.$TrainingApplyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TrainingApply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingApplyFindFirstArgs} args - Arguments to find a TrainingApply
     * @example
     * // Get one TrainingApply
     * const trainingApply = await prisma.trainingApply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TrainingApplyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingApplyFindFirstArgs<ExtArgs>>
    ): Prisma__TrainingApplyClient<$Result.GetResult<Prisma.$TrainingApplyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TrainingApply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingApplyFindFirstOrThrowArgs} args - Arguments to find a TrainingApply
     * @example
     * // Get one TrainingApply
     * const trainingApply = await prisma.trainingApply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TrainingApplyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingApplyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TrainingApplyClient<$Result.GetResult<Prisma.$TrainingApplyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TrainingApplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingApplyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingApplies
     * const trainingApplies = await prisma.trainingApply.findMany()
     * 
     * // Get first 10 TrainingApplies
     * const trainingApplies = await prisma.trainingApply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingApplyWithIdOnly = await prisma.trainingApply.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TrainingApplyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingApplyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingApplyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TrainingApply.
     * @param {TrainingApplyCreateArgs} args - Arguments to create a TrainingApply.
     * @example
     * // Create one TrainingApply
     * const TrainingApply = await prisma.trainingApply.create({
     *   data: {
     *     // ... data to create a TrainingApply
     *   }
     * })
     * 
    **/
    create<T extends TrainingApplyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingApplyCreateArgs<ExtArgs>>
    ): Prisma__TrainingApplyClient<$Result.GetResult<Prisma.$TrainingApplyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TrainingApplies.
     *     @param {TrainingApplyCreateManyArgs} args - Arguments to create many TrainingApplies.
     *     @example
     *     // Create many TrainingApplies
     *     const trainingApply = await prisma.trainingApply.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TrainingApplyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingApplyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TrainingApply.
     * @param {TrainingApplyDeleteArgs} args - Arguments to delete one TrainingApply.
     * @example
     * // Delete one TrainingApply
     * const TrainingApply = await prisma.trainingApply.delete({
     *   where: {
     *     // ... filter to delete one TrainingApply
     *   }
     * })
     * 
    **/
    delete<T extends TrainingApplyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingApplyDeleteArgs<ExtArgs>>
    ): Prisma__TrainingApplyClient<$Result.GetResult<Prisma.$TrainingApplyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TrainingApply.
     * @param {TrainingApplyUpdateArgs} args - Arguments to update one TrainingApply.
     * @example
     * // Update one TrainingApply
     * const trainingApply = await prisma.trainingApply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TrainingApplyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingApplyUpdateArgs<ExtArgs>>
    ): Prisma__TrainingApplyClient<$Result.GetResult<Prisma.$TrainingApplyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TrainingApplies.
     * @param {TrainingApplyDeleteManyArgs} args - Arguments to filter TrainingApplies to delete.
     * @example
     * // Delete a few TrainingApplies
     * const { count } = await prisma.trainingApply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TrainingApplyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingApplyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingApplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingApplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingApplies
     * const trainingApply = await prisma.trainingApply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TrainingApplyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingApplyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrainingApply.
     * @param {TrainingApplyUpsertArgs} args - Arguments to update or create a TrainingApply.
     * @example
     * // Update or create a TrainingApply
     * const trainingApply = await prisma.trainingApply.upsert({
     *   create: {
     *     // ... data to create a TrainingApply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingApply we want to update
     *   }
     * })
    **/
    upsert<T extends TrainingApplyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingApplyUpsertArgs<ExtArgs>>
    ): Prisma__TrainingApplyClient<$Result.GetResult<Prisma.$TrainingApplyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TrainingApplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingApplyCountArgs} args - Arguments to filter TrainingApplies to count.
     * @example
     * // Count the number of TrainingApplies
     * const count = await prisma.trainingApply.count({
     *   where: {
     *     // ... the filter for the TrainingApplies we want to count
     *   }
     * })
    **/
    count<T extends TrainingApplyCountArgs>(
      args?: Subset<T, TrainingApplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingApplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingApply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingApplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingApplyAggregateArgs>(args: Subset<T, TrainingApplyAggregateArgs>): Prisma.PrismaPromise<GetTrainingApplyAggregateType<T>>

    /**
     * Group by TrainingApply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingApplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingApplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingApplyGroupByArgs['orderBy'] }
        : { orderBy?: TrainingApplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingApplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingApplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingApply model
   */
  readonly fields: TrainingApplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingApply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingApplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    train<T extends TrainingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingDefaultArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    checking_applys<T extends TrainingApply$checking_applysArgs<ExtArgs> = {}>(args?: Subset<T, TrainingApply$checking_applysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckTrainingApplyPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TrainingApply model
   */ 
  interface TrainingApplyFieldRefs {
    readonly id: FieldRef<"TrainingApply", 'String'>
    readonly trainingId: FieldRef<"TrainingApply", 'String'>
    readonly teacherId: FieldRef<"TrainingApply", 'String'>
    readonly text: FieldRef<"TrainingApply", 'String'>
    readonly file: FieldRef<"TrainingApply", 'String'>
    readonly is_seen: FieldRef<"TrainingApply", 'Boolean'>
    readonly created_at: FieldRef<"TrainingApply", 'DateTime'>
    readonly updated_at: FieldRef<"TrainingApply", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * TrainingApply findUnique
   */
  export type TrainingApplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingApply
     */
    select?: TrainingApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingApplyInclude<ExtArgs> | null
    /**
     * Filter, which TrainingApply to fetch.
     */
    where: TrainingApplyWhereUniqueInput
  }


  /**
   * TrainingApply findUniqueOrThrow
   */
  export type TrainingApplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingApply
     */
    select?: TrainingApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingApplyInclude<ExtArgs> | null
    /**
     * Filter, which TrainingApply to fetch.
     */
    where: TrainingApplyWhereUniqueInput
  }


  /**
   * TrainingApply findFirst
   */
  export type TrainingApplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingApply
     */
    select?: TrainingApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingApplyInclude<ExtArgs> | null
    /**
     * Filter, which TrainingApply to fetch.
     */
    where?: TrainingApplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingApplies to fetch.
     */
    orderBy?: TrainingApplyOrderByWithRelationInput | TrainingApplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingApplies.
     */
    cursor?: TrainingApplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingApplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingApplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingApplies.
     */
    distinct?: TrainingApplyScalarFieldEnum | TrainingApplyScalarFieldEnum[]
  }


  /**
   * TrainingApply findFirstOrThrow
   */
  export type TrainingApplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingApply
     */
    select?: TrainingApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingApplyInclude<ExtArgs> | null
    /**
     * Filter, which TrainingApply to fetch.
     */
    where?: TrainingApplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingApplies to fetch.
     */
    orderBy?: TrainingApplyOrderByWithRelationInput | TrainingApplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingApplies.
     */
    cursor?: TrainingApplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingApplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingApplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingApplies.
     */
    distinct?: TrainingApplyScalarFieldEnum | TrainingApplyScalarFieldEnum[]
  }


  /**
   * TrainingApply findMany
   */
  export type TrainingApplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingApply
     */
    select?: TrainingApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingApplyInclude<ExtArgs> | null
    /**
     * Filter, which TrainingApplies to fetch.
     */
    where?: TrainingApplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingApplies to fetch.
     */
    orderBy?: TrainingApplyOrderByWithRelationInput | TrainingApplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingApplies.
     */
    cursor?: TrainingApplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingApplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingApplies.
     */
    skip?: number
    distinct?: TrainingApplyScalarFieldEnum | TrainingApplyScalarFieldEnum[]
  }


  /**
   * TrainingApply create
   */
  export type TrainingApplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingApply
     */
    select?: TrainingApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingApplyInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingApply.
     */
    data: XOR<TrainingApplyCreateInput, TrainingApplyUncheckedCreateInput>
  }


  /**
   * TrainingApply createMany
   */
  export type TrainingApplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingApplies.
     */
    data: TrainingApplyCreateManyInput | TrainingApplyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TrainingApply update
   */
  export type TrainingApplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingApply
     */
    select?: TrainingApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingApplyInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingApply.
     */
    data: XOR<TrainingApplyUpdateInput, TrainingApplyUncheckedUpdateInput>
    /**
     * Choose, which TrainingApply to update.
     */
    where: TrainingApplyWhereUniqueInput
  }


  /**
   * TrainingApply updateMany
   */
  export type TrainingApplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingApplies.
     */
    data: XOR<TrainingApplyUpdateManyMutationInput, TrainingApplyUncheckedUpdateManyInput>
    /**
     * Filter which TrainingApplies to update
     */
    where?: TrainingApplyWhereInput
  }


  /**
   * TrainingApply upsert
   */
  export type TrainingApplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingApply
     */
    select?: TrainingApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingApplyInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingApply to update in case it exists.
     */
    where: TrainingApplyWhereUniqueInput
    /**
     * In case the TrainingApply found by the `where` argument doesn't exist, create a new TrainingApply with this data.
     */
    create: XOR<TrainingApplyCreateInput, TrainingApplyUncheckedCreateInput>
    /**
     * In case the TrainingApply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingApplyUpdateInput, TrainingApplyUncheckedUpdateInput>
  }


  /**
   * TrainingApply delete
   */
  export type TrainingApplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingApply
     */
    select?: TrainingApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingApplyInclude<ExtArgs> | null
    /**
     * Filter which TrainingApply to delete.
     */
    where: TrainingApplyWhereUniqueInput
  }


  /**
   * TrainingApply deleteMany
   */
  export type TrainingApplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingApplies to delete
     */
    where?: TrainingApplyWhereInput
  }


  /**
   * TrainingApply.checking_applys
   */
  export type TrainingApply$checking_applysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckTrainingApply
     */
    select?: CheckTrainingApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckTrainingApplyInclude<ExtArgs> | null
    where?: CheckTrainingApplyWhereInput
    orderBy?: CheckTrainingApplyOrderByWithRelationInput | CheckTrainingApplyOrderByWithRelationInput[]
    cursor?: CheckTrainingApplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckTrainingApplyScalarFieldEnum | CheckTrainingApplyScalarFieldEnum[]
  }


  /**
   * TrainingApply without action
   */
  export type TrainingApplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingApply
     */
    select?: TrainingApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingApplyInclude<ExtArgs> | null
  }



  /**
   * Model CheckTrainingApply
   */

  export type AggregateCheckTrainingApply = {
    _count: CheckTrainingApplyCountAggregateOutputType | null
    _avg: CheckTrainingApplyAvgAggregateOutputType | null
    _sum: CheckTrainingApplySumAggregateOutputType | null
    _min: CheckTrainingApplyMinAggregateOutputType | null
    _max: CheckTrainingApplyMaxAggregateOutputType | null
  }

  export type CheckTrainingApplyAvgAggregateOutputType = {
    score: number | null
  }

  export type CheckTrainingApplySumAggregateOutputType = {
    score: number | null
  }

  export type CheckTrainingApplyMinAggregateOutputType = {
    id: string | null
    training_applyId: string | null
    description: string | null
    score: number | null
    is_active: boolean | null
    is_seen: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CheckTrainingApplyMaxAggregateOutputType = {
    id: string | null
    training_applyId: string | null
    description: string | null
    score: number | null
    is_active: boolean | null
    is_seen: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CheckTrainingApplyCountAggregateOutputType = {
    id: number
    training_applyId: number
    description: number
    score: number
    is_active: number
    is_seen: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CheckTrainingApplyAvgAggregateInputType = {
    score?: true
  }

  export type CheckTrainingApplySumAggregateInputType = {
    score?: true
  }

  export type CheckTrainingApplyMinAggregateInputType = {
    id?: true
    training_applyId?: true
    description?: true
    score?: true
    is_active?: true
    is_seen?: true
    created_at?: true
    updated_at?: true
  }

  export type CheckTrainingApplyMaxAggregateInputType = {
    id?: true
    training_applyId?: true
    description?: true
    score?: true
    is_active?: true
    is_seen?: true
    created_at?: true
    updated_at?: true
  }

  export type CheckTrainingApplyCountAggregateInputType = {
    id?: true
    training_applyId?: true
    description?: true
    score?: true
    is_active?: true
    is_seen?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CheckTrainingApplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheckTrainingApply to aggregate.
     */
    where?: CheckTrainingApplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckTrainingApplies to fetch.
     */
    orderBy?: CheckTrainingApplyOrderByWithRelationInput | CheckTrainingApplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CheckTrainingApplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckTrainingApplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckTrainingApplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CheckTrainingApplies
    **/
    _count?: true | CheckTrainingApplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CheckTrainingApplyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CheckTrainingApplySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CheckTrainingApplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CheckTrainingApplyMaxAggregateInputType
  }

  export type GetCheckTrainingApplyAggregateType<T extends CheckTrainingApplyAggregateArgs> = {
        [P in keyof T & keyof AggregateCheckTrainingApply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCheckTrainingApply[P]>
      : GetScalarType<T[P], AggregateCheckTrainingApply[P]>
  }




  export type CheckTrainingApplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckTrainingApplyWhereInput
    orderBy?: CheckTrainingApplyOrderByWithAggregationInput | CheckTrainingApplyOrderByWithAggregationInput[]
    by: CheckTrainingApplyScalarFieldEnum[] | CheckTrainingApplyScalarFieldEnum
    having?: CheckTrainingApplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CheckTrainingApplyCountAggregateInputType | true
    _avg?: CheckTrainingApplyAvgAggregateInputType
    _sum?: CheckTrainingApplySumAggregateInputType
    _min?: CheckTrainingApplyMinAggregateInputType
    _max?: CheckTrainingApplyMaxAggregateInputType
  }

  export type CheckTrainingApplyGroupByOutputType = {
    id: string
    training_applyId: string
    description: string | null
    score: number
    is_active: boolean | null
    is_seen: boolean | null
    created_at: Date
    updated_at: Date
    _count: CheckTrainingApplyCountAggregateOutputType | null
    _avg: CheckTrainingApplyAvgAggregateOutputType | null
    _sum: CheckTrainingApplySumAggregateOutputType | null
    _min: CheckTrainingApplyMinAggregateOutputType | null
    _max: CheckTrainingApplyMaxAggregateOutputType | null
  }

  type GetCheckTrainingApplyGroupByPayload<T extends CheckTrainingApplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CheckTrainingApplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CheckTrainingApplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CheckTrainingApplyGroupByOutputType[P]>
            : GetScalarType<T[P], CheckTrainingApplyGroupByOutputType[P]>
        }
      >
    >


  export type CheckTrainingApplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    training_applyId?: boolean
    description?: boolean
    score?: boolean
    is_active?: boolean
    is_seen?: boolean
    created_at?: boolean
    updated_at?: boolean
    training_apply?: boolean | TrainingApplyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checkTrainingApply"]>

  export type CheckTrainingApplySelectScalar = {
    id?: boolean
    training_applyId?: boolean
    description?: boolean
    score?: boolean
    is_active?: boolean
    is_seen?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CheckTrainingApplyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training_apply?: boolean | TrainingApplyDefaultArgs<ExtArgs>
  }


  export type $CheckTrainingApplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CheckTrainingApply"
    objects: {
      training_apply: Prisma.$TrainingApplyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      training_applyId: string
      description: string | null
      score: number
      is_active: boolean | null
      is_seen: boolean | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["checkTrainingApply"]>
    composites: {}
  }


  type CheckTrainingApplyGetPayload<S extends boolean | null | undefined | CheckTrainingApplyDefaultArgs> = $Result.GetResult<Prisma.$CheckTrainingApplyPayload, S>

  type CheckTrainingApplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CheckTrainingApplyFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CheckTrainingApplyCountAggregateInputType | true
    }

  export interface CheckTrainingApplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CheckTrainingApply'], meta: { name: 'CheckTrainingApply' } }
    /**
     * Find zero or one CheckTrainingApply that matches the filter.
     * @param {CheckTrainingApplyFindUniqueArgs} args - Arguments to find a CheckTrainingApply
     * @example
     * // Get one CheckTrainingApply
     * const checkTrainingApply = await prisma.checkTrainingApply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CheckTrainingApplyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CheckTrainingApplyFindUniqueArgs<ExtArgs>>
    ): Prisma__CheckTrainingApplyClient<$Result.GetResult<Prisma.$CheckTrainingApplyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CheckTrainingApply that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CheckTrainingApplyFindUniqueOrThrowArgs} args - Arguments to find a CheckTrainingApply
     * @example
     * // Get one CheckTrainingApply
     * const checkTrainingApply = await prisma.checkTrainingApply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CheckTrainingApplyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CheckTrainingApplyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CheckTrainingApplyClient<$Result.GetResult<Prisma.$CheckTrainingApplyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CheckTrainingApply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckTrainingApplyFindFirstArgs} args - Arguments to find a CheckTrainingApply
     * @example
     * // Get one CheckTrainingApply
     * const checkTrainingApply = await prisma.checkTrainingApply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CheckTrainingApplyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CheckTrainingApplyFindFirstArgs<ExtArgs>>
    ): Prisma__CheckTrainingApplyClient<$Result.GetResult<Prisma.$CheckTrainingApplyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CheckTrainingApply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckTrainingApplyFindFirstOrThrowArgs} args - Arguments to find a CheckTrainingApply
     * @example
     * // Get one CheckTrainingApply
     * const checkTrainingApply = await prisma.checkTrainingApply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CheckTrainingApplyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CheckTrainingApplyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CheckTrainingApplyClient<$Result.GetResult<Prisma.$CheckTrainingApplyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CheckTrainingApplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckTrainingApplyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CheckTrainingApplies
     * const checkTrainingApplies = await prisma.checkTrainingApply.findMany()
     * 
     * // Get first 10 CheckTrainingApplies
     * const checkTrainingApplies = await prisma.checkTrainingApply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checkTrainingApplyWithIdOnly = await prisma.checkTrainingApply.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CheckTrainingApplyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CheckTrainingApplyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckTrainingApplyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CheckTrainingApply.
     * @param {CheckTrainingApplyCreateArgs} args - Arguments to create a CheckTrainingApply.
     * @example
     * // Create one CheckTrainingApply
     * const CheckTrainingApply = await prisma.checkTrainingApply.create({
     *   data: {
     *     // ... data to create a CheckTrainingApply
     *   }
     * })
     * 
    **/
    create<T extends CheckTrainingApplyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CheckTrainingApplyCreateArgs<ExtArgs>>
    ): Prisma__CheckTrainingApplyClient<$Result.GetResult<Prisma.$CheckTrainingApplyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CheckTrainingApplies.
     *     @param {CheckTrainingApplyCreateManyArgs} args - Arguments to create many CheckTrainingApplies.
     *     @example
     *     // Create many CheckTrainingApplies
     *     const checkTrainingApply = await prisma.checkTrainingApply.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CheckTrainingApplyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CheckTrainingApplyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CheckTrainingApply.
     * @param {CheckTrainingApplyDeleteArgs} args - Arguments to delete one CheckTrainingApply.
     * @example
     * // Delete one CheckTrainingApply
     * const CheckTrainingApply = await prisma.checkTrainingApply.delete({
     *   where: {
     *     // ... filter to delete one CheckTrainingApply
     *   }
     * })
     * 
    **/
    delete<T extends CheckTrainingApplyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CheckTrainingApplyDeleteArgs<ExtArgs>>
    ): Prisma__CheckTrainingApplyClient<$Result.GetResult<Prisma.$CheckTrainingApplyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CheckTrainingApply.
     * @param {CheckTrainingApplyUpdateArgs} args - Arguments to update one CheckTrainingApply.
     * @example
     * // Update one CheckTrainingApply
     * const checkTrainingApply = await prisma.checkTrainingApply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CheckTrainingApplyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CheckTrainingApplyUpdateArgs<ExtArgs>>
    ): Prisma__CheckTrainingApplyClient<$Result.GetResult<Prisma.$CheckTrainingApplyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CheckTrainingApplies.
     * @param {CheckTrainingApplyDeleteManyArgs} args - Arguments to filter CheckTrainingApplies to delete.
     * @example
     * // Delete a few CheckTrainingApplies
     * const { count } = await prisma.checkTrainingApply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CheckTrainingApplyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CheckTrainingApplyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CheckTrainingApplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckTrainingApplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CheckTrainingApplies
     * const checkTrainingApply = await prisma.checkTrainingApply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CheckTrainingApplyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CheckTrainingApplyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CheckTrainingApply.
     * @param {CheckTrainingApplyUpsertArgs} args - Arguments to update or create a CheckTrainingApply.
     * @example
     * // Update or create a CheckTrainingApply
     * const checkTrainingApply = await prisma.checkTrainingApply.upsert({
     *   create: {
     *     // ... data to create a CheckTrainingApply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CheckTrainingApply we want to update
     *   }
     * })
    **/
    upsert<T extends CheckTrainingApplyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CheckTrainingApplyUpsertArgs<ExtArgs>>
    ): Prisma__CheckTrainingApplyClient<$Result.GetResult<Prisma.$CheckTrainingApplyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CheckTrainingApplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckTrainingApplyCountArgs} args - Arguments to filter CheckTrainingApplies to count.
     * @example
     * // Count the number of CheckTrainingApplies
     * const count = await prisma.checkTrainingApply.count({
     *   where: {
     *     // ... the filter for the CheckTrainingApplies we want to count
     *   }
     * })
    **/
    count<T extends CheckTrainingApplyCountArgs>(
      args?: Subset<T, CheckTrainingApplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CheckTrainingApplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CheckTrainingApply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckTrainingApplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CheckTrainingApplyAggregateArgs>(args: Subset<T, CheckTrainingApplyAggregateArgs>): Prisma.PrismaPromise<GetCheckTrainingApplyAggregateType<T>>

    /**
     * Group by CheckTrainingApply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckTrainingApplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CheckTrainingApplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CheckTrainingApplyGroupByArgs['orderBy'] }
        : { orderBy?: CheckTrainingApplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CheckTrainingApplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCheckTrainingApplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CheckTrainingApply model
   */
  readonly fields: CheckTrainingApplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CheckTrainingApply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CheckTrainingApplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    training_apply<T extends TrainingApplyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingApplyDefaultArgs<ExtArgs>>): Prisma__TrainingApplyClient<$Result.GetResult<Prisma.$TrainingApplyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CheckTrainingApply model
   */ 
  interface CheckTrainingApplyFieldRefs {
    readonly id: FieldRef<"CheckTrainingApply", 'String'>
    readonly training_applyId: FieldRef<"CheckTrainingApply", 'String'>
    readonly description: FieldRef<"CheckTrainingApply", 'String'>
    readonly score: FieldRef<"CheckTrainingApply", 'Int'>
    readonly is_active: FieldRef<"CheckTrainingApply", 'Boolean'>
    readonly is_seen: FieldRef<"CheckTrainingApply", 'Boolean'>
    readonly created_at: FieldRef<"CheckTrainingApply", 'DateTime'>
    readonly updated_at: FieldRef<"CheckTrainingApply", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * CheckTrainingApply findUnique
   */
  export type CheckTrainingApplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckTrainingApply
     */
    select?: CheckTrainingApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckTrainingApplyInclude<ExtArgs> | null
    /**
     * Filter, which CheckTrainingApply to fetch.
     */
    where: CheckTrainingApplyWhereUniqueInput
  }


  /**
   * CheckTrainingApply findUniqueOrThrow
   */
  export type CheckTrainingApplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckTrainingApply
     */
    select?: CheckTrainingApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckTrainingApplyInclude<ExtArgs> | null
    /**
     * Filter, which CheckTrainingApply to fetch.
     */
    where: CheckTrainingApplyWhereUniqueInput
  }


  /**
   * CheckTrainingApply findFirst
   */
  export type CheckTrainingApplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckTrainingApply
     */
    select?: CheckTrainingApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckTrainingApplyInclude<ExtArgs> | null
    /**
     * Filter, which CheckTrainingApply to fetch.
     */
    where?: CheckTrainingApplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckTrainingApplies to fetch.
     */
    orderBy?: CheckTrainingApplyOrderByWithRelationInput | CheckTrainingApplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheckTrainingApplies.
     */
    cursor?: CheckTrainingApplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckTrainingApplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckTrainingApplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheckTrainingApplies.
     */
    distinct?: CheckTrainingApplyScalarFieldEnum | CheckTrainingApplyScalarFieldEnum[]
  }


  /**
   * CheckTrainingApply findFirstOrThrow
   */
  export type CheckTrainingApplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckTrainingApply
     */
    select?: CheckTrainingApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckTrainingApplyInclude<ExtArgs> | null
    /**
     * Filter, which CheckTrainingApply to fetch.
     */
    where?: CheckTrainingApplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckTrainingApplies to fetch.
     */
    orderBy?: CheckTrainingApplyOrderByWithRelationInput | CheckTrainingApplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheckTrainingApplies.
     */
    cursor?: CheckTrainingApplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckTrainingApplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckTrainingApplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheckTrainingApplies.
     */
    distinct?: CheckTrainingApplyScalarFieldEnum | CheckTrainingApplyScalarFieldEnum[]
  }


  /**
   * CheckTrainingApply findMany
   */
  export type CheckTrainingApplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckTrainingApply
     */
    select?: CheckTrainingApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckTrainingApplyInclude<ExtArgs> | null
    /**
     * Filter, which CheckTrainingApplies to fetch.
     */
    where?: CheckTrainingApplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckTrainingApplies to fetch.
     */
    orderBy?: CheckTrainingApplyOrderByWithRelationInput | CheckTrainingApplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CheckTrainingApplies.
     */
    cursor?: CheckTrainingApplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckTrainingApplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckTrainingApplies.
     */
    skip?: number
    distinct?: CheckTrainingApplyScalarFieldEnum | CheckTrainingApplyScalarFieldEnum[]
  }


  /**
   * CheckTrainingApply create
   */
  export type CheckTrainingApplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckTrainingApply
     */
    select?: CheckTrainingApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckTrainingApplyInclude<ExtArgs> | null
    /**
     * The data needed to create a CheckTrainingApply.
     */
    data: XOR<CheckTrainingApplyCreateInput, CheckTrainingApplyUncheckedCreateInput>
  }


  /**
   * CheckTrainingApply createMany
   */
  export type CheckTrainingApplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CheckTrainingApplies.
     */
    data: CheckTrainingApplyCreateManyInput | CheckTrainingApplyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CheckTrainingApply update
   */
  export type CheckTrainingApplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckTrainingApply
     */
    select?: CheckTrainingApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckTrainingApplyInclude<ExtArgs> | null
    /**
     * The data needed to update a CheckTrainingApply.
     */
    data: XOR<CheckTrainingApplyUpdateInput, CheckTrainingApplyUncheckedUpdateInput>
    /**
     * Choose, which CheckTrainingApply to update.
     */
    where: CheckTrainingApplyWhereUniqueInput
  }


  /**
   * CheckTrainingApply updateMany
   */
  export type CheckTrainingApplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CheckTrainingApplies.
     */
    data: XOR<CheckTrainingApplyUpdateManyMutationInput, CheckTrainingApplyUncheckedUpdateManyInput>
    /**
     * Filter which CheckTrainingApplies to update
     */
    where?: CheckTrainingApplyWhereInput
  }


  /**
   * CheckTrainingApply upsert
   */
  export type CheckTrainingApplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckTrainingApply
     */
    select?: CheckTrainingApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckTrainingApplyInclude<ExtArgs> | null
    /**
     * The filter to search for the CheckTrainingApply to update in case it exists.
     */
    where: CheckTrainingApplyWhereUniqueInput
    /**
     * In case the CheckTrainingApply found by the `where` argument doesn't exist, create a new CheckTrainingApply with this data.
     */
    create: XOR<CheckTrainingApplyCreateInput, CheckTrainingApplyUncheckedCreateInput>
    /**
     * In case the CheckTrainingApply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CheckTrainingApplyUpdateInput, CheckTrainingApplyUncheckedUpdateInput>
  }


  /**
   * CheckTrainingApply delete
   */
  export type CheckTrainingApplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckTrainingApply
     */
    select?: CheckTrainingApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckTrainingApplyInclude<ExtArgs> | null
    /**
     * Filter which CheckTrainingApply to delete.
     */
    where: CheckTrainingApplyWhereUniqueInput
  }


  /**
   * CheckTrainingApply deleteMany
   */
  export type CheckTrainingApplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheckTrainingApplies to delete
     */
    where?: CheckTrainingApplyWhereInput
  }


  /**
   * CheckTrainingApply without action
   */
  export type CheckTrainingApplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckTrainingApply
     */
    select?: CheckTrainingApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckTrainingApplyInclude<ExtArgs> | null
  }



  /**
   * Model Lesson
   */

  export type AggregateLesson = {
    _count: LessonCountAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  export type LessonMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    file: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LessonMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    file: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LessonCountAggregateOutputType = {
    id: number
    title: number
    description: number
    file: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type LessonMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    file?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type LessonMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    file?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type LessonCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    file?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type LessonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lesson to aggregate.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lessons
    **/
    _count?: true | LessonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonMaxAggregateInputType
  }

  export type GetLessonAggregateType<T extends LessonAggregateArgs> = {
        [P in keyof T & keyof AggregateLesson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLesson[P]>
      : GetScalarType<T[P], AggregateLesson[P]>
  }




  export type LessonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithAggregationInput | LessonOrderByWithAggregationInput[]
    by: LessonScalarFieldEnum[] | LessonScalarFieldEnum
    having?: LessonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonCountAggregateInputType | true
    _min?: LessonMinAggregateInputType
    _max?: LessonMaxAggregateInputType
  }

  export type LessonGroupByOutputType = {
    id: string
    title: string
    description: string | null
    file: string | null
    is_active: boolean | null
    created_at: Date
    updated_at: Date
    _count: LessonCountAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  type GetLessonGroupByPayload<T extends LessonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonGroupByOutputType[P]>
            : GetScalarType<T[P], LessonGroupByOutputType[P]>
        }
      >
    >


  export type LessonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    file?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    tasks?: boolean | Lesson$tasksArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    file?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type LessonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | Lesson$tasksArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $LessonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lesson"
    objects: {
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      file: string | null
      is_active: boolean | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["lesson"]>
    composites: {}
  }


  type LessonGetPayload<S extends boolean | null | undefined | LessonDefaultArgs> = $Result.GetResult<Prisma.$LessonPayload, S>

  type LessonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LessonFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: LessonCountAggregateInputType | true
    }

  export interface LessonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lesson'], meta: { name: 'Lesson' } }
    /**
     * Find zero or one Lesson that matches the filter.
     * @param {LessonFindUniqueArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LessonFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LessonFindUniqueArgs<ExtArgs>>
    ): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Lesson that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LessonFindUniqueOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LessonFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LessonFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Lesson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LessonFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LessonFindFirstArgs<ExtArgs>>
    ): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Lesson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LessonFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LessonFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lessons
     * const lessons = await prisma.lesson.findMany()
     * 
     * // Get first 10 Lessons
     * const lessons = await prisma.lesson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonWithIdOnly = await prisma.lesson.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LessonFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LessonFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Lesson.
     * @param {LessonCreateArgs} args - Arguments to create a Lesson.
     * @example
     * // Create one Lesson
     * const Lesson = await prisma.lesson.create({
     *   data: {
     *     // ... data to create a Lesson
     *   }
     * })
     * 
    **/
    create<T extends LessonCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LessonCreateArgs<ExtArgs>>
    ): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Lessons.
     *     @param {LessonCreateManyArgs} args - Arguments to create many Lessons.
     *     @example
     *     // Create many Lessons
     *     const lesson = await prisma.lesson.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LessonCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LessonCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lesson.
     * @param {LessonDeleteArgs} args - Arguments to delete one Lesson.
     * @example
     * // Delete one Lesson
     * const Lesson = await prisma.lesson.delete({
     *   where: {
     *     // ... filter to delete one Lesson
     *   }
     * })
     * 
    **/
    delete<T extends LessonDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LessonDeleteArgs<ExtArgs>>
    ): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Lesson.
     * @param {LessonUpdateArgs} args - Arguments to update one Lesson.
     * @example
     * // Update one Lesson
     * const lesson = await prisma.lesson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LessonUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LessonUpdateArgs<ExtArgs>>
    ): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Lessons.
     * @param {LessonDeleteManyArgs} args - Arguments to filter Lessons to delete.
     * @example
     * // Delete a few Lessons
     * const { count } = await prisma.lesson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LessonDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LessonDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LessonUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LessonUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lesson.
     * @param {LessonUpsertArgs} args - Arguments to update or create a Lesson.
     * @example
     * // Update or create a Lesson
     * const lesson = await prisma.lesson.upsert({
     *   create: {
     *     // ... data to create a Lesson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lesson we want to update
     *   }
     * })
    **/
    upsert<T extends LessonUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LessonUpsertArgs<ExtArgs>>
    ): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCountArgs} args - Arguments to filter Lessons to count.
     * @example
     * // Count the number of Lessons
     * const count = await prisma.lesson.count({
     *   where: {
     *     // ... the filter for the Lessons we want to count
     *   }
     * })
    **/
    count<T extends LessonCountArgs>(
      args?: Subset<T, LessonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonAggregateArgs>(args: Subset<T, LessonAggregateArgs>): Prisma.PrismaPromise<GetLessonAggregateType<T>>

    /**
     * Group by Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonGroupByArgs['orderBy'] }
        : { orderBy?: LessonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lesson model
   */
  readonly fields: LessonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lesson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tasks<T extends Lesson$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Lesson model
   */ 
  interface LessonFieldRefs {
    readonly id: FieldRef<"Lesson", 'String'>
    readonly title: FieldRef<"Lesson", 'String'>
    readonly description: FieldRef<"Lesson", 'String'>
    readonly file: FieldRef<"Lesson", 'String'>
    readonly is_active: FieldRef<"Lesson", 'Boolean'>
    readonly created_at: FieldRef<"Lesson", 'DateTime'>
    readonly updated_at: FieldRef<"Lesson", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Lesson findUnique
   */
  export type LessonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }


  /**
   * Lesson findUniqueOrThrow
   */
  export type LessonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }


  /**
   * Lesson findFirst
   */
  export type LessonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }


  /**
   * Lesson findFirstOrThrow
   */
  export type LessonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }


  /**
   * Lesson findMany
   */
  export type LessonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }


  /**
   * Lesson create
   */
  export type LessonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to create a Lesson.
     */
    data: XOR<LessonCreateInput, LessonUncheckedCreateInput>
  }


  /**
   * Lesson createMany
   */
  export type LessonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Lesson update
   */
  export type LessonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to update a Lesson.
     */
    data: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
    /**
     * Choose, which Lesson to update.
     */
    where: LessonWhereUniqueInput
  }


  /**
   * Lesson updateMany
   */
  export type LessonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
  }


  /**
   * Lesson upsert
   */
  export type LessonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The filter to search for the Lesson to update in case it exists.
     */
    where: LessonWhereUniqueInput
    /**
     * In case the Lesson found by the `where` argument doesn't exist, create a new Lesson with this data.
     */
    create: XOR<LessonCreateInput, LessonUncheckedCreateInput>
    /**
     * In case the Lesson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
  }


  /**
   * Lesson delete
   */
  export type LessonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter which Lesson to delete.
     */
    where: LessonWhereUniqueInput
  }


  /**
   * Lesson deleteMany
   */
  export type LessonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lessons to delete
     */
    where?: LessonWhereInput
  }


  /**
   * Lesson.tasks
   */
  export type Lesson$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }


  /**
   * Lesson without action
   */
  export type LessonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonInclude<ExtArgs> | null
  }



  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    score: number | null
  }

  export type TaskSumAggregateOutputType = {
    score: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    file: string | null
    score: number | null
    is_active: boolean | null
    lessonId: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    file: string | null
    score: number | null
    is_active: boolean | null
    lessonId: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    title: number
    description: number
    file: number
    score: number
    is_active: number
    lessonId: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    score?: true
  }

  export type TaskSumAggregateInputType = {
    score?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    file?: true
    score?: true
    is_active?: true
    lessonId?: true
    created_at?: true
    updated_at?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    file?: true
    score?: true
    is_active?: true
    lessonId?: true
    created_at?: true
    updated_at?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    file?: true
    score?: true
    is_active?: true
    lessonId?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    title: string
    description: string | null
    file: string | null
    score: number
    is_active: boolean | null
    lessonId: string
    created_at: Date
    updated_at: Date
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    file?: boolean
    score?: boolean
    is_active?: boolean
    lessonId?: boolean
    created_at?: boolean
    updated_at?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    criterias?: boolean | Task$criteriasArgs<ExtArgs>
    task_applys?: boolean | Task$task_applysArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    file?: boolean
    score?: boolean
    is_active?: boolean
    lessonId?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    criterias?: boolean | Task$criteriasArgs<ExtArgs>
    task_applys?: boolean | Task$task_applysArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      lesson: Prisma.$LessonPayload<ExtArgs>
      criterias: Prisma.$TaskCriteriaPayload<ExtArgs>[]
      task_applys: Prisma.$TaskApplyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      file: string | null
      score: number
      is_active: boolean | null
      lessonId: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["task"]>
    composites: {}
  }


  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TaskFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>
    ): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Task that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TaskFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>
    ): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TaskFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
    **/
    create<T extends TaskCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TaskCreateArgs<ExtArgs>>
    ): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tasks.
     *     @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     *     @example
     *     // Create many Tasks
     *     const task = await prisma.task.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TaskCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
    **/
    delete<T extends TaskDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>
    ): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TaskUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>
    ): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TaskDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TaskUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
    **/
    upsert<T extends TaskUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>
    ): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    criterias<T extends Task$criteriasArgs<ExtArgs> = {}>(args?: Subset<T, Task$criteriasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCriteriaPayload<ExtArgs>, T, 'findMany'> | Null>;

    task_applys<T extends Task$task_applysArgs<ExtArgs> = {}>(args?: Subset<T, Task$task_applysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskApplyPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Task model
   */ 
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly file: FieldRef<"Task", 'String'>
    readonly score: FieldRef<"Task", 'Int'>
    readonly is_active: FieldRef<"Task", 'Boolean'>
    readonly lessonId: FieldRef<"Task", 'String'>
    readonly created_at: FieldRef<"Task", 'DateTime'>
    readonly updated_at: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }


  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }


  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }


  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }


  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }


  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }


  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }


  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
  }


  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }


  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }


  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
  }


  /**
   * Task.criterias
   */
  export type Task$criteriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCriteria
     */
    select?: TaskCriteriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskCriteriaInclude<ExtArgs> | null
    where?: TaskCriteriaWhereInput
    orderBy?: TaskCriteriaOrderByWithRelationInput | TaskCriteriaOrderByWithRelationInput[]
    cursor?: TaskCriteriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskCriteriaScalarFieldEnum | TaskCriteriaScalarFieldEnum[]
  }


  /**
   * Task.task_applys
   */
  export type Task$task_applysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskApply
     */
    select?: TaskApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskApplyInclude<ExtArgs> | null
    where?: TaskApplyWhereInput
    orderBy?: TaskApplyOrderByWithRelationInput | TaskApplyOrderByWithRelationInput[]
    cursor?: TaskApplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskApplyScalarFieldEnum | TaskApplyScalarFieldEnum[]
  }


  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskInclude<ExtArgs> | null
  }



  /**
   * Model TaskCriteria
   */

  export type AggregateTaskCriteria = {
    _count: TaskCriteriaCountAggregateOutputType | null
    _avg: TaskCriteriaAvgAggregateOutputType | null
    _sum: TaskCriteriaSumAggregateOutputType | null
    _min: TaskCriteriaMinAggregateOutputType | null
    _max: TaskCriteriaMaxAggregateOutputType | null
  }

  export type TaskCriteriaAvgAggregateOutputType = {
    value: number | null
  }

  export type TaskCriteriaSumAggregateOutputType = {
    value: number | null
  }

  export type TaskCriteriaMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: number | null
    description: string | null
    taskId: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TaskCriteriaMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: number | null
    description: string | null
    taskId: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TaskCriteriaCountAggregateOutputType = {
    id: number
    key: number
    value: number
    description: number
    taskId: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TaskCriteriaAvgAggregateInputType = {
    value?: true
  }

  export type TaskCriteriaSumAggregateInputType = {
    value?: true
  }

  export type TaskCriteriaMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    taskId?: true
    created_at?: true
    updated_at?: true
  }

  export type TaskCriteriaMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    taskId?: true
    created_at?: true
    updated_at?: true
  }

  export type TaskCriteriaCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    taskId?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TaskCriteriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskCriteria to aggregate.
     */
    where?: TaskCriteriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCriteria to fetch.
     */
    orderBy?: TaskCriteriaOrderByWithRelationInput | TaskCriteriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskCriteriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCriteria from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCriteria.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskCriteria
    **/
    _count?: true | TaskCriteriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskCriteriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskCriteriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskCriteriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskCriteriaMaxAggregateInputType
  }

  export type GetTaskCriteriaAggregateType<T extends TaskCriteriaAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskCriteria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskCriteria[P]>
      : GetScalarType<T[P], AggregateTaskCriteria[P]>
  }




  export type TaskCriteriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskCriteriaWhereInput
    orderBy?: TaskCriteriaOrderByWithAggregationInput | TaskCriteriaOrderByWithAggregationInput[]
    by: TaskCriteriaScalarFieldEnum[] | TaskCriteriaScalarFieldEnum
    having?: TaskCriteriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCriteriaCountAggregateInputType | true
    _avg?: TaskCriteriaAvgAggregateInputType
    _sum?: TaskCriteriaSumAggregateInputType
    _min?: TaskCriteriaMinAggregateInputType
    _max?: TaskCriteriaMaxAggregateInputType
  }

  export type TaskCriteriaGroupByOutputType = {
    id: string
    key: string
    value: number
    description: string | null
    taskId: string
    created_at: Date
    updated_at: Date
    _count: TaskCriteriaCountAggregateOutputType | null
    _avg: TaskCriteriaAvgAggregateOutputType | null
    _sum: TaskCriteriaSumAggregateOutputType | null
    _min: TaskCriteriaMinAggregateOutputType | null
    _max: TaskCriteriaMaxAggregateOutputType | null
  }

  type GetTaskCriteriaGroupByPayload<T extends TaskCriteriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskCriteriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskCriteriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskCriteriaGroupByOutputType[P]>
            : GetScalarType<T[P], TaskCriteriaGroupByOutputType[P]>
        }
      >
    >


  export type TaskCriteriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    taskId?: boolean
    created_at?: boolean
    updated_at?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    checks_criterias?: boolean | TaskCriteria$checks_criteriasArgs<ExtArgs>
    _count?: boolean | TaskCriteriaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskCriteria"]>

  export type TaskCriteriaSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    taskId?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TaskCriteriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    checks_criterias?: boolean | TaskCriteria$checks_criteriasArgs<ExtArgs>
    _count?: boolean | TaskCriteriaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TaskCriteriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskCriteria"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      checks_criterias: Prisma.$CheckWithTaskCriteriasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: number
      description: string | null
      taskId: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["taskCriteria"]>
    composites: {}
  }


  type TaskCriteriaGetPayload<S extends boolean | null | undefined | TaskCriteriaDefaultArgs> = $Result.GetResult<Prisma.$TaskCriteriaPayload, S>

  type TaskCriteriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskCriteriaFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: TaskCriteriaCountAggregateInputType | true
    }

  export interface TaskCriteriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskCriteria'], meta: { name: 'TaskCriteria' } }
    /**
     * Find zero or one TaskCriteria that matches the filter.
     * @param {TaskCriteriaFindUniqueArgs} args - Arguments to find a TaskCriteria
     * @example
     * // Get one TaskCriteria
     * const taskCriteria = await prisma.taskCriteria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TaskCriteriaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TaskCriteriaFindUniqueArgs<ExtArgs>>
    ): Prisma__TaskCriteriaClient<$Result.GetResult<Prisma.$TaskCriteriaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TaskCriteria that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TaskCriteriaFindUniqueOrThrowArgs} args - Arguments to find a TaskCriteria
     * @example
     * // Get one TaskCriteria
     * const taskCriteria = await prisma.taskCriteria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TaskCriteriaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskCriteriaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TaskCriteriaClient<$Result.GetResult<Prisma.$TaskCriteriaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TaskCriteria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCriteriaFindFirstArgs} args - Arguments to find a TaskCriteria
     * @example
     * // Get one TaskCriteria
     * const taskCriteria = await prisma.taskCriteria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TaskCriteriaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskCriteriaFindFirstArgs<ExtArgs>>
    ): Prisma__TaskCriteriaClient<$Result.GetResult<Prisma.$TaskCriteriaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TaskCriteria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCriteriaFindFirstOrThrowArgs} args - Arguments to find a TaskCriteria
     * @example
     * // Get one TaskCriteria
     * const taskCriteria = await prisma.taskCriteria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TaskCriteriaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskCriteriaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TaskCriteriaClient<$Result.GetResult<Prisma.$TaskCriteriaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TaskCriteria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCriteriaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskCriteria
     * const taskCriteria = await prisma.taskCriteria.findMany()
     * 
     * // Get first 10 TaskCriteria
     * const taskCriteria = await prisma.taskCriteria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskCriteriaWithIdOnly = await prisma.taskCriteria.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TaskCriteriaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskCriteriaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCriteriaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TaskCriteria.
     * @param {TaskCriteriaCreateArgs} args - Arguments to create a TaskCriteria.
     * @example
     * // Create one TaskCriteria
     * const TaskCriteria = await prisma.taskCriteria.create({
     *   data: {
     *     // ... data to create a TaskCriteria
     *   }
     * })
     * 
    **/
    create<T extends TaskCriteriaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TaskCriteriaCreateArgs<ExtArgs>>
    ): Prisma__TaskCriteriaClient<$Result.GetResult<Prisma.$TaskCriteriaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TaskCriteria.
     *     @param {TaskCriteriaCreateManyArgs} args - Arguments to create many TaskCriteria.
     *     @example
     *     // Create many TaskCriteria
     *     const taskCriteria = await prisma.taskCriteria.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TaskCriteriaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskCriteriaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TaskCriteria.
     * @param {TaskCriteriaDeleteArgs} args - Arguments to delete one TaskCriteria.
     * @example
     * // Delete one TaskCriteria
     * const TaskCriteria = await prisma.taskCriteria.delete({
     *   where: {
     *     // ... filter to delete one TaskCriteria
     *   }
     * })
     * 
    **/
    delete<T extends TaskCriteriaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TaskCriteriaDeleteArgs<ExtArgs>>
    ): Prisma__TaskCriteriaClient<$Result.GetResult<Prisma.$TaskCriteriaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TaskCriteria.
     * @param {TaskCriteriaUpdateArgs} args - Arguments to update one TaskCriteria.
     * @example
     * // Update one TaskCriteria
     * const taskCriteria = await prisma.taskCriteria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TaskCriteriaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TaskCriteriaUpdateArgs<ExtArgs>>
    ): Prisma__TaskCriteriaClient<$Result.GetResult<Prisma.$TaskCriteriaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TaskCriteria.
     * @param {TaskCriteriaDeleteManyArgs} args - Arguments to filter TaskCriteria to delete.
     * @example
     * // Delete a few TaskCriteria
     * const { count } = await prisma.taskCriteria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TaskCriteriaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskCriteriaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskCriteria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCriteriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskCriteria
     * const taskCriteria = await prisma.taskCriteria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TaskCriteriaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TaskCriteriaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskCriteria.
     * @param {TaskCriteriaUpsertArgs} args - Arguments to update or create a TaskCriteria.
     * @example
     * // Update or create a TaskCriteria
     * const taskCriteria = await prisma.taskCriteria.upsert({
     *   create: {
     *     // ... data to create a TaskCriteria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskCriteria we want to update
     *   }
     * })
    **/
    upsert<T extends TaskCriteriaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TaskCriteriaUpsertArgs<ExtArgs>>
    ): Prisma__TaskCriteriaClient<$Result.GetResult<Prisma.$TaskCriteriaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TaskCriteria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCriteriaCountArgs} args - Arguments to filter TaskCriteria to count.
     * @example
     * // Count the number of TaskCriteria
     * const count = await prisma.taskCriteria.count({
     *   where: {
     *     // ... the filter for the TaskCriteria we want to count
     *   }
     * })
    **/
    count<T extends TaskCriteriaCountArgs>(
      args?: Subset<T, TaskCriteriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCriteriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskCriteria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCriteriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskCriteriaAggregateArgs>(args: Subset<T, TaskCriteriaAggregateArgs>): Prisma.PrismaPromise<GetTaskCriteriaAggregateType<T>>

    /**
     * Group by TaskCriteria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCriteriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskCriteriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskCriteriaGroupByArgs['orderBy'] }
        : { orderBy?: TaskCriteriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskCriteriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskCriteriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskCriteria model
   */
  readonly fields: TaskCriteriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskCriteria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskCriteriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    checks_criterias<T extends TaskCriteria$checks_criteriasArgs<ExtArgs> = {}>(args?: Subset<T, TaskCriteria$checks_criteriasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckWithTaskCriteriasPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TaskCriteria model
   */ 
  interface TaskCriteriaFieldRefs {
    readonly id: FieldRef<"TaskCriteria", 'String'>
    readonly key: FieldRef<"TaskCriteria", 'String'>
    readonly value: FieldRef<"TaskCriteria", 'Int'>
    readonly description: FieldRef<"TaskCriteria", 'String'>
    readonly taskId: FieldRef<"TaskCriteria", 'String'>
    readonly created_at: FieldRef<"TaskCriteria", 'DateTime'>
    readonly updated_at: FieldRef<"TaskCriteria", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * TaskCriteria findUnique
   */
  export type TaskCriteriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCriteria
     */
    select?: TaskCriteriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskCriteriaInclude<ExtArgs> | null
    /**
     * Filter, which TaskCriteria to fetch.
     */
    where: TaskCriteriaWhereUniqueInput
  }


  /**
   * TaskCriteria findUniqueOrThrow
   */
  export type TaskCriteriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCriteria
     */
    select?: TaskCriteriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskCriteriaInclude<ExtArgs> | null
    /**
     * Filter, which TaskCriteria to fetch.
     */
    where: TaskCriteriaWhereUniqueInput
  }


  /**
   * TaskCriteria findFirst
   */
  export type TaskCriteriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCriteria
     */
    select?: TaskCriteriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskCriteriaInclude<ExtArgs> | null
    /**
     * Filter, which TaskCriteria to fetch.
     */
    where?: TaskCriteriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCriteria to fetch.
     */
    orderBy?: TaskCriteriaOrderByWithRelationInput | TaskCriteriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskCriteria.
     */
    cursor?: TaskCriteriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCriteria from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCriteria.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskCriteria.
     */
    distinct?: TaskCriteriaScalarFieldEnum | TaskCriteriaScalarFieldEnum[]
  }


  /**
   * TaskCriteria findFirstOrThrow
   */
  export type TaskCriteriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCriteria
     */
    select?: TaskCriteriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskCriteriaInclude<ExtArgs> | null
    /**
     * Filter, which TaskCriteria to fetch.
     */
    where?: TaskCriteriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCriteria to fetch.
     */
    orderBy?: TaskCriteriaOrderByWithRelationInput | TaskCriteriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskCriteria.
     */
    cursor?: TaskCriteriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCriteria from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCriteria.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskCriteria.
     */
    distinct?: TaskCriteriaScalarFieldEnum | TaskCriteriaScalarFieldEnum[]
  }


  /**
   * TaskCriteria findMany
   */
  export type TaskCriteriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCriteria
     */
    select?: TaskCriteriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskCriteriaInclude<ExtArgs> | null
    /**
     * Filter, which TaskCriteria to fetch.
     */
    where?: TaskCriteriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCriteria to fetch.
     */
    orderBy?: TaskCriteriaOrderByWithRelationInput | TaskCriteriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskCriteria.
     */
    cursor?: TaskCriteriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCriteria from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCriteria.
     */
    skip?: number
    distinct?: TaskCriteriaScalarFieldEnum | TaskCriteriaScalarFieldEnum[]
  }


  /**
   * TaskCriteria create
   */
  export type TaskCriteriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCriteria
     */
    select?: TaskCriteriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskCriteriaInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskCriteria.
     */
    data: XOR<TaskCriteriaCreateInput, TaskCriteriaUncheckedCreateInput>
  }


  /**
   * TaskCriteria createMany
   */
  export type TaskCriteriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskCriteria.
     */
    data: TaskCriteriaCreateManyInput | TaskCriteriaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TaskCriteria update
   */
  export type TaskCriteriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCriteria
     */
    select?: TaskCriteriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskCriteriaInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskCriteria.
     */
    data: XOR<TaskCriteriaUpdateInput, TaskCriteriaUncheckedUpdateInput>
    /**
     * Choose, which TaskCriteria to update.
     */
    where: TaskCriteriaWhereUniqueInput
  }


  /**
   * TaskCriteria updateMany
   */
  export type TaskCriteriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskCriteria.
     */
    data: XOR<TaskCriteriaUpdateManyMutationInput, TaskCriteriaUncheckedUpdateManyInput>
    /**
     * Filter which TaskCriteria to update
     */
    where?: TaskCriteriaWhereInput
  }


  /**
   * TaskCriteria upsert
   */
  export type TaskCriteriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCriteria
     */
    select?: TaskCriteriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskCriteriaInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskCriteria to update in case it exists.
     */
    where: TaskCriteriaWhereUniqueInput
    /**
     * In case the TaskCriteria found by the `where` argument doesn't exist, create a new TaskCriteria with this data.
     */
    create: XOR<TaskCriteriaCreateInput, TaskCriteriaUncheckedCreateInput>
    /**
     * In case the TaskCriteria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskCriteriaUpdateInput, TaskCriteriaUncheckedUpdateInput>
  }


  /**
   * TaskCriteria delete
   */
  export type TaskCriteriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCriteria
     */
    select?: TaskCriteriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskCriteriaInclude<ExtArgs> | null
    /**
     * Filter which TaskCriteria to delete.
     */
    where: TaskCriteriaWhereUniqueInput
  }


  /**
   * TaskCriteria deleteMany
   */
  export type TaskCriteriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskCriteria to delete
     */
    where?: TaskCriteriaWhereInput
  }


  /**
   * TaskCriteria.checks_criterias
   */
  export type TaskCriteria$checks_criteriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckWithTaskCriterias
     */
    select?: CheckWithTaskCriteriasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckWithTaskCriteriasInclude<ExtArgs> | null
    where?: CheckWithTaskCriteriasWhereInput
    orderBy?: CheckWithTaskCriteriasOrderByWithRelationInput | CheckWithTaskCriteriasOrderByWithRelationInput[]
    cursor?: CheckWithTaskCriteriasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckWithTaskCriteriasScalarFieldEnum | CheckWithTaskCriteriasScalarFieldEnum[]
  }


  /**
   * TaskCriteria without action
   */
  export type TaskCriteriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCriteria
     */
    select?: TaskCriteriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskCriteriaInclude<ExtArgs> | null
  }



  /**
   * Model TaskApply
   */

  export type AggregateTaskApply = {
    _count: TaskApplyCountAggregateOutputType | null
    _avg: TaskApplyAvgAggregateOutputType | null
    _sum: TaskApplySumAggregateOutputType | null
    _min: TaskApplyMinAggregateOutputType | null
    _max: TaskApplyMaxAggregateOutputType | null
  }

  export type TaskApplyAvgAggregateOutputType = {
    overall_score: number | null
  }

  export type TaskApplySumAggregateOutputType = {
    overall_score: number | null
  }

  export type TaskApplyMinAggregateOutputType = {
    id: string | null
    teacherId: string | null
    taskId: string | null
    overall_score: number | null
    description: string | null
    file: string | null
    is_active: boolean | null
    is_seen: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TaskApplyMaxAggregateOutputType = {
    id: string | null
    teacherId: string | null
    taskId: string | null
    overall_score: number | null
    description: string | null
    file: string | null
    is_active: boolean | null
    is_seen: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TaskApplyCountAggregateOutputType = {
    id: number
    teacherId: number
    taskId: number
    overall_score: number
    description: number
    file: number
    is_active: number
    is_seen: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TaskApplyAvgAggregateInputType = {
    overall_score?: true
  }

  export type TaskApplySumAggregateInputType = {
    overall_score?: true
  }

  export type TaskApplyMinAggregateInputType = {
    id?: true
    teacherId?: true
    taskId?: true
    overall_score?: true
    description?: true
    file?: true
    is_active?: true
    is_seen?: true
    created_at?: true
    updated_at?: true
  }

  export type TaskApplyMaxAggregateInputType = {
    id?: true
    teacherId?: true
    taskId?: true
    overall_score?: true
    description?: true
    file?: true
    is_active?: true
    is_seen?: true
    created_at?: true
    updated_at?: true
  }

  export type TaskApplyCountAggregateInputType = {
    id?: true
    teacherId?: true
    taskId?: true
    overall_score?: true
    description?: true
    file?: true
    is_active?: true
    is_seen?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TaskApplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskApply to aggregate.
     */
    where?: TaskApplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskApplies to fetch.
     */
    orderBy?: TaskApplyOrderByWithRelationInput | TaskApplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskApplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskApplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskApplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskApplies
    **/
    _count?: true | TaskApplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskApplyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskApplySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskApplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskApplyMaxAggregateInputType
  }

  export type GetTaskApplyAggregateType<T extends TaskApplyAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskApply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskApply[P]>
      : GetScalarType<T[P], AggregateTaskApply[P]>
  }




  export type TaskApplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskApplyWhereInput
    orderBy?: TaskApplyOrderByWithAggregationInput | TaskApplyOrderByWithAggregationInput[]
    by: TaskApplyScalarFieldEnum[] | TaskApplyScalarFieldEnum
    having?: TaskApplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskApplyCountAggregateInputType | true
    _avg?: TaskApplyAvgAggregateInputType
    _sum?: TaskApplySumAggregateInputType
    _min?: TaskApplyMinAggregateInputType
    _max?: TaskApplyMaxAggregateInputType
  }

  export type TaskApplyGroupByOutputType = {
    id: string
    teacherId: string
    taskId: string
    overall_score: number | null
    description: string
    file: string | null
    is_active: boolean | null
    is_seen: boolean | null
    created_at: Date
    updated_at: Date
    _count: TaskApplyCountAggregateOutputType | null
    _avg: TaskApplyAvgAggregateOutputType | null
    _sum: TaskApplySumAggregateOutputType | null
    _min: TaskApplyMinAggregateOutputType | null
    _max: TaskApplyMaxAggregateOutputType | null
  }

  type GetTaskApplyGroupByPayload<T extends TaskApplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskApplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskApplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskApplyGroupByOutputType[P]>
            : GetScalarType<T[P], TaskApplyGroupByOutputType[P]>
        }
      >
    >


  export type TaskApplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    taskId?: boolean
    overall_score?: boolean
    description?: boolean
    file?: boolean
    is_active?: boolean
    is_seen?: boolean
    created_at?: boolean
    updated_at?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
    check_task_criterias?: boolean | TaskApply$check_task_criteriasArgs<ExtArgs>
    _count?: boolean | TaskApplyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskApply"]>

  export type TaskApplySelectScalar = {
    id?: boolean
    teacherId?: boolean
    taskId?: boolean
    overall_score?: boolean
    description?: boolean
    file?: boolean
    is_active?: boolean
    is_seen?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TaskApplyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
    check_task_criterias?: boolean | TaskApply$check_task_criteriasArgs<ExtArgs>
    _count?: boolean | TaskApplyCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TaskApplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskApply"
    objects: {
      teacher: Prisma.$TeacherPayload<ExtArgs>
      task: Prisma.$TaskPayload<ExtArgs>
      check_task_criterias: Prisma.$CheckWithTaskCriteriasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teacherId: string
      taskId: string
      overall_score: number | null
      description: string
      file: string | null
      is_active: boolean | null
      is_seen: boolean | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["taskApply"]>
    composites: {}
  }


  type TaskApplyGetPayload<S extends boolean | null | undefined | TaskApplyDefaultArgs> = $Result.GetResult<Prisma.$TaskApplyPayload, S>

  type TaskApplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskApplyFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: TaskApplyCountAggregateInputType | true
    }

  export interface TaskApplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskApply'], meta: { name: 'TaskApply' } }
    /**
     * Find zero or one TaskApply that matches the filter.
     * @param {TaskApplyFindUniqueArgs} args - Arguments to find a TaskApply
     * @example
     * // Get one TaskApply
     * const taskApply = await prisma.taskApply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TaskApplyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TaskApplyFindUniqueArgs<ExtArgs>>
    ): Prisma__TaskApplyClient<$Result.GetResult<Prisma.$TaskApplyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TaskApply that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TaskApplyFindUniqueOrThrowArgs} args - Arguments to find a TaskApply
     * @example
     * // Get one TaskApply
     * const taskApply = await prisma.taskApply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TaskApplyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskApplyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TaskApplyClient<$Result.GetResult<Prisma.$TaskApplyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TaskApply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskApplyFindFirstArgs} args - Arguments to find a TaskApply
     * @example
     * // Get one TaskApply
     * const taskApply = await prisma.taskApply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TaskApplyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskApplyFindFirstArgs<ExtArgs>>
    ): Prisma__TaskApplyClient<$Result.GetResult<Prisma.$TaskApplyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TaskApply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskApplyFindFirstOrThrowArgs} args - Arguments to find a TaskApply
     * @example
     * // Get one TaskApply
     * const taskApply = await prisma.taskApply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TaskApplyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskApplyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TaskApplyClient<$Result.GetResult<Prisma.$TaskApplyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TaskApplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskApplyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskApplies
     * const taskApplies = await prisma.taskApply.findMany()
     * 
     * // Get first 10 TaskApplies
     * const taskApplies = await prisma.taskApply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskApplyWithIdOnly = await prisma.taskApply.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TaskApplyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskApplyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskApplyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TaskApply.
     * @param {TaskApplyCreateArgs} args - Arguments to create a TaskApply.
     * @example
     * // Create one TaskApply
     * const TaskApply = await prisma.taskApply.create({
     *   data: {
     *     // ... data to create a TaskApply
     *   }
     * })
     * 
    **/
    create<T extends TaskApplyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TaskApplyCreateArgs<ExtArgs>>
    ): Prisma__TaskApplyClient<$Result.GetResult<Prisma.$TaskApplyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TaskApplies.
     *     @param {TaskApplyCreateManyArgs} args - Arguments to create many TaskApplies.
     *     @example
     *     // Create many TaskApplies
     *     const taskApply = await prisma.taskApply.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TaskApplyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskApplyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TaskApply.
     * @param {TaskApplyDeleteArgs} args - Arguments to delete one TaskApply.
     * @example
     * // Delete one TaskApply
     * const TaskApply = await prisma.taskApply.delete({
     *   where: {
     *     // ... filter to delete one TaskApply
     *   }
     * })
     * 
    **/
    delete<T extends TaskApplyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TaskApplyDeleteArgs<ExtArgs>>
    ): Prisma__TaskApplyClient<$Result.GetResult<Prisma.$TaskApplyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TaskApply.
     * @param {TaskApplyUpdateArgs} args - Arguments to update one TaskApply.
     * @example
     * // Update one TaskApply
     * const taskApply = await prisma.taskApply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TaskApplyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TaskApplyUpdateArgs<ExtArgs>>
    ): Prisma__TaskApplyClient<$Result.GetResult<Prisma.$TaskApplyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TaskApplies.
     * @param {TaskApplyDeleteManyArgs} args - Arguments to filter TaskApplies to delete.
     * @example
     * // Delete a few TaskApplies
     * const { count } = await prisma.taskApply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TaskApplyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TaskApplyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskApplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskApplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskApplies
     * const taskApply = await prisma.taskApply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TaskApplyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TaskApplyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskApply.
     * @param {TaskApplyUpsertArgs} args - Arguments to update or create a TaskApply.
     * @example
     * // Update or create a TaskApply
     * const taskApply = await prisma.taskApply.upsert({
     *   create: {
     *     // ... data to create a TaskApply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskApply we want to update
     *   }
     * })
    **/
    upsert<T extends TaskApplyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TaskApplyUpsertArgs<ExtArgs>>
    ): Prisma__TaskApplyClient<$Result.GetResult<Prisma.$TaskApplyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TaskApplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskApplyCountArgs} args - Arguments to filter TaskApplies to count.
     * @example
     * // Count the number of TaskApplies
     * const count = await prisma.taskApply.count({
     *   where: {
     *     // ... the filter for the TaskApplies we want to count
     *   }
     * })
    **/
    count<T extends TaskApplyCountArgs>(
      args?: Subset<T, TaskApplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskApplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskApply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskApplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskApplyAggregateArgs>(args: Subset<T, TaskApplyAggregateArgs>): Prisma.PrismaPromise<GetTaskApplyAggregateType<T>>

    /**
     * Group by TaskApply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskApplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskApplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskApplyGroupByArgs['orderBy'] }
        : { orderBy?: TaskApplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskApplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskApplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskApply model
   */
  readonly fields: TaskApplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskApply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskApplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    check_task_criterias<T extends TaskApply$check_task_criteriasArgs<ExtArgs> = {}>(args?: Subset<T, TaskApply$check_task_criteriasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckWithTaskCriteriasPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TaskApply model
   */ 
  interface TaskApplyFieldRefs {
    readonly id: FieldRef<"TaskApply", 'String'>
    readonly teacherId: FieldRef<"TaskApply", 'String'>
    readonly taskId: FieldRef<"TaskApply", 'String'>
    readonly overall_score: FieldRef<"TaskApply", 'Int'>
    readonly description: FieldRef<"TaskApply", 'String'>
    readonly file: FieldRef<"TaskApply", 'String'>
    readonly is_active: FieldRef<"TaskApply", 'Boolean'>
    readonly is_seen: FieldRef<"TaskApply", 'Boolean'>
    readonly created_at: FieldRef<"TaskApply", 'DateTime'>
    readonly updated_at: FieldRef<"TaskApply", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * TaskApply findUnique
   */
  export type TaskApplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskApply
     */
    select?: TaskApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskApplyInclude<ExtArgs> | null
    /**
     * Filter, which TaskApply to fetch.
     */
    where: TaskApplyWhereUniqueInput
  }


  /**
   * TaskApply findUniqueOrThrow
   */
  export type TaskApplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskApply
     */
    select?: TaskApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskApplyInclude<ExtArgs> | null
    /**
     * Filter, which TaskApply to fetch.
     */
    where: TaskApplyWhereUniqueInput
  }


  /**
   * TaskApply findFirst
   */
  export type TaskApplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskApply
     */
    select?: TaskApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskApplyInclude<ExtArgs> | null
    /**
     * Filter, which TaskApply to fetch.
     */
    where?: TaskApplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskApplies to fetch.
     */
    orderBy?: TaskApplyOrderByWithRelationInput | TaskApplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskApplies.
     */
    cursor?: TaskApplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskApplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskApplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskApplies.
     */
    distinct?: TaskApplyScalarFieldEnum | TaskApplyScalarFieldEnum[]
  }


  /**
   * TaskApply findFirstOrThrow
   */
  export type TaskApplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskApply
     */
    select?: TaskApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskApplyInclude<ExtArgs> | null
    /**
     * Filter, which TaskApply to fetch.
     */
    where?: TaskApplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskApplies to fetch.
     */
    orderBy?: TaskApplyOrderByWithRelationInput | TaskApplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskApplies.
     */
    cursor?: TaskApplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskApplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskApplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskApplies.
     */
    distinct?: TaskApplyScalarFieldEnum | TaskApplyScalarFieldEnum[]
  }


  /**
   * TaskApply findMany
   */
  export type TaskApplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskApply
     */
    select?: TaskApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskApplyInclude<ExtArgs> | null
    /**
     * Filter, which TaskApplies to fetch.
     */
    where?: TaskApplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskApplies to fetch.
     */
    orderBy?: TaskApplyOrderByWithRelationInput | TaskApplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskApplies.
     */
    cursor?: TaskApplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskApplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskApplies.
     */
    skip?: number
    distinct?: TaskApplyScalarFieldEnum | TaskApplyScalarFieldEnum[]
  }


  /**
   * TaskApply create
   */
  export type TaskApplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskApply
     */
    select?: TaskApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskApplyInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskApply.
     */
    data: XOR<TaskApplyCreateInput, TaskApplyUncheckedCreateInput>
  }


  /**
   * TaskApply createMany
   */
  export type TaskApplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskApplies.
     */
    data: TaskApplyCreateManyInput | TaskApplyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TaskApply update
   */
  export type TaskApplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskApply
     */
    select?: TaskApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskApplyInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskApply.
     */
    data: XOR<TaskApplyUpdateInput, TaskApplyUncheckedUpdateInput>
    /**
     * Choose, which TaskApply to update.
     */
    where: TaskApplyWhereUniqueInput
  }


  /**
   * TaskApply updateMany
   */
  export type TaskApplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskApplies.
     */
    data: XOR<TaskApplyUpdateManyMutationInput, TaskApplyUncheckedUpdateManyInput>
    /**
     * Filter which TaskApplies to update
     */
    where?: TaskApplyWhereInput
  }


  /**
   * TaskApply upsert
   */
  export type TaskApplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskApply
     */
    select?: TaskApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskApplyInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskApply to update in case it exists.
     */
    where: TaskApplyWhereUniqueInput
    /**
     * In case the TaskApply found by the `where` argument doesn't exist, create a new TaskApply with this data.
     */
    create: XOR<TaskApplyCreateInput, TaskApplyUncheckedCreateInput>
    /**
     * In case the TaskApply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskApplyUpdateInput, TaskApplyUncheckedUpdateInput>
  }


  /**
   * TaskApply delete
   */
  export type TaskApplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskApply
     */
    select?: TaskApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskApplyInclude<ExtArgs> | null
    /**
     * Filter which TaskApply to delete.
     */
    where: TaskApplyWhereUniqueInput
  }


  /**
   * TaskApply deleteMany
   */
  export type TaskApplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskApplies to delete
     */
    where?: TaskApplyWhereInput
  }


  /**
   * TaskApply.check_task_criterias
   */
  export type TaskApply$check_task_criteriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckWithTaskCriterias
     */
    select?: CheckWithTaskCriteriasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckWithTaskCriteriasInclude<ExtArgs> | null
    where?: CheckWithTaskCriteriasWhereInput
    orderBy?: CheckWithTaskCriteriasOrderByWithRelationInput | CheckWithTaskCriteriasOrderByWithRelationInput[]
    cursor?: CheckWithTaskCriteriasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckWithTaskCriteriasScalarFieldEnum | CheckWithTaskCriteriasScalarFieldEnum[]
  }


  /**
   * TaskApply without action
   */
  export type TaskApplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskApply
     */
    select?: TaskApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskApplyInclude<ExtArgs> | null
  }



  /**
   * Model CheckWithTaskCriterias
   */

  export type AggregateCheckWithTaskCriterias = {
    _count: CheckWithTaskCriteriasCountAggregateOutputType | null
    _avg: CheckWithTaskCriteriasAvgAggregateOutputType | null
    _sum: CheckWithTaskCriteriasSumAggregateOutputType | null
    _min: CheckWithTaskCriteriasMinAggregateOutputType | null
    _max: CheckWithTaskCriteriasMaxAggregateOutputType | null
  }

  export type CheckWithTaskCriteriasAvgAggregateOutputType = {
    criteria_score: number | null
  }

  export type CheckWithTaskCriteriasSumAggregateOutputType = {
    criteria_score: number | null
  }

  export type CheckWithTaskCriteriasMinAggregateOutputType = {
    id: string | null
    task_applyId: string | null
    task_criteriaId: string | null
    criteria_score: number | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CheckWithTaskCriteriasMaxAggregateOutputType = {
    id: string | null
    task_applyId: string | null
    task_criteriaId: string | null
    criteria_score: number | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CheckWithTaskCriteriasCountAggregateOutputType = {
    id: number
    task_applyId: number
    task_criteriaId: number
    criteria_score: number
    description: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CheckWithTaskCriteriasAvgAggregateInputType = {
    criteria_score?: true
  }

  export type CheckWithTaskCriteriasSumAggregateInputType = {
    criteria_score?: true
  }

  export type CheckWithTaskCriteriasMinAggregateInputType = {
    id?: true
    task_applyId?: true
    task_criteriaId?: true
    criteria_score?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type CheckWithTaskCriteriasMaxAggregateInputType = {
    id?: true
    task_applyId?: true
    task_criteriaId?: true
    criteria_score?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type CheckWithTaskCriteriasCountAggregateInputType = {
    id?: true
    task_applyId?: true
    task_criteriaId?: true
    criteria_score?: true
    description?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CheckWithTaskCriteriasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheckWithTaskCriterias to aggregate.
     */
    where?: CheckWithTaskCriteriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckWithTaskCriterias to fetch.
     */
    orderBy?: CheckWithTaskCriteriasOrderByWithRelationInput | CheckWithTaskCriteriasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CheckWithTaskCriteriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckWithTaskCriterias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckWithTaskCriterias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CheckWithTaskCriterias
    **/
    _count?: true | CheckWithTaskCriteriasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CheckWithTaskCriteriasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CheckWithTaskCriteriasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CheckWithTaskCriteriasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CheckWithTaskCriteriasMaxAggregateInputType
  }

  export type GetCheckWithTaskCriteriasAggregateType<T extends CheckWithTaskCriteriasAggregateArgs> = {
        [P in keyof T & keyof AggregateCheckWithTaskCriterias]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCheckWithTaskCriterias[P]>
      : GetScalarType<T[P], AggregateCheckWithTaskCriterias[P]>
  }




  export type CheckWithTaskCriteriasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckWithTaskCriteriasWhereInput
    orderBy?: CheckWithTaskCriteriasOrderByWithAggregationInput | CheckWithTaskCriteriasOrderByWithAggregationInput[]
    by: CheckWithTaskCriteriasScalarFieldEnum[] | CheckWithTaskCriteriasScalarFieldEnum
    having?: CheckWithTaskCriteriasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CheckWithTaskCriteriasCountAggregateInputType | true
    _avg?: CheckWithTaskCriteriasAvgAggregateInputType
    _sum?: CheckWithTaskCriteriasSumAggregateInputType
    _min?: CheckWithTaskCriteriasMinAggregateInputType
    _max?: CheckWithTaskCriteriasMaxAggregateInputType
  }

  export type CheckWithTaskCriteriasGroupByOutputType = {
    id: string
    task_applyId: string
    task_criteriaId: string
    criteria_score: number
    description: string | null
    created_at: Date
    updated_at: Date
    _count: CheckWithTaskCriteriasCountAggregateOutputType | null
    _avg: CheckWithTaskCriteriasAvgAggregateOutputType | null
    _sum: CheckWithTaskCriteriasSumAggregateOutputType | null
    _min: CheckWithTaskCriteriasMinAggregateOutputType | null
    _max: CheckWithTaskCriteriasMaxAggregateOutputType | null
  }

  type GetCheckWithTaskCriteriasGroupByPayload<T extends CheckWithTaskCriteriasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CheckWithTaskCriteriasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CheckWithTaskCriteriasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CheckWithTaskCriteriasGroupByOutputType[P]>
            : GetScalarType<T[P], CheckWithTaskCriteriasGroupByOutputType[P]>
        }
      >
    >


  export type CheckWithTaskCriteriasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_applyId?: boolean
    task_criteriaId?: boolean
    criteria_score?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    task_apply?: boolean | TaskApplyDefaultArgs<ExtArgs>
    task_criteria?: boolean | TaskCriteriaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checkWithTaskCriterias"]>

  export type CheckWithTaskCriteriasSelectScalar = {
    id?: boolean
    task_applyId?: boolean
    task_criteriaId?: boolean
    criteria_score?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CheckWithTaskCriteriasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task_apply?: boolean | TaskApplyDefaultArgs<ExtArgs>
    task_criteria?: boolean | TaskCriteriaDefaultArgs<ExtArgs>
  }


  export type $CheckWithTaskCriteriasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CheckWithTaskCriterias"
    objects: {
      task_apply: Prisma.$TaskApplyPayload<ExtArgs>
      task_criteria: Prisma.$TaskCriteriaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      task_applyId: string
      task_criteriaId: string
      criteria_score: number
      description: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["checkWithTaskCriterias"]>
    composites: {}
  }


  type CheckWithTaskCriteriasGetPayload<S extends boolean | null | undefined | CheckWithTaskCriteriasDefaultArgs> = $Result.GetResult<Prisma.$CheckWithTaskCriteriasPayload, S>

  type CheckWithTaskCriteriasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CheckWithTaskCriteriasFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CheckWithTaskCriteriasCountAggregateInputType | true
    }

  export interface CheckWithTaskCriteriasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CheckWithTaskCriterias'], meta: { name: 'CheckWithTaskCriterias' } }
    /**
     * Find zero or one CheckWithTaskCriterias that matches the filter.
     * @param {CheckWithTaskCriteriasFindUniqueArgs} args - Arguments to find a CheckWithTaskCriterias
     * @example
     * // Get one CheckWithTaskCriterias
     * const checkWithTaskCriterias = await prisma.checkWithTaskCriterias.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CheckWithTaskCriteriasFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CheckWithTaskCriteriasFindUniqueArgs<ExtArgs>>
    ): Prisma__CheckWithTaskCriteriasClient<$Result.GetResult<Prisma.$CheckWithTaskCriteriasPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CheckWithTaskCriterias that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CheckWithTaskCriteriasFindUniqueOrThrowArgs} args - Arguments to find a CheckWithTaskCriterias
     * @example
     * // Get one CheckWithTaskCriterias
     * const checkWithTaskCriterias = await prisma.checkWithTaskCriterias.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CheckWithTaskCriteriasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CheckWithTaskCriteriasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CheckWithTaskCriteriasClient<$Result.GetResult<Prisma.$CheckWithTaskCriteriasPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CheckWithTaskCriterias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckWithTaskCriteriasFindFirstArgs} args - Arguments to find a CheckWithTaskCriterias
     * @example
     * // Get one CheckWithTaskCriterias
     * const checkWithTaskCriterias = await prisma.checkWithTaskCriterias.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CheckWithTaskCriteriasFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CheckWithTaskCriteriasFindFirstArgs<ExtArgs>>
    ): Prisma__CheckWithTaskCriteriasClient<$Result.GetResult<Prisma.$CheckWithTaskCriteriasPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CheckWithTaskCriterias that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckWithTaskCriteriasFindFirstOrThrowArgs} args - Arguments to find a CheckWithTaskCriterias
     * @example
     * // Get one CheckWithTaskCriterias
     * const checkWithTaskCriterias = await prisma.checkWithTaskCriterias.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CheckWithTaskCriteriasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CheckWithTaskCriteriasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CheckWithTaskCriteriasClient<$Result.GetResult<Prisma.$CheckWithTaskCriteriasPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CheckWithTaskCriterias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckWithTaskCriteriasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CheckWithTaskCriterias
     * const checkWithTaskCriterias = await prisma.checkWithTaskCriterias.findMany()
     * 
     * // Get first 10 CheckWithTaskCriterias
     * const checkWithTaskCriterias = await prisma.checkWithTaskCriterias.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checkWithTaskCriteriasWithIdOnly = await prisma.checkWithTaskCriterias.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CheckWithTaskCriteriasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CheckWithTaskCriteriasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckWithTaskCriteriasPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CheckWithTaskCriterias.
     * @param {CheckWithTaskCriteriasCreateArgs} args - Arguments to create a CheckWithTaskCriterias.
     * @example
     * // Create one CheckWithTaskCriterias
     * const CheckWithTaskCriterias = await prisma.checkWithTaskCriterias.create({
     *   data: {
     *     // ... data to create a CheckWithTaskCriterias
     *   }
     * })
     * 
    **/
    create<T extends CheckWithTaskCriteriasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CheckWithTaskCriteriasCreateArgs<ExtArgs>>
    ): Prisma__CheckWithTaskCriteriasClient<$Result.GetResult<Prisma.$CheckWithTaskCriteriasPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CheckWithTaskCriterias.
     *     @param {CheckWithTaskCriteriasCreateManyArgs} args - Arguments to create many CheckWithTaskCriterias.
     *     @example
     *     // Create many CheckWithTaskCriterias
     *     const checkWithTaskCriterias = await prisma.checkWithTaskCriterias.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CheckWithTaskCriteriasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CheckWithTaskCriteriasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CheckWithTaskCriterias.
     * @param {CheckWithTaskCriteriasDeleteArgs} args - Arguments to delete one CheckWithTaskCriterias.
     * @example
     * // Delete one CheckWithTaskCriterias
     * const CheckWithTaskCriterias = await prisma.checkWithTaskCriterias.delete({
     *   where: {
     *     // ... filter to delete one CheckWithTaskCriterias
     *   }
     * })
     * 
    **/
    delete<T extends CheckWithTaskCriteriasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CheckWithTaskCriteriasDeleteArgs<ExtArgs>>
    ): Prisma__CheckWithTaskCriteriasClient<$Result.GetResult<Prisma.$CheckWithTaskCriteriasPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CheckWithTaskCriterias.
     * @param {CheckWithTaskCriteriasUpdateArgs} args - Arguments to update one CheckWithTaskCriterias.
     * @example
     * // Update one CheckWithTaskCriterias
     * const checkWithTaskCriterias = await prisma.checkWithTaskCriterias.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CheckWithTaskCriteriasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CheckWithTaskCriteriasUpdateArgs<ExtArgs>>
    ): Prisma__CheckWithTaskCriteriasClient<$Result.GetResult<Prisma.$CheckWithTaskCriteriasPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CheckWithTaskCriterias.
     * @param {CheckWithTaskCriteriasDeleteManyArgs} args - Arguments to filter CheckWithTaskCriterias to delete.
     * @example
     * // Delete a few CheckWithTaskCriterias
     * const { count } = await prisma.checkWithTaskCriterias.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CheckWithTaskCriteriasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CheckWithTaskCriteriasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CheckWithTaskCriterias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckWithTaskCriteriasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CheckWithTaskCriterias
     * const checkWithTaskCriterias = await prisma.checkWithTaskCriterias.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CheckWithTaskCriteriasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CheckWithTaskCriteriasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CheckWithTaskCriterias.
     * @param {CheckWithTaskCriteriasUpsertArgs} args - Arguments to update or create a CheckWithTaskCriterias.
     * @example
     * // Update or create a CheckWithTaskCriterias
     * const checkWithTaskCriterias = await prisma.checkWithTaskCriterias.upsert({
     *   create: {
     *     // ... data to create a CheckWithTaskCriterias
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CheckWithTaskCriterias we want to update
     *   }
     * })
    **/
    upsert<T extends CheckWithTaskCriteriasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CheckWithTaskCriteriasUpsertArgs<ExtArgs>>
    ): Prisma__CheckWithTaskCriteriasClient<$Result.GetResult<Prisma.$CheckWithTaskCriteriasPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CheckWithTaskCriterias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckWithTaskCriteriasCountArgs} args - Arguments to filter CheckWithTaskCriterias to count.
     * @example
     * // Count the number of CheckWithTaskCriterias
     * const count = await prisma.checkWithTaskCriterias.count({
     *   where: {
     *     // ... the filter for the CheckWithTaskCriterias we want to count
     *   }
     * })
    **/
    count<T extends CheckWithTaskCriteriasCountArgs>(
      args?: Subset<T, CheckWithTaskCriteriasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CheckWithTaskCriteriasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CheckWithTaskCriterias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckWithTaskCriteriasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CheckWithTaskCriteriasAggregateArgs>(args: Subset<T, CheckWithTaskCriteriasAggregateArgs>): Prisma.PrismaPromise<GetCheckWithTaskCriteriasAggregateType<T>>

    /**
     * Group by CheckWithTaskCriterias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckWithTaskCriteriasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CheckWithTaskCriteriasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CheckWithTaskCriteriasGroupByArgs['orderBy'] }
        : { orderBy?: CheckWithTaskCriteriasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CheckWithTaskCriteriasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCheckWithTaskCriteriasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CheckWithTaskCriterias model
   */
  readonly fields: CheckWithTaskCriteriasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CheckWithTaskCriterias.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CheckWithTaskCriteriasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    task_apply<T extends TaskApplyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskApplyDefaultArgs<ExtArgs>>): Prisma__TaskApplyClient<$Result.GetResult<Prisma.$TaskApplyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    task_criteria<T extends TaskCriteriaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskCriteriaDefaultArgs<ExtArgs>>): Prisma__TaskCriteriaClient<$Result.GetResult<Prisma.$TaskCriteriaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CheckWithTaskCriterias model
   */ 
  interface CheckWithTaskCriteriasFieldRefs {
    readonly id: FieldRef<"CheckWithTaskCriterias", 'String'>
    readonly task_applyId: FieldRef<"CheckWithTaskCriterias", 'String'>
    readonly task_criteriaId: FieldRef<"CheckWithTaskCriterias", 'String'>
    readonly criteria_score: FieldRef<"CheckWithTaskCriterias", 'Int'>
    readonly description: FieldRef<"CheckWithTaskCriterias", 'String'>
    readonly created_at: FieldRef<"CheckWithTaskCriterias", 'DateTime'>
    readonly updated_at: FieldRef<"CheckWithTaskCriterias", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * CheckWithTaskCriterias findUnique
   */
  export type CheckWithTaskCriteriasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckWithTaskCriterias
     */
    select?: CheckWithTaskCriteriasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckWithTaskCriteriasInclude<ExtArgs> | null
    /**
     * Filter, which CheckWithTaskCriterias to fetch.
     */
    where: CheckWithTaskCriteriasWhereUniqueInput
  }


  /**
   * CheckWithTaskCriterias findUniqueOrThrow
   */
  export type CheckWithTaskCriteriasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckWithTaskCriterias
     */
    select?: CheckWithTaskCriteriasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckWithTaskCriteriasInclude<ExtArgs> | null
    /**
     * Filter, which CheckWithTaskCriterias to fetch.
     */
    where: CheckWithTaskCriteriasWhereUniqueInput
  }


  /**
   * CheckWithTaskCriterias findFirst
   */
  export type CheckWithTaskCriteriasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckWithTaskCriterias
     */
    select?: CheckWithTaskCriteriasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckWithTaskCriteriasInclude<ExtArgs> | null
    /**
     * Filter, which CheckWithTaskCriterias to fetch.
     */
    where?: CheckWithTaskCriteriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckWithTaskCriterias to fetch.
     */
    orderBy?: CheckWithTaskCriteriasOrderByWithRelationInput | CheckWithTaskCriteriasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheckWithTaskCriterias.
     */
    cursor?: CheckWithTaskCriteriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckWithTaskCriterias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckWithTaskCriterias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheckWithTaskCriterias.
     */
    distinct?: CheckWithTaskCriteriasScalarFieldEnum | CheckWithTaskCriteriasScalarFieldEnum[]
  }


  /**
   * CheckWithTaskCriterias findFirstOrThrow
   */
  export type CheckWithTaskCriteriasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckWithTaskCriterias
     */
    select?: CheckWithTaskCriteriasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckWithTaskCriteriasInclude<ExtArgs> | null
    /**
     * Filter, which CheckWithTaskCriterias to fetch.
     */
    where?: CheckWithTaskCriteriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckWithTaskCriterias to fetch.
     */
    orderBy?: CheckWithTaskCriteriasOrderByWithRelationInput | CheckWithTaskCriteriasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheckWithTaskCriterias.
     */
    cursor?: CheckWithTaskCriteriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckWithTaskCriterias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckWithTaskCriterias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheckWithTaskCriterias.
     */
    distinct?: CheckWithTaskCriteriasScalarFieldEnum | CheckWithTaskCriteriasScalarFieldEnum[]
  }


  /**
   * CheckWithTaskCriterias findMany
   */
  export type CheckWithTaskCriteriasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckWithTaskCriterias
     */
    select?: CheckWithTaskCriteriasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckWithTaskCriteriasInclude<ExtArgs> | null
    /**
     * Filter, which CheckWithTaskCriterias to fetch.
     */
    where?: CheckWithTaskCriteriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckWithTaskCriterias to fetch.
     */
    orderBy?: CheckWithTaskCriteriasOrderByWithRelationInput | CheckWithTaskCriteriasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CheckWithTaskCriterias.
     */
    cursor?: CheckWithTaskCriteriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckWithTaskCriterias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckWithTaskCriterias.
     */
    skip?: number
    distinct?: CheckWithTaskCriteriasScalarFieldEnum | CheckWithTaskCriteriasScalarFieldEnum[]
  }


  /**
   * CheckWithTaskCriterias create
   */
  export type CheckWithTaskCriteriasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckWithTaskCriterias
     */
    select?: CheckWithTaskCriteriasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckWithTaskCriteriasInclude<ExtArgs> | null
    /**
     * The data needed to create a CheckWithTaskCriterias.
     */
    data: XOR<CheckWithTaskCriteriasCreateInput, CheckWithTaskCriteriasUncheckedCreateInput>
  }


  /**
   * CheckWithTaskCriterias createMany
   */
  export type CheckWithTaskCriteriasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CheckWithTaskCriterias.
     */
    data: CheckWithTaskCriteriasCreateManyInput | CheckWithTaskCriteriasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CheckWithTaskCriterias update
   */
  export type CheckWithTaskCriteriasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckWithTaskCriterias
     */
    select?: CheckWithTaskCriteriasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckWithTaskCriteriasInclude<ExtArgs> | null
    /**
     * The data needed to update a CheckWithTaskCriterias.
     */
    data: XOR<CheckWithTaskCriteriasUpdateInput, CheckWithTaskCriteriasUncheckedUpdateInput>
    /**
     * Choose, which CheckWithTaskCriterias to update.
     */
    where: CheckWithTaskCriteriasWhereUniqueInput
  }


  /**
   * CheckWithTaskCriterias updateMany
   */
  export type CheckWithTaskCriteriasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CheckWithTaskCriterias.
     */
    data: XOR<CheckWithTaskCriteriasUpdateManyMutationInput, CheckWithTaskCriteriasUncheckedUpdateManyInput>
    /**
     * Filter which CheckWithTaskCriterias to update
     */
    where?: CheckWithTaskCriteriasWhereInput
  }


  /**
   * CheckWithTaskCriterias upsert
   */
  export type CheckWithTaskCriteriasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckWithTaskCriterias
     */
    select?: CheckWithTaskCriteriasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckWithTaskCriteriasInclude<ExtArgs> | null
    /**
     * The filter to search for the CheckWithTaskCriterias to update in case it exists.
     */
    where: CheckWithTaskCriteriasWhereUniqueInput
    /**
     * In case the CheckWithTaskCriterias found by the `where` argument doesn't exist, create a new CheckWithTaskCriterias with this data.
     */
    create: XOR<CheckWithTaskCriteriasCreateInput, CheckWithTaskCriteriasUncheckedCreateInput>
    /**
     * In case the CheckWithTaskCriterias was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CheckWithTaskCriteriasUpdateInput, CheckWithTaskCriteriasUncheckedUpdateInput>
  }


  /**
   * CheckWithTaskCriterias delete
   */
  export type CheckWithTaskCriteriasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckWithTaskCriterias
     */
    select?: CheckWithTaskCriteriasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckWithTaskCriteriasInclude<ExtArgs> | null
    /**
     * Filter which CheckWithTaskCriterias to delete.
     */
    where: CheckWithTaskCriteriasWhereUniqueInput
  }


  /**
   * CheckWithTaskCriterias deleteMany
   */
  export type CheckWithTaskCriteriasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheckWithTaskCriterias to delete
     */
    where?: CheckWithTaskCriteriasWhereInput
  }


  /**
   * CheckWithTaskCriterias without action
   */
  export type CheckWithTaskCriteriasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckWithTaskCriterias
     */
    select?: CheckWithTaskCriteriasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckWithTaskCriteriasInclude<ExtArgs> | null
  }



  /**
   * Model Teacher
   */

  export type AggregateTeacher = {
    _count: TeacherCountAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  export type TeacherMinAggregateOutputType = {
    id: string | null
    first_name: string | null
    last_name: string | null
    email: string | null
    username: string | null
    hashed_password: string | null
    hashed_refresh_token: string | null
    activation_link: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TeacherMaxAggregateOutputType = {
    id: string | null
    first_name: string | null
    last_name: string | null
    email: string | null
    username: string | null
    hashed_password: string | null
    hashed_refresh_token: string | null
    activation_link: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TeacherCountAggregateOutputType = {
    id: number
    first_name: number
    last_name: number
    email: number
    username: number
    hashed_password: number
    hashed_refresh_token: number
    activation_link: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TeacherMinAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    username?: true
    hashed_password?: true
    hashed_refresh_token?: true
    activation_link?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type TeacherMaxAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    username?: true
    hashed_password?: true
    hashed_refresh_token?: true
    activation_link?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type TeacherCountAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    username?: true
    hashed_password?: true
    hashed_refresh_token?: true
    activation_link?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TeacherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teacher to aggregate.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teachers
    **/
    _count?: true | TeacherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherMaxAggregateInputType
  }

  export type GetTeacherAggregateType<T extends TeacherAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacher[P]>
      : GetScalarType<T[P], AggregateTeacher[P]>
  }




  export type TeacherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWhereInput
    orderBy?: TeacherOrderByWithAggregationInput | TeacherOrderByWithAggregationInput[]
    by: TeacherScalarFieldEnum[] | TeacherScalarFieldEnum
    having?: TeacherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherCountAggregateInputType | true
    _min?: TeacherMinAggregateInputType
    _max?: TeacherMaxAggregateInputType
  }

  export type TeacherGroupByOutputType = {
    id: string
    first_name: string
    last_name: string
    email: string
    username: string
    hashed_password: string
    hashed_refresh_token: string | null
    activation_link: string | null
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: TeacherCountAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  type GetTeacherGroupByPayload<T extends TeacherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherGroupByOutputType[P]>
        }
      >
    >


  export type TeacherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    username?: boolean
    hashed_password?: boolean
    hashed_refresh_token?: boolean
    activation_link?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    task_applys?: boolean | Teacher$task_applysArgs<ExtArgs>
    teacher_training_applys?: boolean | Teacher$teacher_training_applysArgs<ExtArgs>
    write_question_applys?: boolean | Teacher$write_question_applysArgs<ExtArgs>
    choice_answer_applys?: boolean | Teacher$choice_answer_applysArgs<ExtArgs>
    teacher_personal_info?: boolean | Teacher$teacher_personal_infoArgs<ExtArgs>
    teacher_workplace?: boolean | Teacher$teacher_workplaceArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type TeacherSelectScalar = {
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    username?: boolean
    hashed_password?: boolean
    hashed_refresh_token?: boolean
    activation_link?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TeacherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task_applys?: boolean | Teacher$task_applysArgs<ExtArgs>
    teacher_training_applys?: boolean | Teacher$teacher_training_applysArgs<ExtArgs>
    write_question_applys?: boolean | Teacher$write_question_applysArgs<ExtArgs>
    choice_answer_applys?: boolean | Teacher$choice_answer_applysArgs<ExtArgs>
    teacher_personal_info?: boolean | Teacher$teacher_personal_infoArgs<ExtArgs>
    teacher_workplace?: boolean | Teacher$teacher_workplaceArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TeacherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Teacher"
    objects: {
      task_applys: Prisma.$TaskApplyPayload<ExtArgs>[]
      teacher_training_applys: Prisma.$TrainingApplyPayload<ExtArgs>[]
      write_question_applys: Prisma.$WriteQuestionApplyPayload<ExtArgs>[]
      choice_answer_applys: Prisma.$ChoiceAnswerApplyPayload<ExtArgs>[]
      teacher_personal_info: Prisma.$TeacherPersonalInfoPayload<ExtArgs>[]
      teacher_workplace: Prisma.$TeacherWorkplacePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      first_name: string
      last_name: string
      email: string
      username: string
      hashed_password: string
      hashed_refresh_token: string | null
      activation_link: string | null
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["teacher"]>
    composites: {}
  }


  type TeacherGetPayload<S extends boolean | null | undefined | TeacherDefaultArgs> = $Result.GetResult<Prisma.$TeacherPayload, S>

  type TeacherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeacherFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: TeacherCountAggregateInputType | true
    }

  export interface TeacherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Teacher'], meta: { name: 'Teacher' } }
    /**
     * Find zero or one Teacher that matches the filter.
     * @param {TeacherFindUniqueArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeacherFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherFindUniqueArgs<ExtArgs>>
    ): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Teacher that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TeacherFindUniqueOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TeacherFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Teacher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeacherFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherFindFirstArgs<ExtArgs>>
    ): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Teacher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TeacherFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers
     * const teachers = await prisma.teacher.findMany()
     * 
     * // Get first 10 Teachers
     * const teachers = await prisma.teacher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherWithIdOnly = await prisma.teacher.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TeacherFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Teacher.
     * @param {TeacherCreateArgs} args - Arguments to create a Teacher.
     * @example
     * // Create one Teacher
     * const Teacher = await prisma.teacher.create({
     *   data: {
     *     // ... data to create a Teacher
     *   }
     * })
     * 
    **/
    create<T extends TeacherCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherCreateArgs<ExtArgs>>
    ): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Teachers.
     *     @param {TeacherCreateManyArgs} args - Arguments to create many Teachers.
     *     @example
     *     // Create many Teachers
     *     const teacher = await prisma.teacher.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeacherCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Teacher.
     * @param {TeacherDeleteArgs} args - Arguments to delete one Teacher.
     * @example
     * // Delete one Teacher
     * const Teacher = await prisma.teacher.delete({
     *   where: {
     *     // ... filter to delete one Teacher
     *   }
     * })
     * 
    **/
    delete<T extends TeacherDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherDeleteArgs<ExtArgs>>
    ): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Teacher.
     * @param {TeacherUpdateArgs} args - Arguments to update one Teacher.
     * @example
     * // Update one Teacher
     * const teacher = await prisma.teacher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeacherUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherUpdateArgs<ExtArgs>>
    ): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Teachers.
     * @param {TeacherDeleteManyArgs} args - Arguments to filter Teachers to delete.
     * @example
     * // Delete a few Teachers
     * const { count } = await prisma.teacher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeacherDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeacherUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Teacher.
     * @param {TeacherUpsertArgs} args - Arguments to update or create a Teacher.
     * @example
     * // Update or create a Teacher
     * const teacher = await prisma.teacher.upsert({
     *   create: {
     *     // ... data to create a Teacher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teacher we want to update
     *   }
     * })
    **/
    upsert<T extends TeacherUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherUpsertArgs<ExtArgs>>
    ): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherCountArgs} args - Arguments to filter Teachers to count.
     * @example
     * // Count the number of Teachers
     * const count = await prisma.teacher.count({
     *   where: {
     *     // ... the filter for the Teachers we want to count
     *   }
     * })
    **/
    count<T extends TeacherCountArgs>(
      args?: Subset<T, TeacherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherAggregateArgs>(args: Subset<T, TeacherAggregateArgs>): Prisma.PrismaPromise<GetTeacherAggregateType<T>>

    /**
     * Group by Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherGroupByArgs['orderBy'] }
        : { orderBy?: TeacherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Teacher model
   */
  readonly fields: TeacherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Teacher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    task_applys<T extends Teacher$task_applysArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$task_applysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskApplyPayload<ExtArgs>, T, 'findMany'> | Null>;

    teacher_training_applys<T extends Teacher$teacher_training_applysArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$teacher_training_applysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingApplyPayload<ExtArgs>, T, 'findMany'> | Null>;

    write_question_applys<T extends Teacher$write_question_applysArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$write_question_applysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WriteQuestionApplyPayload<ExtArgs>, T, 'findMany'> | Null>;

    choice_answer_applys<T extends Teacher$choice_answer_applysArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$choice_answer_applysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoiceAnswerApplyPayload<ExtArgs>, T, 'findMany'> | Null>;

    teacher_personal_info<T extends Teacher$teacher_personal_infoArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$teacher_personal_infoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPersonalInfoPayload<ExtArgs>, T, 'findMany'> | Null>;

    teacher_workplace<T extends Teacher$teacher_workplaceArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$teacher_workplaceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherWorkplacePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Teacher model
   */ 
  interface TeacherFieldRefs {
    readonly id: FieldRef<"Teacher", 'String'>
    readonly first_name: FieldRef<"Teacher", 'String'>
    readonly last_name: FieldRef<"Teacher", 'String'>
    readonly email: FieldRef<"Teacher", 'String'>
    readonly username: FieldRef<"Teacher", 'String'>
    readonly hashed_password: FieldRef<"Teacher", 'String'>
    readonly hashed_refresh_token: FieldRef<"Teacher", 'String'>
    readonly activation_link: FieldRef<"Teacher", 'String'>
    readonly is_active: FieldRef<"Teacher", 'Boolean'>
    readonly created_at: FieldRef<"Teacher", 'DateTime'>
    readonly updated_at: FieldRef<"Teacher", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Teacher findUnique
   */
  export type TeacherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }


  /**
   * Teacher findUniqueOrThrow
   */
  export type TeacherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }


  /**
   * Teacher findFirst
   */
  export type TeacherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }


  /**
   * Teacher findFirstOrThrow
   */
  export type TeacherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }


  /**
   * Teacher findMany
   */
  export type TeacherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }


  /**
   * Teacher create
   */
  export type TeacherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to create a Teacher.
     */
    data: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
  }


  /**
   * Teacher createMany
   */
  export type TeacherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teachers.
     */
    data: TeacherCreateManyInput | TeacherCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Teacher update
   */
  export type TeacherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to update a Teacher.
     */
    data: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
    /**
     * Choose, which Teacher to update.
     */
    where: TeacherWhereUniqueInput
  }


  /**
   * Teacher updateMany
   */
  export type TeacherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeacherWhereInput
  }


  /**
   * Teacher upsert
   */
  export type TeacherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The filter to search for the Teacher to update in case it exists.
     */
    where: TeacherWhereUniqueInput
    /**
     * In case the Teacher found by the `where` argument doesn't exist, create a new Teacher with this data.
     */
    create: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
    /**
     * In case the Teacher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
  }


  /**
   * Teacher delete
   */
  export type TeacherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter which Teacher to delete.
     */
    where: TeacherWhereUniqueInput
  }


  /**
   * Teacher deleteMany
   */
  export type TeacherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teachers to delete
     */
    where?: TeacherWhereInput
  }


  /**
   * Teacher.task_applys
   */
  export type Teacher$task_applysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskApply
     */
    select?: TaskApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TaskApplyInclude<ExtArgs> | null
    where?: TaskApplyWhereInput
    orderBy?: TaskApplyOrderByWithRelationInput | TaskApplyOrderByWithRelationInput[]
    cursor?: TaskApplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskApplyScalarFieldEnum | TaskApplyScalarFieldEnum[]
  }


  /**
   * Teacher.teacher_training_applys
   */
  export type Teacher$teacher_training_applysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingApply
     */
    select?: TrainingApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingApplyInclude<ExtArgs> | null
    where?: TrainingApplyWhereInput
    orderBy?: TrainingApplyOrderByWithRelationInput | TrainingApplyOrderByWithRelationInput[]
    cursor?: TrainingApplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingApplyScalarFieldEnum | TrainingApplyScalarFieldEnum[]
  }


  /**
   * Teacher.write_question_applys
   */
  export type Teacher$write_question_applysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WriteQuestionApply
     */
    select?: WriteQuestionApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WriteQuestionApplyInclude<ExtArgs> | null
    where?: WriteQuestionApplyWhereInput
    orderBy?: WriteQuestionApplyOrderByWithRelationInput | WriteQuestionApplyOrderByWithRelationInput[]
    cursor?: WriteQuestionApplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WriteQuestionApplyScalarFieldEnum | WriteQuestionApplyScalarFieldEnum[]
  }


  /**
   * Teacher.choice_answer_applys
   */
  export type Teacher$choice_answer_applysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoiceAnswerApply
     */
    select?: ChoiceAnswerApplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoiceAnswerApplyInclude<ExtArgs> | null
    where?: ChoiceAnswerApplyWhereInput
    orderBy?: ChoiceAnswerApplyOrderByWithRelationInput | ChoiceAnswerApplyOrderByWithRelationInput[]
    cursor?: ChoiceAnswerApplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChoiceAnswerApplyScalarFieldEnum | ChoiceAnswerApplyScalarFieldEnum[]
  }


  /**
   * Teacher.teacher_personal_info
   */
  export type Teacher$teacher_personal_infoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherPersonalInfo
     */
    select?: TeacherPersonalInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherPersonalInfoInclude<ExtArgs> | null
    where?: TeacherPersonalInfoWhereInput
    orderBy?: TeacherPersonalInfoOrderByWithRelationInput | TeacherPersonalInfoOrderByWithRelationInput[]
    cursor?: TeacherPersonalInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherPersonalInfoScalarFieldEnum | TeacherPersonalInfoScalarFieldEnum[]
  }


  /**
   * Teacher.teacher_workplace
   */
  export type Teacher$teacher_workplaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkplace
     */
    select?: TeacherWorkplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherWorkplaceInclude<ExtArgs> | null
    where?: TeacherWorkplaceWhereInput
    orderBy?: TeacherWorkplaceOrderByWithRelationInput | TeacherWorkplaceOrderByWithRelationInput[]
    cursor?: TeacherWorkplaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherWorkplaceScalarFieldEnum | TeacherWorkplaceScalarFieldEnum[]
  }


  /**
   * Teacher without action
   */
  export type TeacherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude<ExtArgs> | null
  }



  /**
   * Model TeacherPersonalInfo
   */

  export type AggregateTeacherPersonalInfo = {
    _count: TeacherPersonalInfoCountAggregateOutputType | null
    _min: TeacherPersonalInfoMinAggregateOutputType | null
    _max: TeacherPersonalInfoMaxAggregateOutputType | null
  }

  export type TeacherPersonalInfoMinAggregateOutputType = {
    id: string | null
    teacherId: string | null
    nationality: string | null
    gender: string | null
    birthDate: string | null
    passport_serial: string | null
    is_active: boolean | null
    photo: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TeacherPersonalInfoMaxAggregateOutputType = {
    id: string | null
    teacherId: string | null
    nationality: string | null
    gender: string | null
    birthDate: string | null
    passport_serial: string | null
    is_active: boolean | null
    photo: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TeacherPersonalInfoCountAggregateOutputType = {
    id: number
    teacherId: number
    nationality: number
    gender: number
    birthDate: number
    passport_serial: number
    is_active: number
    photo: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TeacherPersonalInfoMinAggregateInputType = {
    id?: true
    teacherId?: true
    nationality?: true
    gender?: true
    birthDate?: true
    passport_serial?: true
    is_active?: true
    photo?: true
    created_at?: true
    updated_at?: true
  }

  export type TeacherPersonalInfoMaxAggregateInputType = {
    id?: true
    teacherId?: true
    nationality?: true
    gender?: true
    birthDate?: true
    passport_serial?: true
    is_active?: true
    photo?: true
    created_at?: true
    updated_at?: true
  }

  export type TeacherPersonalInfoCountAggregateInputType = {
    id?: true
    teacherId?: true
    nationality?: true
    gender?: true
    birthDate?: true
    passport_serial?: true
    is_active?: true
    photo?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TeacherPersonalInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherPersonalInfo to aggregate.
     */
    where?: TeacherPersonalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherPersonalInfos to fetch.
     */
    orderBy?: TeacherPersonalInfoOrderByWithRelationInput | TeacherPersonalInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherPersonalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherPersonalInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherPersonalInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherPersonalInfos
    **/
    _count?: true | TeacherPersonalInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherPersonalInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherPersonalInfoMaxAggregateInputType
  }

  export type GetTeacherPersonalInfoAggregateType<T extends TeacherPersonalInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherPersonalInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherPersonalInfo[P]>
      : GetScalarType<T[P], AggregateTeacherPersonalInfo[P]>
  }




  export type TeacherPersonalInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherPersonalInfoWhereInput
    orderBy?: TeacherPersonalInfoOrderByWithAggregationInput | TeacherPersonalInfoOrderByWithAggregationInput[]
    by: TeacherPersonalInfoScalarFieldEnum[] | TeacherPersonalInfoScalarFieldEnum
    having?: TeacherPersonalInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherPersonalInfoCountAggregateInputType | true
    _min?: TeacherPersonalInfoMinAggregateInputType
    _max?: TeacherPersonalInfoMaxAggregateInputType
  }

  export type TeacherPersonalInfoGroupByOutputType = {
    id: string
    teacherId: string
    nationality: string | null
    gender: string | null
    birthDate: string | null
    passport_serial: string | null
    is_active: boolean
    photo: string | null
    created_at: Date
    updated_at: Date
    _count: TeacherPersonalInfoCountAggregateOutputType | null
    _min: TeacherPersonalInfoMinAggregateOutputType | null
    _max: TeacherPersonalInfoMaxAggregateOutputType | null
  }

  type GetTeacherPersonalInfoGroupByPayload<T extends TeacherPersonalInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherPersonalInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherPersonalInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherPersonalInfoGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherPersonalInfoGroupByOutputType[P]>
        }
      >
    >


  export type TeacherPersonalInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    nationality?: boolean
    gender?: boolean
    birthDate?: boolean
    passport_serial?: boolean
    is_active?: boolean
    photo?: boolean
    created_at?: boolean
    updated_at?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherPersonalInfo"]>

  export type TeacherPersonalInfoSelectScalar = {
    id?: boolean
    teacherId?: boolean
    nationality?: boolean
    gender?: boolean
    birthDate?: boolean
    passport_serial?: boolean
    is_active?: boolean
    photo?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TeacherPersonalInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }


  export type $TeacherPersonalInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeacherPersonalInfo"
    objects: {
      teacher: Prisma.$TeacherPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teacherId: string
      nationality: string | null
      gender: string | null
      birthDate: string | null
      passport_serial: string | null
      is_active: boolean
      photo: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["teacherPersonalInfo"]>
    composites: {}
  }


  type TeacherPersonalInfoGetPayload<S extends boolean | null | undefined | TeacherPersonalInfoDefaultArgs> = $Result.GetResult<Prisma.$TeacherPersonalInfoPayload, S>

  type TeacherPersonalInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeacherPersonalInfoFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: TeacherPersonalInfoCountAggregateInputType | true
    }

  export interface TeacherPersonalInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeacherPersonalInfo'], meta: { name: 'TeacherPersonalInfo' } }
    /**
     * Find zero or one TeacherPersonalInfo that matches the filter.
     * @param {TeacherPersonalInfoFindUniqueArgs} args - Arguments to find a TeacherPersonalInfo
     * @example
     * // Get one TeacherPersonalInfo
     * const teacherPersonalInfo = await prisma.teacherPersonalInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeacherPersonalInfoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherPersonalInfoFindUniqueArgs<ExtArgs>>
    ): Prisma__TeacherPersonalInfoClient<$Result.GetResult<Prisma.$TeacherPersonalInfoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TeacherPersonalInfo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TeacherPersonalInfoFindUniqueOrThrowArgs} args - Arguments to find a TeacherPersonalInfo
     * @example
     * // Get one TeacherPersonalInfo
     * const teacherPersonalInfo = await prisma.teacherPersonalInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TeacherPersonalInfoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherPersonalInfoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TeacherPersonalInfoClient<$Result.GetResult<Prisma.$TeacherPersonalInfoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TeacherPersonalInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherPersonalInfoFindFirstArgs} args - Arguments to find a TeacherPersonalInfo
     * @example
     * // Get one TeacherPersonalInfo
     * const teacherPersonalInfo = await prisma.teacherPersonalInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeacherPersonalInfoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherPersonalInfoFindFirstArgs<ExtArgs>>
    ): Prisma__TeacherPersonalInfoClient<$Result.GetResult<Prisma.$TeacherPersonalInfoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TeacherPersonalInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherPersonalInfoFindFirstOrThrowArgs} args - Arguments to find a TeacherPersonalInfo
     * @example
     * // Get one TeacherPersonalInfo
     * const teacherPersonalInfo = await prisma.teacherPersonalInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TeacherPersonalInfoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherPersonalInfoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TeacherPersonalInfoClient<$Result.GetResult<Prisma.$TeacherPersonalInfoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TeacherPersonalInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherPersonalInfoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherPersonalInfos
     * const teacherPersonalInfos = await prisma.teacherPersonalInfo.findMany()
     * 
     * // Get first 10 TeacherPersonalInfos
     * const teacherPersonalInfos = await prisma.teacherPersonalInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherPersonalInfoWithIdOnly = await prisma.teacherPersonalInfo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TeacherPersonalInfoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherPersonalInfoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPersonalInfoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TeacherPersonalInfo.
     * @param {TeacherPersonalInfoCreateArgs} args - Arguments to create a TeacherPersonalInfo.
     * @example
     * // Create one TeacherPersonalInfo
     * const TeacherPersonalInfo = await prisma.teacherPersonalInfo.create({
     *   data: {
     *     // ... data to create a TeacherPersonalInfo
     *   }
     * })
     * 
    **/
    create<T extends TeacherPersonalInfoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherPersonalInfoCreateArgs<ExtArgs>>
    ): Prisma__TeacherPersonalInfoClient<$Result.GetResult<Prisma.$TeacherPersonalInfoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TeacherPersonalInfos.
     *     @param {TeacherPersonalInfoCreateManyArgs} args - Arguments to create many TeacherPersonalInfos.
     *     @example
     *     // Create many TeacherPersonalInfos
     *     const teacherPersonalInfo = await prisma.teacherPersonalInfo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeacherPersonalInfoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherPersonalInfoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TeacherPersonalInfo.
     * @param {TeacherPersonalInfoDeleteArgs} args - Arguments to delete one TeacherPersonalInfo.
     * @example
     * // Delete one TeacherPersonalInfo
     * const TeacherPersonalInfo = await prisma.teacherPersonalInfo.delete({
     *   where: {
     *     // ... filter to delete one TeacherPersonalInfo
     *   }
     * })
     * 
    **/
    delete<T extends TeacherPersonalInfoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherPersonalInfoDeleteArgs<ExtArgs>>
    ): Prisma__TeacherPersonalInfoClient<$Result.GetResult<Prisma.$TeacherPersonalInfoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TeacherPersonalInfo.
     * @param {TeacherPersonalInfoUpdateArgs} args - Arguments to update one TeacherPersonalInfo.
     * @example
     * // Update one TeacherPersonalInfo
     * const teacherPersonalInfo = await prisma.teacherPersonalInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeacherPersonalInfoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherPersonalInfoUpdateArgs<ExtArgs>>
    ): Prisma__TeacherPersonalInfoClient<$Result.GetResult<Prisma.$TeacherPersonalInfoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TeacherPersonalInfos.
     * @param {TeacherPersonalInfoDeleteManyArgs} args - Arguments to filter TeacherPersonalInfos to delete.
     * @example
     * // Delete a few TeacherPersonalInfos
     * const { count } = await prisma.teacherPersonalInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeacherPersonalInfoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherPersonalInfoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherPersonalInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherPersonalInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherPersonalInfos
     * const teacherPersonalInfo = await prisma.teacherPersonalInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeacherPersonalInfoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherPersonalInfoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeacherPersonalInfo.
     * @param {TeacherPersonalInfoUpsertArgs} args - Arguments to update or create a TeacherPersonalInfo.
     * @example
     * // Update or create a TeacherPersonalInfo
     * const teacherPersonalInfo = await prisma.teacherPersonalInfo.upsert({
     *   create: {
     *     // ... data to create a TeacherPersonalInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherPersonalInfo we want to update
     *   }
     * })
    **/
    upsert<T extends TeacherPersonalInfoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherPersonalInfoUpsertArgs<ExtArgs>>
    ): Prisma__TeacherPersonalInfoClient<$Result.GetResult<Prisma.$TeacherPersonalInfoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TeacherPersonalInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherPersonalInfoCountArgs} args - Arguments to filter TeacherPersonalInfos to count.
     * @example
     * // Count the number of TeacherPersonalInfos
     * const count = await prisma.teacherPersonalInfo.count({
     *   where: {
     *     // ... the filter for the TeacherPersonalInfos we want to count
     *   }
     * })
    **/
    count<T extends TeacherPersonalInfoCountArgs>(
      args?: Subset<T, TeacherPersonalInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherPersonalInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherPersonalInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherPersonalInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherPersonalInfoAggregateArgs>(args: Subset<T, TeacherPersonalInfoAggregateArgs>): Prisma.PrismaPromise<GetTeacherPersonalInfoAggregateType<T>>

    /**
     * Group by TeacherPersonalInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherPersonalInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherPersonalInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherPersonalInfoGroupByArgs['orderBy'] }
        : { orderBy?: TeacherPersonalInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherPersonalInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherPersonalInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeacherPersonalInfo model
   */
  readonly fields: TeacherPersonalInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherPersonalInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherPersonalInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TeacherPersonalInfo model
   */ 
  interface TeacherPersonalInfoFieldRefs {
    readonly id: FieldRef<"TeacherPersonalInfo", 'String'>
    readonly teacherId: FieldRef<"TeacherPersonalInfo", 'String'>
    readonly nationality: FieldRef<"TeacherPersonalInfo", 'String'>
    readonly gender: FieldRef<"TeacherPersonalInfo", 'String'>
    readonly birthDate: FieldRef<"TeacherPersonalInfo", 'String'>
    readonly passport_serial: FieldRef<"TeacherPersonalInfo", 'String'>
    readonly is_active: FieldRef<"TeacherPersonalInfo", 'Boolean'>
    readonly photo: FieldRef<"TeacherPersonalInfo", 'String'>
    readonly created_at: FieldRef<"TeacherPersonalInfo", 'DateTime'>
    readonly updated_at: FieldRef<"TeacherPersonalInfo", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * TeacherPersonalInfo findUnique
   */
  export type TeacherPersonalInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherPersonalInfo
     */
    select?: TeacherPersonalInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherPersonalInfoInclude<ExtArgs> | null
    /**
     * Filter, which TeacherPersonalInfo to fetch.
     */
    where: TeacherPersonalInfoWhereUniqueInput
  }


  /**
   * TeacherPersonalInfo findUniqueOrThrow
   */
  export type TeacherPersonalInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherPersonalInfo
     */
    select?: TeacherPersonalInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherPersonalInfoInclude<ExtArgs> | null
    /**
     * Filter, which TeacherPersonalInfo to fetch.
     */
    where: TeacherPersonalInfoWhereUniqueInput
  }


  /**
   * TeacherPersonalInfo findFirst
   */
  export type TeacherPersonalInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherPersonalInfo
     */
    select?: TeacherPersonalInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherPersonalInfoInclude<ExtArgs> | null
    /**
     * Filter, which TeacherPersonalInfo to fetch.
     */
    where?: TeacherPersonalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherPersonalInfos to fetch.
     */
    orderBy?: TeacherPersonalInfoOrderByWithRelationInput | TeacherPersonalInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherPersonalInfos.
     */
    cursor?: TeacherPersonalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherPersonalInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherPersonalInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherPersonalInfos.
     */
    distinct?: TeacherPersonalInfoScalarFieldEnum | TeacherPersonalInfoScalarFieldEnum[]
  }


  /**
   * TeacherPersonalInfo findFirstOrThrow
   */
  export type TeacherPersonalInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherPersonalInfo
     */
    select?: TeacherPersonalInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherPersonalInfoInclude<ExtArgs> | null
    /**
     * Filter, which TeacherPersonalInfo to fetch.
     */
    where?: TeacherPersonalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherPersonalInfos to fetch.
     */
    orderBy?: TeacherPersonalInfoOrderByWithRelationInput | TeacherPersonalInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherPersonalInfos.
     */
    cursor?: TeacherPersonalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherPersonalInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherPersonalInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherPersonalInfos.
     */
    distinct?: TeacherPersonalInfoScalarFieldEnum | TeacherPersonalInfoScalarFieldEnum[]
  }


  /**
   * TeacherPersonalInfo findMany
   */
  export type TeacherPersonalInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherPersonalInfo
     */
    select?: TeacherPersonalInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherPersonalInfoInclude<ExtArgs> | null
    /**
     * Filter, which TeacherPersonalInfos to fetch.
     */
    where?: TeacherPersonalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherPersonalInfos to fetch.
     */
    orderBy?: TeacherPersonalInfoOrderByWithRelationInput | TeacherPersonalInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherPersonalInfos.
     */
    cursor?: TeacherPersonalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherPersonalInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherPersonalInfos.
     */
    skip?: number
    distinct?: TeacherPersonalInfoScalarFieldEnum | TeacherPersonalInfoScalarFieldEnum[]
  }


  /**
   * TeacherPersonalInfo create
   */
  export type TeacherPersonalInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherPersonalInfo
     */
    select?: TeacherPersonalInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherPersonalInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a TeacherPersonalInfo.
     */
    data: XOR<TeacherPersonalInfoCreateInput, TeacherPersonalInfoUncheckedCreateInput>
  }


  /**
   * TeacherPersonalInfo createMany
   */
  export type TeacherPersonalInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeacherPersonalInfos.
     */
    data: TeacherPersonalInfoCreateManyInput | TeacherPersonalInfoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TeacherPersonalInfo update
   */
  export type TeacherPersonalInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherPersonalInfo
     */
    select?: TeacherPersonalInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherPersonalInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a TeacherPersonalInfo.
     */
    data: XOR<TeacherPersonalInfoUpdateInput, TeacherPersonalInfoUncheckedUpdateInput>
    /**
     * Choose, which TeacherPersonalInfo to update.
     */
    where: TeacherPersonalInfoWhereUniqueInput
  }


  /**
   * TeacherPersonalInfo updateMany
   */
  export type TeacherPersonalInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeacherPersonalInfos.
     */
    data: XOR<TeacherPersonalInfoUpdateManyMutationInput, TeacherPersonalInfoUncheckedUpdateManyInput>
    /**
     * Filter which TeacherPersonalInfos to update
     */
    where?: TeacherPersonalInfoWhereInput
  }


  /**
   * TeacherPersonalInfo upsert
   */
  export type TeacherPersonalInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherPersonalInfo
     */
    select?: TeacherPersonalInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherPersonalInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the TeacherPersonalInfo to update in case it exists.
     */
    where: TeacherPersonalInfoWhereUniqueInput
    /**
     * In case the TeacherPersonalInfo found by the `where` argument doesn't exist, create a new TeacherPersonalInfo with this data.
     */
    create: XOR<TeacherPersonalInfoCreateInput, TeacherPersonalInfoUncheckedCreateInput>
    /**
     * In case the TeacherPersonalInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherPersonalInfoUpdateInput, TeacherPersonalInfoUncheckedUpdateInput>
  }


  /**
   * TeacherPersonalInfo delete
   */
  export type TeacherPersonalInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherPersonalInfo
     */
    select?: TeacherPersonalInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherPersonalInfoInclude<ExtArgs> | null
    /**
     * Filter which TeacherPersonalInfo to delete.
     */
    where: TeacherPersonalInfoWhereUniqueInput
  }


  /**
   * TeacherPersonalInfo deleteMany
   */
  export type TeacherPersonalInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherPersonalInfos to delete
     */
    where?: TeacherPersonalInfoWhereInput
  }


  /**
   * TeacherPersonalInfo without action
   */
  export type TeacherPersonalInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherPersonalInfo
     */
    select?: TeacherPersonalInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherPersonalInfoInclude<ExtArgs> | null
  }



  /**
   * Model TeacherWorkplace
   */

  export type AggregateTeacherWorkplace = {
    _count: TeacherWorkplaceCountAggregateOutputType | null
    _min: TeacherWorkplaceMinAggregateOutputType | null
    _max: TeacherWorkplaceMaxAggregateOutputType | null
  }

  export type TeacherWorkplaceMinAggregateOutputType = {
    id: string | null
    position: string | null
    teacherId: string | null
    schoolId: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TeacherWorkplaceMaxAggregateOutputType = {
    id: string | null
    position: string | null
    teacherId: string | null
    schoolId: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TeacherWorkplaceCountAggregateOutputType = {
    id: number
    position: number
    teacherId: number
    schoolId: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TeacherWorkplaceMinAggregateInputType = {
    id?: true
    position?: true
    teacherId?: true
    schoolId?: true
    created_at?: true
    updated_at?: true
  }

  export type TeacherWorkplaceMaxAggregateInputType = {
    id?: true
    position?: true
    teacherId?: true
    schoolId?: true
    created_at?: true
    updated_at?: true
  }

  export type TeacherWorkplaceCountAggregateInputType = {
    id?: true
    position?: true
    teacherId?: true
    schoolId?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TeacherWorkplaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherWorkplace to aggregate.
     */
    where?: TeacherWorkplaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherWorkplaces to fetch.
     */
    orderBy?: TeacherWorkplaceOrderByWithRelationInput | TeacherWorkplaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherWorkplaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherWorkplaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherWorkplaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherWorkplaces
    **/
    _count?: true | TeacherWorkplaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherWorkplaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherWorkplaceMaxAggregateInputType
  }

  export type GetTeacherWorkplaceAggregateType<T extends TeacherWorkplaceAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherWorkplace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherWorkplace[P]>
      : GetScalarType<T[P], AggregateTeacherWorkplace[P]>
  }




  export type TeacherWorkplaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWorkplaceWhereInput
    orderBy?: TeacherWorkplaceOrderByWithAggregationInput | TeacherWorkplaceOrderByWithAggregationInput[]
    by: TeacherWorkplaceScalarFieldEnum[] | TeacherWorkplaceScalarFieldEnum
    having?: TeacherWorkplaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherWorkplaceCountAggregateInputType | true
    _min?: TeacherWorkplaceMinAggregateInputType
    _max?: TeacherWorkplaceMaxAggregateInputType
  }

  export type TeacherWorkplaceGroupByOutputType = {
    id: string
    position: string
    teacherId: string
    schoolId: string
    created_at: Date
    updated_at: Date
    _count: TeacherWorkplaceCountAggregateOutputType | null
    _min: TeacherWorkplaceMinAggregateOutputType | null
    _max: TeacherWorkplaceMaxAggregateOutputType | null
  }

  type GetTeacherWorkplaceGroupByPayload<T extends TeacherWorkplaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherWorkplaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherWorkplaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherWorkplaceGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherWorkplaceGroupByOutputType[P]>
        }
      >
    >


  export type TeacherWorkplaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    position?: boolean
    teacherId?: boolean
    schoolId?: boolean
    created_at?: boolean
    updated_at?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherWorkplace"]>

  export type TeacherWorkplaceSelectScalar = {
    id?: boolean
    position?: boolean
    teacherId?: boolean
    schoolId?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TeacherWorkplaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }


  export type $TeacherWorkplacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeacherWorkplace"
    objects: {
      teacher: Prisma.$TeacherPayload<ExtArgs>
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      position: string
      teacherId: string
      schoolId: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["teacherWorkplace"]>
    composites: {}
  }


  type TeacherWorkplaceGetPayload<S extends boolean | null | undefined | TeacherWorkplaceDefaultArgs> = $Result.GetResult<Prisma.$TeacherWorkplacePayload, S>

  type TeacherWorkplaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeacherWorkplaceFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: TeacherWorkplaceCountAggregateInputType | true
    }

  export interface TeacherWorkplaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeacherWorkplace'], meta: { name: 'TeacherWorkplace' } }
    /**
     * Find zero or one TeacherWorkplace that matches the filter.
     * @param {TeacherWorkplaceFindUniqueArgs} args - Arguments to find a TeacherWorkplace
     * @example
     * // Get one TeacherWorkplace
     * const teacherWorkplace = await prisma.teacherWorkplace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeacherWorkplaceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherWorkplaceFindUniqueArgs<ExtArgs>>
    ): Prisma__TeacherWorkplaceClient<$Result.GetResult<Prisma.$TeacherWorkplacePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TeacherWorkplace that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TeacherWorkplaceFindUniqueOrThrowArgs} args - Arguments to find a TeacherWorkplace
     * @example
     * // Get one TeacherWorkplace
     * const teacherWorkplace = await prisma.teacherWorkplace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TeacherWorkplaceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherWorkplaceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TeacherWorkplaceClient<$Result.GetResult<Prisma.$TeacherWorkplacePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TeacherWorkplace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherWorkplaceFindFirstArgs} args - Arguments to find a TeacherWorkplace
     * @example
     * // Get one TeacherWorkplace
     * const teacherWorkplace = await prisma.teacherWorkplace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeacherWorkplaceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherWorkplaceFindFirstArgs<ExtArgs>>
    ): Prisma__TeacherWorkplaceClient<$Result.GetResult<Prisma.$TeacherWorkplacePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TeacherWorkplace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherWorkplaceFindFirstOrThrowArgs} args - Arguments to find a TeacherWorkplace
     * @example
     * // Get one TeacherWorkplace
     * const teacherWorkplace = await prisma.teacherWorkplace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TeacherWorkplaceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherWorkplaceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TeacherWorkplaceClient<$Result.GetResult<Prisma.$TeacherWorkplacePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TeacherWorkplaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherWorkplaceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherWorkplaces
     * const teacherWorkplaces = await prisma.teacherWorkplace.findMany()
     * 
     * // Get first 10 TeacherWorkplaces
     * const teacherWorkplaces = await prisma.teacherWorkplace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherWorkplaceWithIdOnly = await prisma.teacherWorkplace.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TeacherWorkplaceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherWorkplaceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherWorkplacePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TeacherWorkplace.
     * @param {TeacherWorkplaceCreateArgs} args - Arguments to create a TeacherWorkplace.
     * @example
     * // Create one TeacherWorkplace
     * const TeacherWorkplace = await prisma.teacherWorkplace.create({
     *   data: {
     *     // ... data to create a TeacherWorkplace
     *   }
     * })
     * 
    **/
    create<T extends TeacherWorkplaceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherWorkplaceCreateArgs<ExtArgs>>
    ): Prisma__TeacherWorkplaceClient<$Result.GetResult<Prisma.$TeacherWorkplacePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TeacherWorkplaces.
     *     @param {TeacherWorkplaceCreateManyArgs} args - Arguments to create many TeacherWorkplaces.
     *     @example
     *     // Create many TeacherWorkplaces
     *     const teacherWorkplace = await prisma.teacherWorkplace.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeacherWorkplaceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherWorkplaceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TeacherWorkplace.
     * @param {TeacherWorkplaceDeleteArgs} args - Arguments to delete one TeacherWorkplace.
     * @example
     * // Delete one TeacherWorkplace
     * const TeacherWorkplace = await prisma.teacherWorkplace.delete({
     *   where: {
     *     // ... filter to delete one TeacherWorkplace
     *   }
     * })
     * 
    **/
    delete<T extends TeacherWorkplaceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherWorkplaceDeleteArgs<ExtArgs>>
    ): Prisma__TeacherWorkplaceClient<$Result.GetResult<Prisma.$TeacherWorkplacePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TeacherWorkplace.
     * @param {TeacherWorkplaceUpdateArgs} args - Arguments to update one TeacherWorkplace.
     * @example
     * // Update one TeacherWorkplace
     * const teacherWorkplace = await prisma.teacherWorkplace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeacherWorkplaceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherWorkplaceUpdateArgs<ExtArgs>>
    ): Prisma__TeacherWorkplaceClient<$Result.GetResult<Prisma.$TeacherWorkplacePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TeacherWorkplaces.
     * @param {TeacherWorkplaceDeleteManyArgs} args - Arguments to filter TeacherWorkplaces to delete.
     * @example
     * // Delete a few TeacherWorkplaces
     * const { count } = await prisma.teacherWorkplace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeacherWorkplaceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherWorkplaceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherWorkplaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherWorkplaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherWorkplaces
     * const teacherWorkplace = await prisma.teacherWorkplace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeacherWorkplaceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherWorkplaceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeacherWorkplace.
     * @param {TeacherWorkplaceUpsertArgs} args - Arguments to update or create a TeacherWorkplace.
     * @example
     * // Update or create a TeacherWorkplace
     * const teacherWorkplace = await prisma.teacherWorkplace.upsert({
     *   create: {
     *     // ... data to create a TeacherWorkplace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherWorkplace we want to update
     *   }
     * })
    **/
    upsert<T extends TeacherWorkplaceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherWorkplaceUpsertArgs<ExtArgs>>
    ): Prisma__TeacherWorkplaceClient<$Result.GetResult<Prisma.$TeacherWorkplacePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TeacherWorkplaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherWorkplaceCountArgs} args - Arguments to filter TeacherWorkplaces to count.
     * @example
     * // Count the number of TeacherWorkplaces
     * const count = await prisma.teacherWorkplace.count({
     *   where: {
     *     // ... the filter for the TeacherWorkplaces we want to count
     *   }
     * })
    **/
    count<T extends TeacherWorkplaceCountArgs>(
      args?: Subset<T, TeacherWorkplaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherWorkplaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherWorkplace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherWorkplaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherWorkplaceAggregateArgs>(args: Subset<T, TeacherWorkplaceAggregateArgs>): Prisma.PrismaPromise<GetTeacherWorkplaceAggregateType<T>>

    /**
     * Group by TeacherWorkplace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherWorkplaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherWorkplaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherWorkplaceGroupByArgs['orderBy'] }
        : { orderBy?: TeacherWorkplaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherWorkplaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherWorkplaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeacherWorkplace model
   */
  readonly fields: TeacherWorkplaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherWorkplace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherWorkplaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TeacherWorkplace model
   */ 
  interface TeacherWorkplaceFieldRefs {
    readonly id: FieldRef<"TeacherWorkplace", 'String'>
    readonly position: FieldRef<"TeacherWorkplace", 'String'>
    readonly teacherId: FieldRef<"TeacherWorkplace", 'String'>
    readonly schoolId: FieldRef<"TeacherWorkplace", 'String'>
    readonly created_at: FieldRef<"TeacherWorkplace", 'DateTime'>
    readonly updated_at: FieldRef<"TeacherWorkplace", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * TeacherWorkplace findUnique
   */
  export type TeacherWorkplaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkplace
     */
    select?: TeacherWorkplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherWorkplaceInclude<ExtArgs> | null
    /**
     * Filter, which TeacherWorkplace to fetch.
     */
    where: TeacherWorkplaceWhereUniqueInput
  }


  /**
   * TeacherWorkplace findUniqueOrThrow
   */
  export type TeacherWorkplaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkplace
     */
    select?: TeacherWorkplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherWorkplaceInclude<ExtArgs> | null
    /**
     * Filter, which TeacherWorkplace to fetch.
     */
    where: TeacherWorkplaceWhereUniqueInput
  }


  /**
   * TeacherWorkplace findFirst
   */
  export type TeacherWorkplaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkplace
     */
    select?: TeacherWorkplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherWorkplaceInclude<ExtArgs> | null
    /**
     * Filter, which TeacherWorkplace to fetch.
     */
    where?: TeacherWorkplaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherWorkplaces to fetch.
     */
    orderBy?: TeacherWorkplaceOrderByWithRelationInput | TeacherWorkplaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherWorkplaces.
     */
    cursor?: TeacherWorkplaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherWorkplaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherWorkplaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherWorkplaces.
     */
    distinct?: TeacherWorkplaceScalarFieldEnum | TeacherWorkplaceScalarFieldEnum[]
  }


  /**
   * TeacherWorkplace findFirstOrThrow
   */
  export type TeacherWorkplaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkplace
     */
    select?: TeacherWorkplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherWorkplaceInclude<ExtArgs> | null
    /**
     * Filter, which TeacherWorkplace to fetch.
     */
    where?: TeacherWorkplaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherWorkplaces to fetch.
     */
    orderBy?: TeacherWorkplaceOrderByWithRelationInput | TeacherWorkplaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherWorkplaces.
     */
    cursor?: TeacherWorkplaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherWorkplaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherWorkplaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherWorkplaces.
     */
    distinct?: TeacherWorkplaceScalarFieldEnum | TeacherWorkplaceScalarFieldEnum[]
  }


  /**
   * TeacherWorkplace findMany
   */
  export type TeacherWorkplaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkplace
     */
    select?: TeacherWorkplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherWorkplaceInclude<ExtArgs> | null
    /**
     * Filter, which TeacherWorkplaces to fetch.
     */
    where?: TeacherWorkplaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherWorkplaces to fetch.
     */
    orderBy?: TeacherWorkplaceOrderByWithRelationInput | TeacherWorkplaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherWorkplaces.
     */
    cursor?: TeacherWorkplaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherWorkplaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherWorkplaces.
     */
    skip?: number
    distinct?: TeacherWorkplaceScalarFieldEnum | TeacherWorkplaceScalarFieldEnum[]
  }


  /**
   * TeacherWorkplace create
   */
  export type TeacherWorkplaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkplace
     */
    select?: TeacherWorkplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherWorkplaceInclude<ExtArgs> | null
    /**
     * The data needed to create a TeacherWorkplace.
     */
    data: XOR<TeacherWorkplaceCreateInput, TeacherWorkplaceUncheckedCreateInput>
  }


  /**
   * TeacherWorkplace createMany
   */
  export type TeacherWorkplaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeacherWorkplaces.
     */
    data: TeacherWorkplaceCreateManyInput | TeacherWorkplaceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TeacherWorkplace update
   */
  export type TeacherWorkplaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkplace
     */
    select?: TeacherWorkplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherWorkplaceInclude<ExtArgs> | null
    /**
     * The data needed to update a TeacherWorkplace.
     */
    data: XOR<TeacherWorkplaceUpdateInput, TeacherWorkplaceUncheckedUpdateInput>
    /**
     * Choose, which TeacherWorkplace to update.
     */
    where: TeacherWorkplaceWhereUniqueInput
  }


  /**
   * TeacherWorkplace updateMany
   */
  export type TeacherWorkplaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeacherWorkplaces.
     */
    data: XOR<TeacherWorkplaceUpdateManyMutationInput, TeacherWorkplaceUncheckedUpdateManyInput>
    /**
     * Filter which TeacherWorkplaces to update
     */
    where?: TeacherWorkplaceWhereInput
  }


  /**
   * TeacherWorkplace upsert
   */
  export type TeacherWorkplaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkplace
     */
    select?: TeacherWorkplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherWorkplaceInclude<ExtArgs> | null
    /**
     * The filter to search for the TeacherWorkplace to update in case it exists.
     */
    where: TeacherWorkplaceWhereUniqueInput
    /**
     * In case the TeacherWorkplace found by the `where` argument doesn't exist, create a new TeacherWorkplace with this data.
     */
    create: XOR<TeacherWorkplaceCreateInput, TeacherWorkplaceUncheckedCreateInput>
    /**
     * In case the TeacherWorkplace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherWorkplaceUpdateInput, TeacherWorkplaceUncheckedUpdateInput>
  }


  /**
   * TeacherWorkplace delete
   */
  export type TeacherWorkplaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkplace
     */
    select?: TeacherWorkplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherWorkplaceInclude<ExtArgs> | null
    /**
     * Filter which TeacherWorkplace to delete.
     */
    where: TeacherWorkplaceWhereUniqueInput
  }


  /**
   * TeacherWorkplace deleteMany
   */
  export type TeacherWorkplaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherWorkplaces to delete
     */
    where?: TeacherWorkplaceWhereInput
  }


  /**
   * TeacherWorkplace without action
   */
  export type TeacherWorkplaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherWorkplace
     */
    select?: TeacherWorkplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherWorkplaceInclude<ExtArgs> | null
  }



  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    first_name: string | null
    last_name: string | null
    email: string | null
    username: string | null
    hashed_password: string | null
    hashed_refresh_token: string | null
    activation_link: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    first_name: string | null
    last_name: string | null
    email: string | null
    username: string | null
    hashed_password: string | null
    hashed_refresh_token: string | null
    activation_link: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    first_name: number
    last_name: number
    email: number
    username: number
    hashed_password: number
    hashed_refresh_token: number
    activation_link: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    username?: true
    hashed_password?: true
    hashed_refresh_token?: true
    activation_link?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    username?: true
    hashed_password?: true
    hashed_refresh_token?: true
    activation_link?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    username?: true
    hashed_password?: true
    hashed_refresh_token?: true
    activation_link?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    first_name: string
    last_name: string
    email: string
    username: string
    hashed_password: string
    hashed_refresh_token: string | null
    activation_link: string | null
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    username?: boolean
    hashed_password?: boolean
    hashed_refresh_token?: boolean
    activation_link?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    username?: boolean
    hashed_password?: boolean
    hashed_refresh_token?: boolean
    activation_link?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      first_name: string
      last_name: string
      email: string
      username: string
      hashed_password: string
      hashed_refresh_token: string | null
      activation_link: string | null
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }


  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Admin that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdminFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
    **/
    create<T extends AdminCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminCreateArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Admins.
     *     @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     *     @example
     *     // Create many Admins
     *     const admin = await prisma.admin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdminCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
    **/
    delete<T extends AdminDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
    **/
    upsert<T extends AdminUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Admin model
   */ 
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly first_name: FieldRef<"Admin", 'String'>
    readonly last_name: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly username: FieldRef<"Admin", 'String'>
    readonly hashed_password: FieldRef<"Admin", 'String'>
    readonly hashed_refresh_token: FieldRef<"Admin", 'String'>
    readonly activation_link: FieldRef<"Admin", 'String'>
    readonly is_active: FieldRef<"Admin", 'Boolean'>
    readonly created_at: FieldRef<"Admin", 'DateTime'>
    readonly updated_at: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }


  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }


  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }


  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }


  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
  }


  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }


  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
  }


  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SchoolScalarFieldEnum: {
    id: 'id',
    name: 'name',
    region_id: 'region_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SchoolScalarFieldEnum = (typeof SchoolScalarFieldEnum)[keyof typeof SchoolScalarFieldEnum]


  export const RegionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type RegionScalarFieldEnum = (typeof RegionScalarFieldEnum)[keyof typeof RegionScalarFieldEnum]


  export const ChoiceQuestionScalarFieldEnum: {
    id: 'id',
    text: 'text',
    description: 'description',
    correct_choice: 'correct_choice',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ChoiceQuestionScalarFieldEnum = (typeof ChoiceQuestionScalarFieldEnum)[keyof typeof ChoiceQuestionScalarFieldEnum]


  export const ChoiceAnswerScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    key: 'key',
    value: 'value',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ChoiceAnswerScalarFieldEnum = (typeof ChoiceAnswerScalarFieldEnum)[keyof typeof ChoiceAnswerScalarFieldEnum]


  export const ChoiceAnswerApplyScalarFieldEnum: {
    id: 'id',
    teacherId: 'teacherId',
    answerId: 'answerId',
    key: 'key',
    is_correct: 'is_correct',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ChoiceAnswerApplyScalarFieldEnum = (typeof ChoiceAnswerApplyScalarFieldEnum)[keyof typeof ChoiceAnswerApplyScalarFieldEnum]


  export const WriteQuestionScalarFieldEnum: {
    id: 'id',
    text: 'text',
    correct_answer: 'correct_answer',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type WriteQuestionScalarFieldEnum = (typeof WriteQuestionScalarFieldEnum)[keyof typeof WriteQuestionScalarFieldEnum]


  export const WriteQuestionApplyScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    teacherId: 'teacherId',
    value: 'value',
    is_correct: 'is_correct',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type WriteQuestionApplyScalarFieldEnum = (typeof WriteQuestionApplyScalarFieldEnum)[keyof typeof WriteQuestionApplyScalarFieldEnum]


  export const TrainingScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    subject: 'subject',
    max_score: 'max_score',
    pass_score: 'pass_score',
    file: 'file',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TrainingScalarFieldEnum = (typeof TrainingScalarFieldEnum)[keyof typeof TrainingScalarFieldEnum]


  export const TrainingApplyScalarFieldEnum: {
    id: 'id',
    trainingId: 'trainingId',
    teacherId: 'teacherId',
    text: 'text',
    file: 'file',
    is_seen: 'is_seen',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TrainingApplyScalarFieldEnum = (typeof TrainingApplyScalarFieldEnum)[keyof typeof TrainingApplyScalarFieldEnum]


  export const CheckTrainingApplyScalarFieldEnum: {
    id: 'id',
    training_applyId: 'training_applyId',
    description: 'description',
    score: 'score',
    is_active: 'is_active',
    is_seen: 'is_seen',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CheckTrainingApplyScalarFieldEnum = (typeof CheckTrainingApplyScalarFieldEnum)[keyof typeof CheckTrainingApplyScalarFieldEnum]


  export const LessonScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    file: 'file',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type LessonScalarFieldEnum = (typeof LessonScalarFieldEnum)[keyof typeof LessonScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    file: 'file',
    score: 'score',
    is_active: 'is_active',
    lessonId: 'lessonId',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const TaskCriteriaScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    description: 'description',
    taskId: 'taskId',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TaskCriteriaScalarFieldEnum = (typeof TaskCriteriaScalarFieldEnum)[keyof typeof TaskCriteriaScalarFieldEnum]


  export const TaskApplyScalarFieldEnum: {
    id: 'id',
    teacherId: 'teacherId',
    taskId: 'taskId',
    overall_score: 'overall_score',
    description: 'description',
    file: 'file',
    is_active: 'is_active',
    is_seen: 'is_seen',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TaskApplyScalarFieldEnum = (typeof TaskApplyScalarFieldEnum)[keyof typeof TaskApplyScalarFieldEnum]


  export const CheckWithTaskCriteriasScalarFieldEnum: {
    id: 'id',
    task_applyId: 'task_applyId',
    task_criteriaId: 'task_criteriaId',
    criteria_score: 'criteria_score',
    description: 'description',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CheckWithTaskCriteriasScalarFieldEnum = (typeof CheckWithTaskCriteriasScalarFieldEnum)[keyof typeof CheckWithTaskCriteriasScalarFieldEnum]


  export const TeacherScalarFieldEnum: {
    id: 'id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    username: 'username',
    hashed_password: 'hashed_password',
    hashed_refresh_token: 'hashed_refresh_token',
    activation_link: 'activation_link',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TeacherScalarFieldEnum = (typeof TeacherScalarFieldEnum)[keyof typeof TeacherScalarFieldEnum]


  export const TeacherPersonalInfoScalarFieldEnum: {
    id: 'id',
    teacherId: 'teacherId',
    nationality: 'nationality',
    gender: 'gender',
    birthDate: 'birthDate',
    passport_serial: 'passport_serial',
    is_active: 'is_active',
    photo: 'photo',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TeacherPersonalInfoScalarFieldEnum = (typeof TeacherPersonalInfoScalarFieldEnum)[keyof typeof TeacherPersonalInfoScalarFieldEnum]


  export const TeacherWorkplaceScalarFieldEnum: {
    id: 'id',
    position: 'position',
    teacherId: 'teacherId',
    schoolId: 'schoolId',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TeacherWorkplaceScalarFieldEnum = (typeof TeacherWorkplaceScalarFieldEnum)[keyof typeof TeacherWorkplaceScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    username: 'username',
    hashed_password: 'hashed_password',
    hashed_refresh_token: 'hashed_refresh_token',
    activation_link: 'activation_link',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type SchoolWhereInput = {
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    id?: StringFilter<"School"> | string
    name?: StringFilter<"School"> | string
    region_id?: StringFilter<"School"> | string
    created_at?: DateTimeFilter<"School"> | Date | string
    updated_at?: DateTimeFilter<"School"> | Date | string
    region?: XOR<RegionRelationFilter, RegionWhereInput>
    teachers_workplaces?: TeacherWorkplaceListRelationFilter
  }

  export type SchoolOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    region_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    region?: RegionOrderByWithRelationInput
    teachers_workplaces?: TeacherWorkplaceOrderByRelationAggregateInput
  }

  export type SchoolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    region_id?: StringFilter<"School"> | string
    created_at?: DateTimeFilter<"School"> | Date | string
    updated_at?: DateTimeFilter<"School"> | Date | string
    region?: XOR<RegionRelationFilter, RegionWhereInput>
    teachers_workplaces?: TeacherWorkplaceListRelationFilter
  }, "id" | "name">

  export type SchoolOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    region_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SchoolCountOrderByAggregateInput
    _max?: SchoolMaxOrderByAggregateInput
    _min?: SchoolMinOrderByAggregateInput
  }

  export type SchoolScalarWhereWithAggregatesInput = {
    AND?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    OR?: SchoolScalarWhereWithAggregatesInput[]
    NOT?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"School"> | string
    name?: StringWithAggregatesFilter<"School"> | string
    region_id?: StringWithAggregatesFilter<"School"> | string
    created_at?: DateTimeWithAggregatesFilter<"School"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"School"> | Date | string
  }

  export type RegionWhereInput = {
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    id?: StringFilter<"Region"> | string
    name?: StringFilter<"Region"> | string
    created_at?: DateTimeFilter<"Region"> | Date | string
    updated_at?: DateTimeFilter<"Region"> | Date | string
    schools?: SchoolListRelationFilter
  }

  export type RegionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    schools?: SchoolOrderByRelationAggregateInput
  }

  export type RegionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    created_at?: DateTimeFilter<"Region"> | Date | string
    updated_at?: DateTimeFilter<"Region"> | Date | string
    schools?: SchoolListRelationFilter
  }, "id" | "name">

  export type RegionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: RegionCountOrderByAggregateInput
    _max?: RegionMaxOrderByAggregateInput
    _min?: RegionMinOrderByAggregateInput
  }

  export type RegionScalarWhereWithAggregatesInput = {
    AND?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    OR?: RegionScalarWhereWithAggregatesInput[]
    NOT?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Region"> | string
    name?: StringWithAggregatesFilter<"Region"> | string
    created_at?: DateTimeWithAggregatesFilter<"Region"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Region"> | Date | string
  }

  export type ChoiceQuestionWhereInput = {
    AND?: ChoiceQuestionWhereInput | ChoiceQuestionWhereInput[]
    OR?: ChoiceQuestionWhereInput[]
    NOT?: ChoiceQuestionWhereInput | ChoiceQuestionWhereInput[]
    id?: StringFilter<"ChoiceQuestion"> | string
    text?: StringFilter<"ChoiceQuestion"> | string
    description?: StringNullableFilter<"ChoiceQuestion"> | string | null
    correct_choice?: StringFilter<"ChoiceQuestion"> | string
    created_at?: DateTimeFilter<"ChoiceQuestion"> | Date | string
    updated_at?: DateTimeFilter<"ChoiceQuestion"> | Date | string
    answers?: ChoiceAnswerListRelationFilter
  }

  export type ChoiceQuestionOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    description?: SortOrderInput | SortOrder
    correct_choice?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    answers?: ChoiceAnswerOrderByRelationAggregateInput
  }

  export type ChoiceQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChoiceQuestionWhereInput | ChoiceQuestionWhereInput[]
    OR?: ChoiceQuestionWhereInput[]
    NOT?: ChoiceQuestionWhereInput | ChoiceQuestionWhereInput[]
    text?: StringFilter<"ChoiceQuestion"> | string
    description?: StringNullableFilter<"ChoiceQuestion"> | string | null
    correct_choice?: StringFilter<"ChoiceQuestion"> | string
    created_at?: DateTimeFilter<"ChoiceQuestion"> | Date | string
    updated_at?: DateTimeFilter<"ChoiceQuestion"> | Date | string
    answers?: ChoiceAnswerListRelationFilter
  }, "id">

  export type ChoiceQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    description?: SortOrderInput | SortOrder
    correct_choice?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ChoiceQuestionCountOrderByAggregateInput
    _max?: ChoiceQuestionMaxOrderByAggregateInput
    _min?: ChoiceQuestionMinOrderByAggregateInput
  }

  export type ChoiceQuestionScalarWhereWithAggregatesInput = {
    AND?: ChoiceQuestionScalarWhereWithAggregatesInput | ChoiceQuestionScalarWhereWithAggregatesInput[]
    OR?: ChoiceQuestionScalarWhereWithAggregatesInput[]
    NOT?: ChoiceQuestionScalarWhereWithAggregatesInput | ChoiceQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChoiceQuestion"> | string
    text?: StringWithAggregatesFilter<"ChoiceQuestion"> | string
    description?: StringNullableWithAggregatesFilter<"ChoiceQuestion"> | string | null
    correct_choice?: StringWithAggregatesFilter<"ChoiceQuestion"> | string
    created_at?: DateTimeWithAggregatesFilter<"ChoiceQuestion"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ChoiceQuestion"> | Date | string
  }

  export type ChoiceAnswerWhereInput = {
    AND?: ChoiceAnswerWhereInput | ChoiceAnswerWhereInput[]
    OR?: ChoiceAnswerWhereInput[]
    NOT?: ChoiceAnswerWhereInput | ChoiceAnswerWhereInput[]
    id?: StringFilter<"ChoiceAnswer"> | string
    questionId?: StringFilter<"ChoiceAnswer"> | string
    key?: StringFilter<"ChoiceAnswer"> | string
    value?: StringFilter<"ChoiceAnswer"> | string
    created_at?: DateTimeFilter<"ChoiceAnswer"> | Date | string
    updated_at?: DateTimeFilter<"ChoiceAnswer"> | Date | string
    question?: XOR<ChoiceQuestionRelationFilter, ChoiceQuestionWhereInput>
    choice_answer_applys?: ChoiceAnswerApplyListRelationFilter
  }

  export type ChoiceAnswerOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    question?: ChoiceQuestionOrderByWithRelationInput
    choice_answer_applys?: ChoiceAnswerApplyOrderByRelationAggregateInput
  }

  export type ChoiceAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChoiceAnswerWhereInput | ChoiceAnswerWhereInput[]
    OR?: ChoiceAnswerWhereInput[]
    NOT?: ChoiceAnswerWhereInput | ChoiceAnswerWhereInput[]
    questionId?: StringFilter<"ChoiceAnswer"> | string
    key?: StringFilter<"ChoiceAnswer"> | string
    value?: StringFilter<"ChoiceAnswer"> | string
    created_at?: DateTimeFilter<"ChoiceAnswer"> | Date | string
    updated_at?: DateTimeFilter<"ChoiceAnswer"> | Date | string
    question?: XOR<ChoiceQuestionRelationFilter, ChoiceQuestionWhereInput>
    choice_answer_applys?: ChoiceAnswerApplyListRelationFilter
  }, "id">

  export type ChoiceAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ChoiceAnswerCountOrderByAggregateInput
    _max?: ChoiceAnswerMaxOrderByAggregateInput
    _min?: ChoiceAnswerMinOrderByAggregateInput
  }

  export type ChoiceAnswerScalarWhereWithAggregatesInput = {
    AND?: ChoiceAnswerScalarWhereWithAggregatesInput | ChoiceAnswerScalarWhereWithAggregatesInput[]
    OR?: ChoiceAnswerScalarWhereWithAggregatesInput[]
    NOT?: ChoiceAnswerScalarWhereWithAggregatesInput | ChoiceAnswerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChoiceAnswer"> | string
    questionId?: StringWithAggregatesFilter<"ChoiceAnswer"> | string
    key?: StringWithAggregatesFilter<"ChoiceAnswer"> | string
    value?: StringWithAggregatesFilter<"ChoiceAnswer"> | string
    created_at?: DateTimeWithAggregatesFilter<"ChoiceAnswer"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ChoiceAnswer"> | Date | string
  }

  export type ChoiceAnswerApplyWhereInput = {
    AND?: ChoiceAnswerApplyWhereInput | ChoiceAnswerApplyWhereInput[]
    OR?: ChoiceAnswerApplyWhereInput[]
    NOT?: ChoiceAnswerApplyWhereInput | ChoiceAnswerApplyWhereInput[]
    id?: StringFilter<"ChoiceAnswerApply"> | string
    teacherId?: StringFilter<"ChoiceAnswerApply"> | string
    answerId?: StringFilter<"ChoiceAnswerApply"> | string
    key?: StringFilter<"ChoiceAnswerApply"> | string
    is_correct?: BoolNullableFilter<"ChoiceAnswerApply"> | boolean | null
    created_at?: DateTimeFilter<"ChoiceAnswerApply"> | Date | string
    updated_at?: DateTimeFilter<"ChoiceAnswerApply"> | Date | string
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
    answer?: XOR<ChoiceAnswerRelationFilter, ChoiceAnswerWhereInput>
  }

  export type ChoiceAnswerApplyOrderByWithRelationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    answerId?: SortOrder
    key?: SortOrder
    is_correct?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    teacher?: TeacherOrderByWithRelationInput
    answer?: ChoiceAnswerOrderByWithRelationInput
  }

  export type ChoiceAnswerApplyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChoiceAnswerApplyWhereInput | ChoiceAnswerApplyWhereInput[]
    OR?: ChoiceAnswerApplyWhereInput[]
    NOT?: ChoiceAnswerApplyWhereInput | ChoiceAnswerApplyWhereInput[]
    teacherId?: StringFilter<"ChoiceAnswerApply"> | string
    answerId?: StringFilter<"ChoiceAnswerApply"> | string
    key?: StringFilter<"ChoiceAnswerApply"> | string
    is_correct?: BoolNullableFilter<"ChoiceAnswerApply"> | boolean | null
    created_at?: DateTimeFilter<"ChoiceAnswerApply"> | Date | string
    updated_at?: DateTimeFilter<"ChoiceAnswerApply"> | Date | string
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
    answer?: XOR<ChoiceAnswerRelationFilter, ChoiceAnswerWhereInput>
  }, "id">

  export type ChoiceAnswerApplyOrderByWithAggregationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    answerId?: SortOrder
    key?: SortOrder
    is_correct?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ChoiceAnswerApplyCountOrderByAggregateInput
    _max?: ChoiceAnswerApplyMaxOrderByAggregateInput
    _min?: ChoiceAnswerApplyMinOrderByAggregateInput
  }

  export type ChoiceAnswerApplyScalarWhereWithAggregatesInput = {
    AND?: ChoiceAnswerApplyScalarWhereWithAggregatesInput | ChoiceAnswerApplyScalarWhereWithAggregatesInput[]
    OR?: ChoiceAnswerApplyScalarWhereWithAggregatesInput[]
    NOT?: ChoiceAnswerApplyScalarWhereWithAggregatesInput | ChoiceAnswerApplyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChoiceAnswerApply"> | string
    teacherId?: StringWithAggregatesFilter<"ChoiceAnswerApply"> | string
    answerId?: StringWithAggregatesFilter<"ChoiceAnswerApply"> | string
    key?: StringWithAggregatesFilter<"ChoiceAnswerApply"> | string
    is_correct?: BoolNullableWithAggregatesFilter<"ChoiceAnswerApply"> | boolean | null
    created_at?: DateTimeWithAggregatesFilter<"ChoiceAnswerApply"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ChoiceAnswerApply"> | Date | string
  }

  export type WriteQuestionWhereInput = {
    AND?: WriteQuestionWhereInput | WriteQuestionWhereInput[]
    OR?: WriteQuestionWhereInput[]
    NOT?: WriteQuestionWhereInput | WriteQuestionWhereInput[]
    id?: StringFilter<"WriteQuestion"> | string
    text?: StringFilter<"WriteQuestion"> | string
    correct_answer?: StringFilter<"WriteQuestion"> | string
    is_active?: BoolFilter<"WriteQuestion"> | boolean
    created_at?: DateTimeFilter<"WriteQuestion"> | Date | string
    updated_at?: DateTimeFilter<"WriteQuestion"> | Date | string
    question_applys?: WriteQuestionApplyListRelationFilter
  }

  export type WriteQuestionOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    correct_answer?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    question_applys?: WriteQuestionApplyOrderByRelationAggregateInput
  }

  export type WriteQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WriteQuestionWhereInput | WriteQuestionWhereInput[]
    OR?: WriteQuestionWhereInput[]
    NOT?: WriteQuestionWhereInput | WriteQuestionWhereInput[]
    text?: StringFilter<"WriteQuestion"> | string
    correct_answer?: StringFilter<"WriteQuestion"> | string
    is_active?: BoolFilter<"WriteQuestion"> | boolean
    created_at?: DateTimeFilter<"WriteQuestion"> | Date | string
    updated_at?: DateTimeFilter<"WriteQuestion"> | Date | string
    question_applys?: WriteQuestionApplyListRelationFilter
  }, "id">

  export type WriteQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    correct_answer?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: WriteQuestionCountOrderByAggregateInput
    _max?: WriteQuestionMaxOrderByAggregateInput
    _min?: WriteQuestionMinOrderByAggregateInput
  }

  export type WriteQuestionScalarWhereWithAggregatesInput = {
    AND?: WriteQuestionScalarWhereWithAggregatesInput | WriteQuestionScalarWhereWithAggregatesInput[]
    OR?: WriteQuestionScalarWhereWithAggregatesInput[]
    NOT?: WriteQuestionScalarWhereWithAggregatesInput | WriteQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WriteQuestion"> | string
    text?: StringWithAggregatesFilter<"WriteQuestion"> | string
    correct_answer?: StringWithAggregatesFilter<"WriteQuestion"> | string
    is_active?: BoolWithAggregatesFilter<"WriteQuestion"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"WriteQuestion"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"WriteQuestion"> | Date | string
  }

  export type WriteQuestionApplyWhereInput = {
    AND?: WriteQuestionApplyWhereInput | WriteQuestionApplyWhereInput[]
    OR?: WriteQuestionApplyWhereInput[]
    NOT?: WriteQuestionApplyWhereInput | WriteQuestionApplyWhereInput[]
    id?: StringFilter<"WriteQuestionApply"> | string
    questionId?: StringFilter<"WriteQuestionApply"> | string
    teacherId?: StringFilter<"WriteQuestionApply"> | string
    value?: StringFilter<"WriteQuestionApply"> | string
    is_correct?: BoolNullableFilter<"WriteQuestionApply"> | boolean | null
    created_at?: DateTimeFilter<"WriteQuestionApply"> | Date | string
    updated_at?: DateTimeFilter<"WriteQuestionApply"> | Date | string
    question?: XOR<WriteQuestionRelationFilter, WriteQuestionWhereInput>
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
  }

  export type WriteQuestionApplyOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    teacherId?: SortOrder
    value?: SortOrder
    is_correct?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    question?: WriteQuestionOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
  }

  export type WriteQuestionApplyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WriteQuestionApplyWhereInput | WriteQuestionApplyWhereInput[]
    OR?: WriteQuestionApplyWhereInput[]
    NOT?: WriteQuestionApplyWhereInput | WriteQuestionApplyWhereInput[]
    questionId?: StringFilter<"WriteQuestionApply"> | string
    teacherId?: StringFilter<"WriteQuestionApply"> | string
    value?: StringFilter<"WriteQuestionApply"> | string
    is_correct?: BoolNullableFilter<"WriteQuestionApply"> | boolean | null
    created_at?: DateTimeFilter<"WriteQuestionApply"> | Date | string
    updated_at?: DateTimeFilter<"WriteQuestionApply"> | Date | string
    question?: XOR<WriteQuestionRelationFilter, WriteQuestionWhereInput>
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
  }, "id">

  export type WriteQuestionApplyOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    teacherId?: SortOrder
    value?: SortOrder
    is_correct?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: WriteQuestionApplyCountOrderByAggregateInput
    _max?: WriteQuestionApplyMaxOrderByAggregateInput
    _min?: WriteQuestionApplyMinOrderByAggregateInput
  }

  export type WriteQuestionApplyScalarWhereWithAggregatesInput = {
    AND?: WriteQuestionApplyScalarWhereWithAggregatesInput | WriteQuestionApplyScalarWhereWithAggregatesInput[]
    OR?: WriteQuestionApplyScalarWhereWithAggregatesInput[]
    NOT?: WriteQuestionApplyScalarWhereWithAggregatesInput | WriteQuestionApplyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WriteQuestionApply"> | string
    questionId?: StringWithAggregatesFilter<"WriteQuestionApply"> | string
    teacherId?: StringWithAggregatesFilter<"WriteQuestionApply"> | string
    value?: StringWithAggregatesFilter<"WriteQuestionApply"> | string
    is_correct?: BoolNullableWithAggregatesFilter<"WriteQuestionApply"> | boolean | null
    created_at?: DateTimeWithAggregatesFilter<"WriteQuestionApply"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"WriteQuestionApply"> | Date | string
  }

  export type TrainingWhereInput = {
    AND?: TrainingWhereInput | TrainingWhereInput[]
    OR?: TrainingWhereInput[]
    NOT?: TrainingWhereInput | TrainingWhereInput[]
    id?: StringFilter<"Training"> | string
    title?: StringFilter<"Training"> | string
    description?: StringNullableFilter<"Training"> | string | null
    subject?: StringNullableFilter<"Training"> | string | null
    max_score?: IntNullableFilter<"Training"> | number | null
    pass_score?: IntNullableFilter<"Training"> | number | null
    file?: StringNullableFilter<"Training"> | string | null
    is_active?: BoolNullableFilter<"Training"> | boolean | null
    created_at?: DateTimeFilter<"Training"> | Date | string
    updated_at?: DateTimeFilter<"Training"> | Date | string
    training_applys?: TrainingApplyListRelationFilter
  }

  export type TrainingOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    max_score?: SortOrderInput | SortOrder
    pass_score?: SortOrderInput | SortOrder
    file?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    training_applys?: TrainingApplyOrderByRelationAggregateInput
  }

  export type TrainingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingWhereInput | TrainingWhereInput[]
    OR?: TrainingWhereInput[]
    NOT?: TrainingWhereInput | TrainingWhereInput[]
    title?: StringFilter<"Training"> | string
    description?: StringNullableFilter<"Training"> | string | null
    subject?: StringNullableFilter<"Training"> | string | null
    max_score?: IntNullableFilter<"Training"> | number | null
    pass_score?: IntNullableFilter<"Training"> | number | null
    file?: StringNullableFilter<"Training"> | string | null
    is_active?: BoolNullableFilter<"Training"> | boolean | null
    created_at?: DateTimeFilter<"Training"> | Date | string
    updated_at?: DateTimeFilter<"Training"> | Date | string
    training_applys?: TrainingApplyListRelationFilter
  }, "id">

  export type TrainingOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    max_score?: SortOrderInput | SortOrder
    pass_score?: SortOrderInput | SortOrder
    file?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TrainingCountOrderByAggregateInput
    _avg?: TrainingAvgOrderByAggregateInput
    _max?: TrainingMaxOrderByAggregateInput
    _min?: TrainingMinOrderByAggregateInput
    _sum?: TrainingSumOrderByAggregateInput
  }

  export type TrainingScalarWhereWithAggregatesInput = {
    AND?: TrainingScalarWhereWithAggregatesInput | TrainingScalarWhereWithAggregatesInput[]
    OR?: TrainingScalarWhereWithAggregatesInput[]
    NOT?: TrainingScalarWhereWithAggregatesInput | TrainingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Training"> | string
    title?: StringWithAggregatesFilter<"Training"> | string
    description?: StringNullableWithAggregatesFilter<"Training"> | string | null
    subject?: StringNullableWithAggregatesFilter<"Training"> | string | null
    max_score?: IntNullableWithAggregatesFilter<"Training"> | number | null
    pass_score?: IntNullableWithAggregatesFilter<"Training"> | number | null
    file?: StringNullableWithAggregatesFilter<"Training"> | string | null
    is_active?: BoolNullableWithAggregatesFilter<"Training"> | boolean | null
    created_at?: DateTimeWithAggregatesFilter<"Training"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Training"> | Date | string
  }

  export type TrainingApplyWhereInput = {
    AND?: TrainingApplyWhereInput | TrainingApplyWhereInput[]
    OR?: TrainingApplyWhereInput[]
    NOT?: TrainingApplyWhereInput | TrainingApplyWhereInput[]
    id?: StringFilter<"TrainingApply"> | string
    trainingId?: StringFilter<"TrainingApply"> | string
    teacherId?: StringFilter<"TrainingApply"> | string
    text?: StringNullableFilter<"TrainingApply"> | string | null
    file?: StringNullableFilter<"TrainingApply"> | string | null
    is_seen?: BoolNullableFilter<"TrainingApply"> | boolean | null
    created_at?: DateTimeFilter<"TrainingApply"> | Date | string
    updated_at?: DateTimeFilter<"TrainingApply"> | Date | string
    train?: XOR<TrainingRelationFilter, TrainingWhereInput>
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
    checking_applys?: CheckTrainingApplyListRelationFilter
  }

  export type TrainingApplyOrderByWithRelationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    teacherId?: SortOrder
    text?: SortOrderInput | SortOrder
    file?: SortOrderInput | SortOrder
    is_seen?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    train?: TrainingOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
    checking_applys?: CheckTrainingApplyOrderByRelationAggregateInput
  }

  export type TrainingApplyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingApplyWhereInput | TrainingApplyWhereInput[]
    OR?: TrainingApplyWhereInput[]
    NOT?: TrainingApplyWhereInput | TrainingApplyWhereInput[]
    trainingId?: StringFilter<"TrainingApply"> | string
    teacherId?: StringFilter<"TrainingApply"> | string
    text?: StringNullableFilter<"TrainingApply"> | string | null
    file?: StringNullableFilter<"TrainingApply"> | string | null
    is_seen?: BoolNullableFilter<"TrainingApply"> | boolean | null
    created_at?: DateTimeFilter<"TrainingApply"> | Date | string
    updated_at?: DateTimeFilter<"TrainingApply"> | Date | string
    train?: XOR<TrainingRelationFilter, TrainingWhereInput>
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
    checking_applys?: CheckTrainingApplyListRelationFilter
  }, "id">

  export type TrainingApplyOrderByWithAggregationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    teacherId?: SortOrder
    text?: SortOrderInput | SortOrder
    file?: SortOrderInput | SortOrder
    is_seen?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TrainingApplyCountOrderByAggregateInput
    _max?: TrainingApplyMaxOrderByAggregateInput
    _min?: TrainingApplyMinOrderByAggregateInput
  }

  export type TrainingApplyScalarWhereWithAggregatesInput = {
    AND?: TrainingApplyScalarWhereWithAggregatesInput | TrainingApplyScalarWhereWithAggregatesInput[]
    OR?: TrainingApplyScalarWhereWithAggregatesInput[]
    NOT?: TrainingApplyScalarWhereWithAggregatesInput | TrainingApplyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingApply"> | string
    trainingId?: StringWithAggregatesFilter<"TrainingApply"> | string
    teacherId?: StringWithAggregatesFilter<"TrainingApply"> | string
    text?: StringNullableWithAggregatesFilter<"TrainingApply"> | string | null
    file?: StringNullableWithAggregatesFilter<"TrainingApply"> | string | null
    is_seen?: BoolNullableWithAggregatesFilter<"TrainingApply"> | boolean | null
    created_at?: DateTimeWithAggregatesFilter<"TrainingApply"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"TrainingApply"> | Date | string
  }

  export type CheckTrainingApplyWhereInput = {
    AND?: CheckTrainingApplyWhereInput | CheckTrainingApplyWhereInput[]
    OR?: CheckTrainingApplyWhereInput[]
    NOT?: CheckTrainingApplyWhereInput | CheckTrainingApplyWhereInput[]
    id?: StringFilter<"CheckTrainingApply"> | string
    training_applyId?: StringFilter<"CheckTrainingApply"> | string
    description?: StringNullableFilter<"CheckTrainingApply"> | string | null
    score?: IntFilter<"CheckTrainingApply"> | number
    is_active?: BoolNullableFilter<"CheckTrainingApply"> | boolean | null
    is_seen?: BoolNullableFilter<"CheckTrainingApply"> | boolean | null
    created_at?: DateTimeFilter<"CheckTrainingApply"> | Date | string
    updated_at?: DateTimeFilter<"CheckTrainingApply"> | Date | string
    training_apply?: XOR<TrainingApplyRelationFilter, TrainingApplyWhereInput>
  }

  export type CheckTrainingApplyOrderByWithRelationInput = {
    id?: SortOrder
    training_applyId?: SortOrder
    description?: SortOrderInput | SortOrder
    score?: SortOrder
    is_active?: SortOrderInput | SortOrder
    is_seen?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    training_apply?: TrainingApplyOrderByWithRelationInput
  }

  export type CheckTrainingApplyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CheckTrainingApplyWhereInput | CheckTrainingApplyWhereInput[]
    OR?: CheckTrainingApplyWhereInput[]
    NOT?: CheckTrainingApplyWhereInput | CheckTrainingApplyWhereInput[]
    training_applyId?: StringFilter<"CheckTrainingApply"> | string
    description?: StringNullableFilter<"CheckTrainingApply"> | string | null
    score?: IntFilter<"CheckTrainingApply"> | number
    is_active?: BoolNullableFilter<"CheckTrainingApply"> | boolean | null
    is_seen?: BoolNullableFilter<"CheckTrainingApply"> | boolean | null
    created_at?: DateTimeFilter<"CheckTrainingApply"> | Date | string
    updated_at?: DateTimeFilter<"CheckTrainingApply"> | Date | string
    training_apply?: XOR<TrainingApplyRelationFilter, TrainingApplyWhereInput>
  }, "id">

  export type CheckTrainingApplyOrderByWithAggregationInput = {
    id?: SortOrder
    training_applyId?: SortOrder
    description?: SortOrderInput | SortOrder
    score?: SortOrder
    is_active?: SortOrderInput | SortOrder
    is_seen?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CheckTrainingApplyCountOrderByAggregateInput
    _avg?: CheckTrainingApplyAvgOrderByAggregateInput
    _max?: CheckTrainingApplyMaxOrderByAggregateInput
    _min?: CheckTrainingApplyMinOrderByAggregateInput
    _sum?: CheckTrainingApplySumOrderByAggregateInput
  }

  export type CheckTrainingApplyScalarWhereWithAggregatesInput = {
    AND?: CheckTrainingApplyScalarWhereWithAggregatesInput | CheckTrainingApplyScalarWhereWithAggregatesInput[]
    OR?: CheckTrainingApplyScalarWhereWithAggregatesInput[]
    NOT?: CheckTrainingApplyScalarWhereWithAggregatesInput | CheckTrainingApplyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CheckTrainingApply"> | string
    training_applyId?: StringWithAggregatesFilter<"CheckTrainingApply"> | string
    description?: StringNullableWithAggregatesFilter<"CheckTrainingApply"> | string | null
    score?: IntWithAggregatesFilter<"CheckTrainingApply"> | number
    is_active?: BoolNullableWithAggregatesFilter<"CheckTrainingApply"> | boolean | null
    is_seen?: BoolNullableWithAggregatesFilter<"CheckTrainingApply"> | boolean | null
    created_at?: DateTimeWithAggregatesFilter<"CheckTrainingApply"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"CheckTrainingApply"> | Date | string
  }

  export type LessonWhereInput = {
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    id?: StringFilter<"Lesson"> | string
    title?: StringFilter<"Lesson"> | string
    description?: StringNullableFilter<"Lesson"> | string | null
    file?: StringNullableFilter<"Lesson"> | string | null
    is_active?: BoolNullableFilter<"Lesson"> | boolean | null
    created_at?: DateTimeFilter<"Lesson"> | Date | string
    updated_at?: DateTimeFilter<"Lesson"> | Date | string
    tasks?: TaskListRelationFilter
  }

  export type LessonOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    file?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type LessonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    title?: string
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    description?: StringNullableFilter<"Lesson"> | string | null
    file?: StringNullableFilter<"Lesson"> | string | null
    is_active?: BoolNullableFilter<"Lesson"> | boolean | null
    created_at?: DateTimeFilter<"Lesson"> | Date | string
    updated_at?: DateTimeFilter<"Lesson"> | Date | string
    tasks?: TaskListRelationFilter
  }, "id" | "title">

  export type LessonOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    file?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: LessonCountOrderByAggregateInput
    _max?: LessonMaxOrderByAggregateInput
    _min?: LessonMinOrderByAggregateInput
  }

  export type LessonScalarWhereWithAggregatesInput = {
    AND?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    OR?: LessonScalarWhereWithAggregatesInput[]
    NOT?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lesson"> | string
    title?: StringWithAggregatesFilter<"Lesson"> | string
    description?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    file?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    is_active?: BoolNullableWithAggregatesFilter<"Lesson"> | boolean | null
    created_at?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    file?: StringNullableFilter<"Task"> | string | null
    score?: IntFilter<"Task"> | number
    is_active?: BoolNullableFilter<"Task"> | boolean | null
    lessonId?: StringFilter<"Task"> | string
    created_at?: DateTimeFilter<"Task"> | Date | string
    updated_at?: DateTimeFilter<"Task"> | Date | string
    lesson?: XOR<LessonRelationFilter, LessonWhereInput>
    criterias?: TaskCriteriaListRelationFilter
    task_applys?: TaskApplyListRelationFilter
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    file?: SortOrderInput | SortOrder
    score?: SortOrder
    is_active?: SortOrderInput | SortOrder
    lessonId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    lesson?: LessonOrderByWithRelationInput
    criterias?: TaskCriteriaOrderByRelationAggregateInput
    task_applys?: TaskApplyOrderByRelationAggregateInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    file?: StringNullableFilter<"Task"> | string | null
    score?: IntFilter<"Task"> | number
    is_active?: BoolNullableFilter<"Task"> | boolean | null
    lessonId?: StringFilter<"Task"> | string
    created_at?: DateTimeFilter<"Task"> | Date | string
    updated_at?: DateTimeFilter<"Task"> | Date | string
    lesson?: XOR<LessonRelationFilter, LessonWhereInput>
    criterias?: TaskCriteriaListRelationFilter
    task_applys?: TaskApplyListRelationFilter
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    file?: SortOrderInput | SortOrder
    score?: SortOrder
    is_active?: SortOrderInput | SortOrder
    lessonId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    file?: StringNullableWithAggregatesFilter<"Task"> | string | null
    score?: IntWithAggregatesFilter<"Task"> | number
    is_active?: BoolNullableWithAggregatesFilter<"Task"> | boolean | null
    lessonId?: StringWithAggregatesFilter<"Task"> | string
    created_at?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Task"> | Date | string
  }

  export type TaskCriteriaWhereInput = {
    AND?: TaskCriteriaWhereInput | TaskCriteriaWhereInput[]
    OR?: TaskCriteriaWhereInput[]
    NOT?: TaskCriteriaWhereInput | TaskCriteriaWhereInput[]
    id?: StringFilter<"TaskCriteria"> | string
    key?: StringFilter<"TaskCriteria"> | string
    value?: IntFilter<"TaskCriteria"> | number
    description?: StringNullableFilter<"TaskCriteria"> | string | null
    taskId?: StringFilter<"TaskCriteria"> | string
    created_at?: DateTimeFilter<"TaskCriteria"> | Date | string
    updated_at?: DateTimeFilter<"TaskCriteria"> | Date | string
    task?: XOR<TaskRelationFilter, TaskWhereInput>
    checks_criterias?: CheckWithTaskCriteriasListRelationFilter
  }

  export type TaskCriteriaOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    taskId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    task?: TaskOrderByWithRelationInput
    checks_criterias?: CheckWithTaskCriteriasOrderByRelationAggregateInput
  }

  export type TaskCriteriaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskCriteriaWhereInput | TaskCriteriaWhereInput[]
    OR?: TaskCriteriaWhereInput[]
    NOT?: TaskCriteriaWhereInput | TaskCriteriaWhereInput[]
    key?: StringFilter<"TaskCriteria"> | string
    value?: IntFilter<"TaskCriteria"> | number
    description?: StringNullableFilter<"TaskCriteria"> | string | null
    taskId?: StringFilter<"TaskCriteria"> | string
    created_at?: DateTimeFilter<"TaskCriteria"> | Date | string
    updated_at?: DateTimeFilter<"TaskCriteria"> | Date | string
    task?: XOR<TaskRelationFilter, TaskWhereInput>
    checks_criterias?: CheckWithTaskCriteriasListRelationFilter
  }, "id">

  export type TaskCriteriaOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    taskId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TaskCriteriaCountOrderByAggregateInput
    _avg?: TaskCriteriaAvgOrderByAggregateInput
    _max?: TaskCriteriaMaxOrderByAggregateInput
    _min?: TaskCriteriaMinOrderByAggregateInput
    _sum?: TaskCriteriaSumOrderByAggregateInput
  }

  export type TaskCriteriaScalarWhereWithAggregatesInput = {
    AND?: TaskCriteriaScalarWhereWithAggregatesInput | TaskCriteriaScalarWhereWithAggregatesInput[]
    OR?: TaskCriteriaScalarWhereWithAggregatesInput[]
    NOT?: TaskCriteriaScalarWhereWithAggregatesInput | TaskCriteriaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskCriteria"> | string
    key?: StringWithAggregatesFilter<"TaskCriteria"> | string
    value?: IntWithAggregatesFilter<"TaskCriteria"> | number
    description?: StringNullableWithAggregatesFilter<"TaskCriteria"> | string | null
    taskId?: StringWithAggregatesFilter<"TaskCriteria"> | string
    created_at?: DateTimeWithAggregatesFilter<"TaskCriteria"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"TaskCriteria"> | Date | string
  }

  export type TaskApplyWhereInput = {
    AND?: TaskApplyWhereInput | TaskApplyWhereInput[]
    OR?: TaskApplyWhereInput[]
    NOT?: TaskApplyWhereInput | TaskApplyWhereInput[]
    id?: StringFilter<"TaskApply"> | string
    teacherId?: StringFilter<"TaskApply"> | string
    taskId?: StringFilter<"TaskApply"> | string
    overall_score?: IntNullableFilter<"TaskApply"> | number | null
    description?: StringFilter<"TaskApply"> | string
    file?: StringNullableFilter<"TaskApply"> | string | null
    is_active?: BoolNullableFilter<"TaskApply"> | boolean | null
    is_seen?: BoolNullableFilter<"TaskApply"> | boolean | null
    created_at?: DateTimeFilter<"TaskApply"> | Date | string
    updated_at?: DateTimeFilter<"TaskApply"> | Date | string
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
    task?: XOR<TaskRelationFilter, TaskWhereInput>
    check_task_criterias?: CheckWithTaskCriteriasListRelationFilter
  }

  export type TaskApplyOrderByWithRelationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    taskId?: SortOrder
    overall_score?: SortOrderInput | SortOrder
    description?: SortOrder
    file?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    is_seen?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    teacher?: TeacherOrderByWithRelationInput
    task?: TaskOrderByWithRelationInput
    check_task_criterias?: CheckWithTaskCriteriasOrderByRelationAggregateInput
  }

  export type TaskApplyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskApplyWhereInput | TaskApplyWhereInput[]
    OR?: TaskApplyWhereInput[]
    NOT?: TaskApplyWhereInput | TaskApplyWhereInput[]
    teacherId?: StringFilter<"TaskApply"> | string
    taskId?: StringFilter<"TaskApply"> | string
    overall_score?: IntNullableFilter<"TaskApply"> | number | null
    description?: StringFilter<"TaskApply"> | string
    file?: StringNullableFilter<"TaskApply"> | string | null
    is_active?: BoolNullableFilter<"TaskApply"> | boolean | null
    is_seen?: BoolNullableFilter<"TaskApply"> | boolean | null
    created_at?: DateTimeFilter<"TaskApply"> | Date | string
    updated_at?: DateTimeFilter<"TaskApply"> | Date | string
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
    task?: XOR<TaskRelationFilter, TaskWhereInput>
    check_task_criterias?: CheckWithTaskCriteriasListRelationFilter
  }, "id">

  export type TaskApplyOrderByWithAggregationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    taskId?: SortOrder
    overall_score?: SortOrderInput | SortOrder
    description?: SortOrder
    file?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    is_seen?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TaskApplyCountOrderByAggregateInput
    _avg?: TaskApplyAvgOrderByAggregateInput
    _max?: TaskApplyMaxOrderByAggregateInput
    _min?: TaskApplyMinOrderByAggregateInput
    _sum?: TaskApplySumOrderByAggregateInput
  }

  export type TaskApplyScalarWhereWithAggregatesInput = {
    AND?: TaskApplyScalarWhereWithAggregatesInput | TaskApplyScalarWhereWithAggregatesInput[]
    OR?: TaskApplyScalarWhereWithAggregatesInput[]
    NOT?: TaskApplyScalarWhereWithAggregatesInput | TaskApplyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskApply"> | string
    teacherId?: StringWithAggregatesFilter<"TaskApply"> | string
    taskId?: StringWithAggregatesFilter<"TaskApply"> | string
    overall_score?: IntNullableWithAggregatesFilter<"TaskApply"> | number | null
    description?: StringWithAggregatesFilter<"TaskApply"> | string
    file?: StringNullableWithAggregatesFilter<"TaskApply"> | string | null
    is_active?: BoolNullableWithAggregatesFilter<"TaskApply"> | boolean | null
    is_seen?: BoolNullableWithAggregatesFilter<"TaskApply"> | boolean | null
    created_at?: DateTimeWithAggregatesFilter<"TaskApply"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"TaskApply"> | Date | string
  }

  export type CheckWithTaskCriteriasWhereInput = {
    AND?: CheckWithTaskCriteriasWhereInput | CheckWithTaskCriteriasWhereInput[]
    OR?: CheckWithTaskCriteriasWhereInput[]
    NOT?: CheckWithTaskCriteriasWhereInput | CheckWithTaskCriteriasWhereInput[]
    id?: StringFilter<"CheckWithTaskCriterias"> | string
    task_applyId?: StringFilter<"CheckWithTaskCriterias"> | string
    task_criteriaId?: StringFilter<"CheckWithTaskCriterias"> | string
    criteria_score?: IntFilter<"CheckWithTaskCriterias"> | number
    description?: StringNullableFilter<"CheckWithTaskCriterias"> | string | null
    created_at?: DateTimeFilter<"CheckWithTaskCriterias"> | Date | string
    updated_at?: DateTimeFilter<"CheckWithTaskCriterias"> | Date | string
    task_apply?: XOR<TaskApplyRelationFilter, TaskApplyWhereInput>
    task_criteria?: XOR<TaskCriteriaRelationFilter, TaskCriteriaWhereInput>
  }

  export type CheckWithTaskCriteriasOrderByWithRelationInput = {
    id?: SortOrder
    task_applyId?: SortOrder
    task_criteriaId?: SortOrder
    criteria_score?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    task_apply?: TaskApplyOrderByWithRelationInput
    task_criteria?: TaskCriteriaOrderByWithRelationInput
  }

  export type CheckWithTaskCriteriasWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CheckWithTaskCriteriasWhereInput | CheckWithTaskCriteriasWhereInput[]
    OR?: CheckWithTaskCriteriasWhereInput[]
    NOT?: CheckWithTaskCriteriasWhereInput | CheckWithTaskCriteriasWhereInput[]
    task_applyId?: StringFilter<"CheckWithTaskCriterias"> | string
    task_criteriaId?: StringFilter<"CheckWithTaskCriterias"> | string
    criteria_score?: IntFilter<"CheckWithTaskCriterias"> | number
    description?: StringNullableFilter<"CheckWithTaskCriterias"> | string | null
    created_at?: DateTimeFilter<"CheckWithTaskCriterias"> | Date | string
    updated_at?: DateTimeFilter<"CheckWithTaskCriterias"> | Date | string
    task_apply?: XOR<TaskApplyRelationFilter, TaskApplyWhereInput>
    task_criteria?: XOR<TaskCriteriaRelationFilter, TaskCriteriaWhereInput>
  }, "id">

  export type CheckWithTaskCriteriasOrderByWithAggregationInput = {
    id?: SortOrder
    task_applyId?: SortOrder
    task_criteriaId?: SortOrder
    criteria_score?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CheckWithTaskCriteriasCountOrderByAggregateInput
    _avg?: CheckWithTaskCriteriasAvgOrderByAggregateInput
    _max?: CheckWithTaskCriteriasMaxOrderByAggregateInput
    _min?: CheckWithTaskCriteriasMinOrderByAggregateInput
    _sum?: CheckWithTaskCriteriasSumOrderByAggregateInput
  }

  export type CheckWithTaskCriteriasScalarWhereWithAggregatesInput = {
    AND?: CheckWithTaskCriteriasScalarWhereWithAggregatesInput | CheckWithTaskCriteriasScalarWhereWithAggregatesInput[]
    OR?: CheckWithTaskCriteriasScalarWhereWithAggregatesInput[]
    NOT?: CheckWithTaskCriteriasScalarWhereWithAggregatesInput | CheckWithTaskCriteriasScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CheckWithTaskCriterias"> | string
    task_applyId?: StringWithAggregatesFilter<"CheckWithTaskCriterias"> | string
    task_criteriaId?: StringWithAggregatesFilter<"CheckWithTaskCriterias"> | string
    criteria_score?: IntWithAggregatesFilter<"CheckWithTaskCriterias"> | number
    description?: StringNullableWithAggregatesFilter<"CheckWithTaskCriterias"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"CheckWithTaskCriterias"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"CheckWithTaskCriterias"> | Date | string
  }

  export type TeacherWhereInput = {
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    id?: StringFilter<"Teacher"> | string
    first_name?: StringFilter<"Teacher"> | string
    last_name?: StringFilter<"Teacher"> | string
    email?: StringFilter<"Teacher"> | string
    username?: StringFilter<"Teacher"> | string
    hashed_password?: StringFilter<"Teacher"> | string
    hashed_refresh_token?: StringNullableFilter<"Teacher"> | string | null
    activation_link?: StringNullableFilter<"Teacher"> | string | null
    is_active?: BoolFilter<"Teacher"> | boolean
    created_at?: DateTimeFilter<"Teacher"> | Date | string
    updated_at?: DateTimeFilter<"Teacher"> | Date | string
    task_applys?: TaskApplyListRelationFilter
    teacher_training_applys?: TrainingApplyListRelationFilter
    write_question_applys?: WriteQuestionApplyListRelationFilter
    choice_answer_applys?: ChoiceAnswerApplyListRelationFilter
    teacher_personal_info?: TeacherPersonalInfoListRelationFilter
    teacher_workplace?: TeacherWorkplaceListRelationFilter
  }

  export type TeacherOrderByWithRelationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    hashed_password?: SortOrder
    hashed_refresh_token?: SortOrderInput | SortOrder
    activation_link?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    task_applys?: TaskApplyOrderByRelationAggregateInput
    teacher_training_applys?: TrainingApplyOrderByRelationAggregateInput
    write_question_applys?: WriteQuestionApplyOrderByRelationAggregateInput
    choice_answer_applys?: ChoiceAnswerApplyOrderByRelationAggregateInput
    teacher_personal_info?: TeacherPersonalInfoOrderByRelationAggregateInput
    teacher_workplace?: TeacherWorkplaceOrderByRelationAggregateInput
  }

  export type TeacherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    activation_link?: string
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    first_name?: StringFilter<"Teacher"> | string
    last_name?: StringFilter<"Teacher"> | string
    hashed_password?: StringFilter<"Teacher"> | string
    hashed_refresh_token?: StringNullableFilter<"Teacher"> | string | null
    is_active?: BoolFilter<"Teacher"> | boolean
    created_at?: DateTimeFilter<"Teacher"> | Date | string
    updated_at?: DateTimeFilter<"Teacher"> | Date | string
    task_applys?: TaskApplyListRelationFilter
    teacher_training_applys?: TrainingApplyListRelationFilter
    write_question_applys?: WriteQuestionApplyListRelationFilter
    choice_answer_applys?: ChoiceAnswerApplyListRelationFilter
    teacher_personal_info?: TeacherPersonalInfoListRelationFilter
    teacher_workplace?: TeacherWorkplaceListRelationFilter
  }, "id" | "email" | "username" | "activation_link">

  export type TeacherOrderByWithAggregationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    hashed_password?: SortOrder
    hashed_refresh_token?: SortOrderInput | SortOrder
    activation_link?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TeacherCountOrderByAggregateInput
    _max?: TeacherMaxOrderByAggregateInput
    _min?: TeacherMinOrderByAggregateInput
  }

  export type TeacherScalarWhereWithAggregatesInput = {
    AND?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    OR?: TeacherScalarWhereWithAggregatesInput[]
    NOT?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Teacher"> | string
    first_name?: StringWithAggregatesFilter<"Teacher"> | string
    last_name?: StringWithAggregatesFilter<"Teacher"> | string
    email?: StringWithAggregatesFilter<"Teacher"> | string
    username?: StringWithAggregatesFilter<"Teacher"> | string
    hashed_password?: StringWithAggregatesFilter<"Teacher"> | string
    hashed_refresh_token?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    activation_link?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    is_active?: BoolWithAggregatesFilter<"Teacher"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Teacher"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Teacher"> | Date | string
  }

  export type TeacherPersonalInfoWhereInput = {
    AND?: TeacherPersonalInfoWhereInput | TeacherPersonalInfoWhereInput[]
    OR?: TeacherPersonalInfoWhereInput[]
    NOT?: TeacherPersonalInfoWhereInput | TeacherPersonalInfoWhereInput[]
    id?: StringFilter<"TeacherPersonalInfo"> | string
    teacherId?: StringFilter<"TeacherPersonalInfo"> | string
    nationality?: StringNullableFilter<"TeacherPersonalInfo"> | string | null
    gender?: StringNullableFilter<"TeacherPersonalInfo"> | string | null
    birthDate?: StringNullableFilter<"TeacherPersonalInfo"> | string | null
    passport_serial?: StringNullableFilter<"TeacherPersonalInfo"> | string | null
    is_active?: BoolFilter<"TeacherPersonalInfo"> | boolean
    photo?: StringNullableFilter<"TeacherPersonalInfo"> | string | null
    created_at?: DateTimeFilter<"TeacherPersonalInfo"> | Date | string
    updated_at?: DateTimeFilter<"TeacherPersonalInfo"> | Date | string
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
  }

  export type TeacherPersonalInfoOrderByWithRelationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    nationality?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    passport_serial?: SortOrderInput | SortOrder
    is_active?: SortOrder
    photo?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    teacher?: TeacherOrderByWithRelationInput
  }

  export type TeacherPersonalInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeacherPersonalInfoWhereInput | TeacherPersonalInfoWhereInput[]
    OR?: TeacherPersonalInfoWhereInput[]
    NOT?: TeacherPersonalInfoWhereInput | TeacherPersonalInfoWhereInput[]
    teacherId?: StringFilter<"TeacherPersonalInfo"> | string
    nationality?: StringNullableFilter<"TeacherPersonalInfo"> | string | null
    gender?: StringNullableFilter<"TeacherPersonalInfo"> | string | null
    birthDate?: StringNullableFilter<"TeacherPersonalInfo"> | string | null
    passport_serial?: StringNullableFilter<"TeacherPersonalInfo"> | string | null
    is_active?: BoolFilter<"TeacherPersonalInfo"> | boolean
    photo?: StringNullableFilter<"TeacherPersonalInfo"> | string | null
    created_at?: DateTimeFilter<"TeacherPersonalInfo"> | Date | string
    updated_at?: DateTimeFilter<"TeacherPersonalInfo"> | Date | string
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
  }, "id">

  export type TeacherPersonalInfoOrderByWithAggregationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    nationality?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    passport_serial?: SortOrderInput | SortOrder
    is_active?: SortOrder
    photo?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TeacherPersonalInfoCountOrderByAggregateInput
    _max?: TeacherPersonalInfoMaxOrderByAggregateInput
    _min?: TeacherPersonalInfoMinOrderByAggregateInput
  }

  export type TeacherPersonalInfoScalarWhereWithAggregatesInput = {
    AND?: TeacherPersonalInfoScalarWhereWithAggregatesInput | TeacherPersonalInfoScalarWhereWithAggregatesInput[]
    OR?: TeacherPersonalInfoScalarWhereWithAggregatesInput[]
    NOT?: TeacherPersonalInfoScalarWhereWithAggregatesInput | TeacherPersonalInfoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeacherPersonalInfo"> | string
    teacherId?: StringWithAggregatesFilter<"TeacherPersonalInfo"> | string
    nationality?: StringNullableWithAggregatesFilter<"TeacherPersonalInfo"> | string | null
    gender?: StringNullableWithAggregatesFilter<"TeacherPersonalInfo"> | string | null
    birthDate?: StringNullableWithAggregatesFilter<"TeacherPersonalInfo"> | string | null
    passport_serial?: StringNullableWithAggregatesFilter<"TeacherPersonalInfo"> | string | null
    is_active?: BoolWithAggregatesFilter<"TeacherPersonalInfo"> | boolean
    photo?: StringNullableWithAggregatesFilter<"TeacherPersonalInfo"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"TeacherPersonalInfo"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"TeacherPersonalInfo"> | Date | string
  }

  export type TeacherWorkplaceWhereInput = {
    AND?: TeacherWorkplaceWhereInput | TeacherWorkplaceWhereInput[]
    OR?: TeacherWorkplaceWhereInput[]
    NOT?: TeacherWorkplaceWhereInput | TeacherWorkplaceWhereInput[]
    id?: StringFilter<"TeacherWorkplace"> | string
    position?: StringFilter<"TeacherWorkplace"> | string
    teacherId?: StringFilter<"TeacherWorkplace"> | string
    schoolId?: StringFilter<"TeacherWorkplace"> | string
    created_at?: DateTimeFilter<"TeacherWorkplace"> | Date | string
    updated_at?: DateTimeFilter<"TeacherWorkplace"> | Date | string
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type TeacherWorkplaceOrderByWithRelationInput = {
    id?: SortOrder
    position?: SortOrder
    teacherId?: SortOrder
    schoolId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    teacher?: TeacherOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
  }

  export type TeacherWorkplaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeacherWorkplaceWhereInput | TeacherWorkplaceWhereInput[]
    OR?: TeacherWorkplaceWhereInput[]
    NOT?: TeacherWorkplaceWhereInput | TeacherWorkplaceWhereInput[]
    position?: StringFilter<"TeacherWorkplace"> | string
    teacherId?: StringFilter<"TeacherWorkplace"> | string
    schoolId?: StringFilter<"TeacherWorkplace"> | string
    created_at?: DateTimeFilter<"TeacherWorkplace"> | Date | string
    updated_at?: DateTimeFilter<"TeacherWorkplace"> | Date | string
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id">

  export type TeacherWorkplaceOrderByWithAggregationInput = {
    id?: SortOrder
    position?: SortOrder
    teacherId?: SortOrder
    schoolId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TeacherWorkplaceCountOrderByAggregateInput
    _max?: TeacherWorkplaceMaxOrderByAggregateInput
    _min?: TeacherWorkplaceMinOrderByAggregateInput
  }

  export type TeacherWorkplaceScalarWhereWithAggregatesInput = {
    AND?: TeacherWorkplaceScalarWhereWithAggregatesInput | TeacherWorkplaceScalarWhereWithAggregatesInput[]
    OR?: TeacherWorkplaceScalarWhereWithAggregatesInput[]
    NOT?: TeacherWorkplaceScalarWhereWithAggregatesInput | TeacherWorkplaceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeacherWorkplace"> | string
    position?: StringWithAggregatesFilter<"TeacherWorkplace"> | string
    teacherId?: StringWithAggregatesFilter<"TeacherWorkplace"> | string
    schoolId?: StringWithAggregatesFilter<"TeacherWorkplace"> | string
    created_at?: DateTimeWithAggregatesFilter<"TeacherWorkplace"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"TeacherWorkplace"> | Date | string
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    first_name?: StringFilter<"Admin"> | string
    last_name?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    username?: StringFilter<"Admin"> | string
    hashed_password?: StringFilter<"Admin"> | string
    hashed_refresh_token?: StringNullableFilter<"Admin"> | string | null
    activation_link?: StringNullableFilter<"Admin"> | string | null
    is_active?: BoolFilter<"Admin"> | boolean
    created_at?: DateTimeFilter<"Admin"> | Date | string
    updated_at?: DateTimeFilter<"Admin"> | Date | string
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    hashed_password?: SortOrder
    hashed_refresh_token?: SortOrderInput | SortOrder
    activation_link?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    activation_link?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    first_name?: StringFilter<"Admin"> | string
    last_name?: StringFilter<"Admin"> | string
    hashed_password?: StringFilter<"Admin"> | string
    hashed_refresh_token?: StringNullableFilter<"Admin"> | string | null
    is_active?: BoolFilter<"Admin"> | boolean
    created_at?: DateTimeFilter<"Admin"> | Date | string
    updated_at?: DateTimeFilter<"Admin"> | Date | string
  }, "id" | "email" | "username" | "activation_link">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    hashed_password?: SortOrder
    hashed_refresh_token?: SortOrderInput | SortOrder
    activation_link?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    first_name?: StringWithAggregatesFilter<"Admin"> | string
    last_name?: StringWithAggregatesFilter<"Admin"> | string
    email?: StringWithAggregatesFilter<"Admin"> | string
    username?: StringWithAggregatesFilter<"Admin"> | string
    hashed_password?: StringWithAggregatesFilter<"Admin"> | string
    hashed_refresh_token?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    activation_link?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    is_active?: BoolWithAggregatesFilter<"Admin"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
  }

  export type SchoolCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    region: RegionCreateNestedOneWithoutSchoolsInput
    teachers_workplaces?: TeacherWorkplaceCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateInput = {
    id?: string
    name: string
    region_id: string
    created_at?: Date | string
    updated_at?: Date | string
    teachers_workplaces?: TeacherWorkplaceUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    region?: RegionUpdateOneRequiredWithoutSchoolsNestedInput
    teachers_workplaces?: TeacherWorkplaceUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers_workplaces?: TeacherWorkplaceUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateManyInput = {
    id?: string
    name: string
    region_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SchoolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    schools?: SchoolCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    schools?: SchoolUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type RegionCreateManyInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RegionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceQuestionCreateInput = {
    id?: string
    text: string
    description?: string | null
    correct_choice: string
    created_at?: Date | string
    updated_at?: Date | string
    answers?: ChoiceAnswerCreateNestedManyWithoutQuestionInput
  }

  export type ChoiceQuestionUncheckedCreateInput = {
    id?: string
    text: string
    description?: string | null
    correct_choice: string
    created_at?: Date | string
    updated_at?: Date | string
    answers?: ChoiceAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type ChoiceQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    correct_choice?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: ChoiceAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type ChoiceQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    correct_choice?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: ChoiceAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type ChoiceQuestionCreateManyInput = {
    id?: string
    text: string
    description?: string | null
    correct_choice: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChoiceQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    correct_choice?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    correct_choice?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceAnswerCreateInput = {
    id?: string
    key: string
    value: string
    created_at?: Date | string
    updated_at?: Date | string
    question: ChoiceQuestionCreateNestedOneWithoutAnswersInput
    choice_answer_applys?: ChoiceAnswerApplyCreateNestedManyWithoutAnswerInput
  }

  export type ChoiceAnswerUncheckedCreateInput = {
    id?: string
    questionId: string
    key: string
    value: string
    created_at?: Date | string
    updated_at?: Date | string
    choice_answer_applys?: ChoiceAnswerApplyUncheckedCreateNestedManyWithoutAnswerInput
  }

  export type ChoiceAnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: ChoiceQuestionUpdateOneRequiredWithoutAnswersNestedInput
    choice_answer_applys?: ChoiceAnswerApplyUpdateManyWithoutAnswerNestedInput
  }

  export type ChoiceAnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    choice_answer_applys?: ChoiceAnswerApplyUncheckedUpdateManyWithoutAnswerNestedInput
  }

  export type ChoiceAnswerCreateManyInput = {
    id?: string
    questionId: string
    key: string
    value: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChoiceAnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceAnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceAnswerApplyCreateInput = {
    id?: string
    key: string
    is_correct?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    teacher: TeacherCreateNestedOneWithoutChoice_answer_applysInput
    answer: ChoiceAnswerCreateNestedOneWithoutChoice_answer_applysInput
  }

  export type ChoiceAnswerApplyUncheckedCreateInput = {
    id?: string
    teacherId: string
    answerId: string
    key: string
    is_correct?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChoiceAnswerApplyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutChoice_answer_applysNestedInput
    answer?: ChoiceAnswerUpdateOneRequiredWithoutChoice_answer_applysNestedInput
  }

  export type ChoiceAnswerApplyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    answerId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceAnswerApplyCreateManyInput = {
    id?: string
    teacherId: string
    answerId: string
    key: string
    is_correct?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChoiceAnswerApplyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceAnswerApplyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    answerId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WriteQuestionCreateInput = {
    id?: string
    text: string
    correct_answer: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    question_applys?: WriteQuestionApplyCreateNestedManyWithoutQuestionInput
  }

  export type WriteQuestionUncheckedCreateInput = {
    id?: string
    text: string
    correct_answer: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    question_applys?: WriteQuestionApplyUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type WriteQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    correct_answer?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    question_applys?: WriteQuestionApplyUpdateManyWithoutQuestionNestedInput
  }

  export type WriteQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    correct_answer?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    question_applys?: WriteQuestionApplyUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type WriteQuestionCreateManyInput = {
    id?: string
    text: string
    correct_answer: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WriteQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    correct_answer?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WriteQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    correct_answer?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WriteQuestionApplyCreateInput = {
    id?: string
    value: string
    is_correct?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    question: WriteQuestionCreateNestedOneWithoutQuestion_applysInput
    teacher: TeacherCreateNestedOneWithoutWrite_question_applysInput
  }

  export type WriteQuestionApplyUncheckedCreateInput = {
    id?: string
    questionId: string
    teacherId: string
    value: string
    is_correct?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WriteQuestionApplyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: WriteQuestionUpdateOneRequiredWithoutQuestion_applysNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutWrite_question_applysNestedInput
  }

  export type WriteQuestionApplyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WriteQuestionApplyCreateManyInput = {
    id?: string
    questionId: string
    teacherId: string
    value: string
    is_correct?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WriteQuestionApplyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WriteQuestionApplyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingCreateInput = {
    id?: string
    title: string
    description?: string | null
    subject?: string | null
    max_score?: number | null
    pass_score?: number | null
    file?: string | null
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    training_applys?: TrainingApplyCreateNestedManyWithoutTrainInput
  }

  export type TrainingUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    subject?: string | null
    max_score?: number | null
    pass_score?: number | null
    file?: string | null
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    training_applys?: TrainingApplyUncheckedCreateNestedManyWithoutTrainInput
  }

  export type TrainingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    max_score?: NullableIntFieldUpdateOperationsInput | number | null
    pass_score?: NullableIntFieldUpdateOperationsInput | number | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    training_applys?: TrainingApplyUpdateManyWithoutTrainNestedInput
  }

  export type TrainingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    max_score?: NullableIntFieldUpdateOperationsInput | number | null
    pass_score?: NullableIntFieldUpdateOperationsInput | number | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    training_applys?: TrainingApplyUncheckedUpdateManyWithoutTrainNestedInput
  }

  export type TrainingCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    subject?: string | null
    max_score?: number | null
    pass_score?: number | null
    file?: string | null
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TrainingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    max_score?: NullableIntFieldUpdateOperationsInput | number | null
    pass_score?: NullableIntFieldUpdateOperationsInput | number | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    max_score?: NullableIntFieldUpdateOperationsInput | number | null
    pass_score?: NullableIntFieldUpdateOperationsInput | number | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingApplyCreateInput = {
    id?: string
    text?: string | null
    file?: string | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    train: TrainingCreateNestedOneWithoutTraining_applysInput
    teacher: TeacherCreateNestedOneWithoutTeacher_training_applysInput
    checking_applys?: CheckTrainingApplyCreateNestedManyWithoutTraining_applyInput
  }

  export type TrainingApplyUncheckedCreateInput = {
    id?: string
    trainingId: string
    teacherId: string
    text?: string | null
    file?: string | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    checking_applys?: CheckTrainingApplyUncheckedCreateNestedManyWithoutTraining_applyInput
  }

  export type TrainingApplyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    train?: TrainingUpdateOneRequiredWithoutTraining_applysNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutTeacher_training_applysNestedInput
    checking_applys?: CheckTrainingApplyUpdateManyWithoutTraining_applyNestedInput
  }

  export type TrainingApplyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    checking_applys?: CheckTrainingApplyUncheckedUpdateManyWithoutTraining_applyNestedInput
  }

  export type TrainingApplyCreateManyInput = {
    id?: string
    trainingId: string
    teacherId: string
    text?: string | null
    file?: string | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TrainingApplyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingApplyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckTrainingApplyCreateInput = {
    id?: string
    description?: string | null
    score?: number
    is_active?: boolean | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    training_apply: TrainingApplyCreateNestedOneWithoutChecking_applysInput
  }

  export type CheckTrainingApplyUncheckedCreateInput = {
    id?: string
    training_applyId: string
    description?: string | null
    score?: number
    is_active?: boolean | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CheckTrainingApplyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    training_apply?: TrainingApplyUpdateOneRequiredWithoutChecking_applysNestedInput
  }

  export type CheckTrainingApplyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    training_applyId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckTrainingApplyCreateManyInput = {
    id?: string
    training_applyId: string
    description?: string | null
    score?: number
    is_active?: boolean | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CheckTrainingApplyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckTrainingApplyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    training_applyId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonCreateInput = {
    id?: string
    title: string
    description?: string | null
    file?: string | null
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    tasks?: TaskCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    file?: string | null
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    file?: string | null
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LessonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    file?: string | null
    score?: number
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    lesson: LessonCreateNestedOneWithoutTasksInput
    criterias?: TaskCriteriaCreateNestedManyWithoutTaskInput
    task_applys?: TaskApplyCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    file?: string | null
    score?: number
    is_active?: boolean | null
    lessonId: string
    created_at?: Date | string
    updated_at?: Date | string
    criterias?: TaskCriteriaUncheckedCreateNestedManyWithoutTaskInput
    task_applys?: TaskApplyUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutTasksNestedInput
    criterias?: TaskCriteriaUpdateManyWithoutTaskNestedInput
    task_applys?: TaskApplyUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lessonId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    criterias?: TaskCriteriaUncheckedUpdateManyWithoutTaskNestedInput
    task_applys?: TaskApplyUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    file?: string | null
    score?: number
    is_active?: boolean | null
    lessonId: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lessonId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCriteriaCreateInput = {
    id?: string
    key: string
    value: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    task: TaskCreateNestedOneWithoutCriteriasInput
    checks_criterias?: CheckWithTaskCriteriasCreateNestedManyWithoutTask_criteriaInput
  }

  export type TaskCriteriaUncheckedCreateInput = {
    id?: string
    key: string
    value: number
    description?: string | null
    taskId: string
    created_at?: Date | string
    updated_at?: Date | string
    checks_criterias?: CheckWithTaskCriteriasUncheckedCreateNestedManyWithoutTask_criteriaInput
  }

  export type TaskCriteriaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutCriteriasNestedInput
    checks_criterias?: CheckWithTaskCriteriasUpdateManyWithoutTask_criteriaNestedInput
  }

  export type TaskCriteriaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    checks_criterias?: CheckWithTaskCriteriasUncheckedUpdateManyWithoutTask_criteriaNestedInput
  }

  export type TaskCriteriaCreateManyInput = {
    id?: string
    key: string
    value: number
    description?: string | null
    taskId: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TaskCriteriaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCriteriaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskApplyCreateInput = {
    id?: string
    overall_score?: number | null
    description: string
    file?: string | null
    is_active?: boolean | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    teacher: TeacherCreateNestedOneWithoutTask_applysInput
    task: TaskCreateNestedOneWithoutTask_applysInput
    check_task_criterias?: CheckWithTaskCriteriasCreateNestedManyWithoutTask_applyInput
  }

  export type TaskApplyUncheckedCreateInput = {
    id?: string
    teacherId: string
    taskId: string
    overall_score?: number | null
    description: string
    file?: string | null
    is_active?: boolean | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    check_task_criterias?: CheckWithTaskCriteriasUncheckedCreateNestedManyWithoutTask_applyInput
  }

  export type TaskApplyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    overall_score?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutTask_applysNestedInput
    task?: TaskUpdateOneRequiredWithoutTask_applysNestedInput
    check_task_criterias?: CheckWithTaskCriteriasUpdateManyWithoutTask_applyNestedInput
  }

  export type TaskApplyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    overall_score?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    check_task_criterias?: CheckWithTaskCriteriasUncheckedUpdateManyWithoutTask_applyNestedInput
  }

  export type TaskApplyCreateManyInput = {
    id?: string
    teacherId: string
    taskId: string
    overall_score?: number | null
    description: string
    file?: string | null
    is_active?: boolean | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TaskApplyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    overall_score?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskApplyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    overall_score?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckWithTaskCriteriasCreateInput = {
    id?: string
    criteria_score?: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    task_apply: TaskApplyCreateNestedOneWithoutCheck_task_criteriasInput
    task_criteria: TaskCriteriaCreateNestedOneWithoutChecks_criteriasInput
  }

  export type CheckWithTaskCriteriasUncheckedCreateInput = {
    id?: string
    task_applyId: string
    task_criteriaId: string
    criteria_score?: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CheckWithTaskCriteriasUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    criteria_score?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_apply?: TaskApplyUpdateOneRequiredWithoutCheck_task_criteriasNestedInput
    task_criteria?: TaskCriteriaUpdateOneRequiredWithoutChecks_criteriasNestedInput
  }

  export type CheckWithTaskCriteriasUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    task_applyId?: StringFieldUpdateOperationsInput | string
    task_criteriaId?: StringFieldUpdateOperationsInput | string
    criteria_score?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckWithTaskCriteriasCreateManyInput = {
    id?: string
    task_applyId: string
    task_criteriaId: string
    criteria_score?: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CheckWithTaskCriteriasUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    criteria_score?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckWithTaskCriteriasUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    task_applyId?: StringFieldUpdateOperationsInput | string
    task_criteriaId?: StringFieldUpdateOperationsInput | string
    criteria_score?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherCreateInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    username: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    task_applys?: TaskApplyCreateNestedManyWithoutTeacherInput
    teacher_training_applys?: TrainingApplyCreateNestedManyWithoutTeacherInput
    write_question_applys?: WriteQuestionApplyCreateNestedManyWithoutTeacherInput
    choice_answer_applys?: ChoiceAnswerApplyCreateNestedManyWithoutTeacherInput
    teacher_personal_info?: TeacherPersonalInfoCreateNestedManyWithoutTeacherInput
    teacher_workplace?: TeacherWorkplaceCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    username: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    task_applys?: TaskApplyUncheckedCreateNestedManyWithoutTeacherInput
    teacher_training_applys?: TrainingApplyUncheckedCreateNestedManyWithoutTeacherInput
    write_question_applys?: WriteQuestionApplyUncheckedCreateNestedManyWithoutTeacherInput
    choice_answer_applys?: ChoiceAnswerApplyUncheckedCreateNestedManyWithoutTeacherInput
    teacher_personal_info?: TeacherPersonalInfoUncheckedCreateNestedManyWithoutTeacherInput
    teacher_workplace?: TeacherWorkplaceUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_applys?: TaskApplyUpdateManyWithoutTeacherNestedInput
    teacher_training_applys?: TrainingApplyUpdateManyWithoutTeacherNestedInput
    write_question_applys?: WriteQuestionApplyUpdateManyWithoutTeacherNestedInput
    choice_answer_applys?: ChoiceAnswerApplyUpdateManyWithoutTeacherNestedInput
    teacher_personal_info?: TeacherPersonalInfoUpdateManyWithoutTeacherNestedInput
    teacher_workplace?: TeacherWorkplaceUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_applys?: TaskApplyUncheckedUpdateManyWithoutTeacherNestedInput
    teacher_training_applys?: TrainingApplyUncheckedUpdateManyWithoutTeacherNestedInput
    write_question_applys?: WriteQuestionApplyUncheckedUpdateManyWithoutTeacherNestedInput
    choice_answer_applys?: ChoiceAnswerApplyUncheckedUpdateManyWithoutTeacherNestedInput
    teacher_personal_info?: TeacherPersonalInfoUncheckedUpdateManyWithoutTeacherNestedInput
    teacher_workplace?: TeacherWorkplaceUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherCreateManyInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    username: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TeacherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherPersonalInfoCreateInput = {
    id?: string
    nationality?: string | null
    gender?: string | null
    birthDate?: string | null
    passport_serial?: string | null
    is_active?: boolean
    photo?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    teacher: TeacherCreateNestedOneWithoutTeacher_personal_infoInput
  }

  export type TeacherPersonalInfoUncheckedCreateInput = {
    id?: string
    teacherId: string
    nationality?: string | null
    gender?: string | null
    birthDate?: string | null
    passport_serial?: string | null
    is_active?: boolean
    photo?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TeacherPersonalInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    passport_serial?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutTeacher_personal_infoNestedInput
  }

  export type TeacherPersonalInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    passport_serial?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherPersonalInfoCreateManyInput = {
    id?: string
    teacherId: string
    nationality?: string | null
    gender?: string | null
    birthDate?: string | null
    passport_serial?: string | null
    is_active?: boolean
    photo?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TeacherPersonalInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    passport_serial?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherPersonalInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    passport_serial?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherWorkplaceCreateInput = {
    id?: string
    position: string
    created_at?: Date | string
    updated_at?: Date | string
    teacher: TeacherCreateNestedOneWithoutTeacher_workplaceInput
    school: SchoolCreateNestedOneWithoutTeachers_workplacesInput
  }

  export type TeacherWorkplaceUncheckedCreateInput = {
    id?: string
    position: string
    teacherId: string
    schoolId: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TeacherWorkplaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutTeacher_workplaceNestedInput
    school?: SchoolUpdateOneRequiredWithoutTeachers_workplacesNestedInput
  }

  export type TeacherWorkplaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherWorkplaceCreateManyInput = {
    id?: string
    position: string
    teacherId: string
    schoolId: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TeacherWorkplaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherWorkplaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    username: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    username: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateManyInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    username: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type RegionRelationFilter = {
    is?: RegionWhereInput
    isNot?: RegionWhereInput
  }

  export type TeacherWorkplaceListRelationFilter = {
    every?: TeacherWorkplaceWhereInput
    some?: TeacherWorkplaceWhereInput
    none?: TeacherWorkplaceWhereInput
  }

  export type TeacherWorkplaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    region_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SchoolMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    region_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SchoolMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    region_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type SchoolListRelationFilter = {
    every?: SchoolWhereInput
    some?: SchoolWhereInput
    none?: SchoolWhereInput
  }

  export type SchoolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RegionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RegionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ChoiceAnswerListRelationFilter = {
    every?: ChoiceAnswerWhereInput
    some?: ChoiceAnswerWhereInput
    none?: ChoiceAnswerWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ChoiceAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChoiceQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    description?: SortOrder
    correct_choice?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChoiceQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    description?: SortOrder
    correct_choice?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChoiceQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    description?: SortOrder
    correct_choice?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type ChoiceQuestionRelationFilter = {
    is?: ChoiceQuestionWhereInput
    isNot?: ChoiceQuestionWhereInput
  }

  export type ChoiceAnswerApplyListRelationFilter = {
    every?: ChoiceAnswerApplyWhereInput
    some?: ChoiceAnswerApplyWhereInput
    none?: ChoiceAnswerApplyWhereInput
  }

  export type ChoiceAnswerApplyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChoiceAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChoiceAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChoiceAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type TeacherRelationFilter = {
    is?: TeacherWhereInput
    isNot?: TeacherWhereInput
  }

  export type ChoiceAnswerRelationFilter = {
    is?: ChoiceAnswerWhereInput
    isNot?: ChoiceAnswerWhereInput
  }

  export type ChoiceAnswerApplyCountOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    answerId?: SortOrder
    key?: SortOrder
    is_correct?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChoiceAnswerApplyMaxOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    answerId?: SortOrder
    key?: SortOrder
    is_correct?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChoiceAnswerApplyMinOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    answerId?: SortOrder
    key?: SortOrder
    is_correct?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type WriteQuestionApplyListRelationFilter = {
    every?: WriteQuestionApplyWhereInput
    some?: WriteQuestionApplyWhereInput
    none?: WriteQuestionApplyWhereInput
  }

  export type WriteQuestionApplyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WriteQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    correct_answer?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WriteQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    correct_answer?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WriteQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    correct_answer?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type WriteQuestionRelationFilter = {
    is?: WriteQuestionWhereInput
    isNot?: WriteQuestionWhereInput
  }

  export type WriteQuestionApplyCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    teacherId?: SortOrder
    value?: SortOrder
    is_correct?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WriteQuestionApplyMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    teacherId?: SortOrder
    value?: SortOrder
    is_correct?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WriteQuestionApplyMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    teacherId?: SortOrder
    value?: SortOrder
    is_correct?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type TrainingApplyListRelationFilter = {
    every?: TrainingApplyWhereInput
    some?: TrainingApplyWhereInput
    none?: TrainingApplyWhereInput
  }

  export type TrainingApplyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    subject?: SortOrder
    max_score?: SortOrder
    pass_score?: SortOrder
    file?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TrainingAvgOrderByAggregateInput = {
    max_score?: SortOrder
    pass_score?: SortOrder
  }

  export type TrainingMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    subject?: SortOrder
    max_score?: SortOrder
    pass_score?: SortOrder
    file?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TrainingMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    subject?: SortOrder
    max_score?: SortOrder
    pass_score?: SortOrder
    file?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TrainingSumOrderByAggregateInput = {
    max_score?: SortOrder
    pass_score?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type TrainingRelationFilter = {
    is?: TrainingWhereInput
    isNot?: TrainingWhereInput
  }

  export type CheckTrainingApplyListRelationFilter = {
    every?: CheckTrainingApplyWhereInput
    some?: CheckTrainingApplyWhereInput
    none?: CheckTrainingApplyWhereInput
  }

  export type CheckTrainingApplyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingApplyCountOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    teacherId?: SortOrder
    text?: SortOrder
    file?: SortOrder
    is_seen?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TrainingApplyMaxOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    teacherId?: SortOrder
    text?: SortOrder
    file?: SortOrder
    is_seen?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TrainingApplyMinOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    teacherId?: SortOrder
    text?: SortOrder
    file?: SortOrder
    is_seen?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type TrainingApplyRelationFilter = {
    is?: TrainingApplyWhereInput
    isNot?: TrainingApplyWhereInput
  }

  export type CheckTrainingApplyCountOrderByAggregateInput = {
    id?: SortOrder
    training_applyId?: SortOrder
    description?: SortOrder
    score?: SortOrder
    is_active?: SortOrder
    is_seen?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CheckTrainingApplyAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type CheckTrainingApplyMaxOrderByAggregateInput = {
    id?: SortOrder
    training_applyId?: SortOrder
    description?: SortOrder
    score?: SortOrder
    is_active?: SortOrder
    is_seen?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CheckTrainingApplyMinOrderByAggregateInput = {
    id?: SortOrder
    training_applyId?: SortOrder
    description?: SortOrder
    score?: SortOrder
    is_active?: SortOrder
    is_seen?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CheckTrainingApplySumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    file?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type LessonMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    file?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type LessonMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    file?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type LessonRelationFilter = {
    is?: LessonWhereInput
    isNot?: LessonWhereInput
  }

  export type TaskCriteriaListRelationFilter = {
    every?: TaskCriteriaWhereInput
    some?: TaskCriteriaWhereInput
    none?: TaskCriteriaWhereInput
  }

  export type TaskApplyListRelationFilter = {
    every?: TaskApplyWhereInput
    some?: TaskApplyWhereInput
    none?: TaskApplyWhereInput
  }

  export type TaskCriteriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskApplyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    file?: SortOrder
    score?: SortOrder
    is_active?: SortOrder
    lessonId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    file?: SortOrder
    score?: SortOrder
    is_active?: SortOrder
    lessonId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    file?: SortOrder
    score?: SortOrder
    is_active?: SortOrder
    lessonId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type TaskRelationFilter = {
    is?: TaskWhereInput
    isNot?: TaskWhereInput
  }

  export type CheckWithTaskCriteriasListRelationFilter = {
    every?: CheckWithTaskCriteriasWhereInput
    some?: CheckWithTaskCriteriasWhereInput
    none?: CheckWithTaskCriteriasWhereInput
  }

  export type CheckWithTaskCriteriasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskCriteriaCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    taskId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TaskCriteriaAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type TaskCriteriaMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    taskId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TaskCriteriaMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    taskId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TaskCriteriaSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type TaskApplyCountOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    taskId?: SortOrder
    overall_score?: SortOrder
    description?: SortOrder
    file?: SortOrder
    is_active?: SortOrder
    is_seen?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TaskApplyAvgOrderByAggregateInput = {
    overall_score?: SortOrder
  }

  export type TaskApplyMaxOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    taskId?: SortOrder
    overall_score?: SortOrder
    description?: SortOrder
    file?: SortOrder
    is_active?: SortOrder
    is_seen?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TaskApplyMinOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    taskId?: SortOrder
    overall_score?: SortOrder
    description?: SortOrder
    file?: SortOrder
    is_active?: SortOrder
    is_seen?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TaskApplySumOrderByAggregateInput = {
    overall_score?: SortOrder
  }

  export type TaskApplyRelationFilter = {
    is?: TaskApplyWhereInput
    isNot?: TaskApplyWhereInput
  }

  export type TaskCriteriaRelationFilter = {
    is?: TaskCriteriaWhereInput
    isNot?: TaskCriteriaWhereInput
  }

  export type CheckWithTaskCriteriasCountOrderByAggregateInput = {
    id?: SortOrder
    task_applyId?: SortOrder
    task_criteriaId?: SortOrder
    criteria_score?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CheckWithTaskCriteriasAvgOrderByAggregateInput = {
    criteria_score?: SortOrder
  }

  export type CheckWithTaskCriteriasMaxOrderByAggregateInput = {
    id?: SortOrder
    task_applyId?: SortOrder
    task_criteriaId?: SortOrder
    criteria_score?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CheckWithTaskCriteriasMinOrderByAggregateInput = {
    id?: SortOrder
    task_applyId?: SortOrder
    task_criteriaId?: SortOrder
    criteria_score?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CheckWithTaskCriteriasSumOrderByAggregateInput = {
    criteria_score?: SortOrder
  }

  export type TeacherPersonalInfoListRelationFilter = {
    every?: TeacherPersonalInfoWhereInput
    some?: TeacherPersonalInfoWhereInput
    none?: TeacherPersonalInfoWhereInput
  }

  export type TeacherPersonalInfoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherCountOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    hashed_password?: SortOrder
    hashed_refresh_token?: SortOrder
    activation_link?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TeacherMaxOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    hashed_password?: SortOrder
    hashed_refresh_token?: SortOrder
    activation_link?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TeacherMinOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    hashed_password?: SortOrder
    hashed_refresh_token?: SortOrder
    activation_link?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TeacherPersonalInfoCountOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    nationality?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    passport_serial?: SortOrder
    is_active?: SortOrder
    photo?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TeacherPersonalInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    nationality?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    passport_serial?: SortOrder
    is_active?: SortOrder
    photo?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TeacherPersonalInfoMinOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    nationality?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    passport_serial?: SortOrder
    is_active?: SortOrder
    photo?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SchoolRelationFilter = {
    is?: SchoolWhereInput
    isNot?: SchoolWhereInput
  }

  export type TeacherWorkplaceCountOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    teacherId?: SortOrder
    schoolId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TeacherWorkplaceMaxOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    teacherId?: SortOrder
    schoolId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TeacherWorkplaceMinOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    teacherId?: SortOrder
    schoolId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    hashed_password?: SortOrder
    hashed_refresh_token?: SortOrder
    activation_link?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    hashed_password?: SortOrder
    hashed_refresh_token?: SortOrder
    activation_link?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    hashed_password?: SortOrder
    hashed_refresh_token?: SortOrder
    activation_link?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RegionCreateNestedOneWithoutSchoolsInput = {
    create?: XOR<RegionCreateWithoutSchoolsInput, RegionUncheckedCreateWithoutSchoolsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutSchoolsInput
    connect?: RegionWhereUniqueInput
  }

  export type TeacherWorkplaceCreateNestedManyWithoutSchoolInput = {
    create?: XOR<TeacherWorkplaceCreateWithoutSchoolInput, TeacherWorkplaceUncheckedCreateWithoutSchoolInput> | TeacherWorkplaceCreateWithoutSchoolInput[] | TeacherWorkplaceUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TeacherWorkplaceCreateOrConnectWithoutSchoolInput | TeacherWorkplaceCreateOrConnectWithoutSchoolInput[]
    createMany?: TeacherWorkplaceCreateManySchoolInputEnvelope
    connect?: TeacherWorkplaceWhereUniqueInput | TeacherWorkplaceWhereUniqueInput[]
  }

  export type TeacherWorkplaceUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<TeacherWorkplaceCreateWithoutSchoolInput, TeacherWorkplaceUncheckedCreateWithoutSchoolInput> | TeacherWorkplaceCreateWithoutSchoolInput[] | TeacherWorkplaceUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TeacherWorkplaceCreateOrConnectWithoutSchoolInput | TeacherWorkplaceCreateOrConnectWithoutSchoolInput[]
    createMany?: TeacherWorkplaceCreateManySchoolInputEnvelope
    connect?: TeacherWorkplaceWhereUniqueInput | TeacherWorkplaceWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type RegionUpdateOneRequiredWithoutSchoolsNestedInput = {
    create?: XOR<RegionCreateWithoutSchoolsInput, RegionUncheckedCreateWithoutSchoolsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutSchoolsInput
    upsert?: RegionUpsertWithoutSchoolsInput
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutSchoolsInput, RegionUpdateWithoutSchoolsInput>, RegionUncheckedUpdateWithoutSchoolsInput>
  }

  export type TeacherWorkplaceUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<TeacherWorkplaceCreateWithoutSchoolInput, TeacherWorkplaceUncheckedCreateWithoutSchoolInput> | TeacherWorkplaceCreateWithoutSchoolInput[] | TeacherWorkplaceUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TeacherWorkplaceCreateOrConnectWithoutSchoolInput | TeacherWorkplaceCreateOrConnectWithoutSchoolInput[]
    upsert?: TeacherWorkplaceUpsertWithWhereUniqueWithoutSchoolInput | TeacherWorkplaceUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: TeacherWorkplaceCreateManySchoolInputEnvelope
    set?: TeacherWorkplaceWhereUniqueInput | TeacherWorkplaceWhereUniqueInput[]
    disconnect?: TeacherWorkplaceWhereUniqueInput | TeacherWorkplaceWhereUniqueInput[]
    delete?: TeacherWorkplaceWhereUniqueInput | TeacherWorkplaceWhereUniqueInput[]
    connect?: TeacherWorkplaceWhereUniqueInput | TeacherWorkplaceWhereUniqueInput[]
    update?: TeacherWorkplaceUpdateWithWhereUniqueWithoutSchoolInput | TeacherWorkplaceUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: TeacherWorkplaceUpdateManyWithWhereWithoutSchoolInput | TeacherWorkplaceUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: TeacherWorkplaceScalarWhereInput | TeacherWorkplaceScalarWhereInput[]
  }

  export type TeacherWorkplaceUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<TeacherWorkplaceCreateWithoutSchoolInput, TeacherWorkplaceUncheckedCreateWithoutSchoolInput> | TeacherWorkplaceCreateWithoutSchoolInput[] | TeacherWorkplaceUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TeacherWorkplaceCreateOrConnectWithoutSchoolInput | TeacherWorkplaceCreateOrConnectWithoutSchoolInput[]
    upsert?: TeacherWorkplaceUpsertWithWhereUniqueWithoutSchoolInput | TeacherWorkplaceUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: TeacherWorkplaceCreateManySchoolInputEnvelope
    set?: TeacherWorkplaceWhereUniqueInput | TeacherWorkplaceWhereUniqueInput[]
    disconnect?: TeacherWorkplaceWhereUniqueInput | TeacherWorkplaceWhereUniqueInput[]
    delete?: TeacherWorkplaceWhereUniqueInput | TeacherWorkplaceWhereUniqueInput[]
    connect?: TeacherWorkplaceWhereUniqueInput | TeacherWorkplaceWhereUniqueInput[]
    update?: TeacherWorkplaceUpdateWithWhereUniqueWithoutSchoolInput | TeacherWorkplaceUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: TeacherWorkplaceUpdateManyWithWhereWithoutSchoolInput | TeacherWorkplaceUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: TeacherWorkplaceScalarWhereInput | TeacherWorkplaceScalarWhereInput[]
  }

  export type SchoolCreateNestedManyWithoutRegionInput = {
    create?: XOR<SchoolCreateWithoutRegionInput, SchoolUncheckedCreateWithoutRegionInput> | SchoolCreateWithoutRegionInput[] | SchoolUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutRegionInput | SchoolCreateOrConnectWithoutRegionInput[]
    createMany?: SchoolCreateManyRegionInputEnvelope
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type SchoolUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<SchoolCreateWithoutRegionInput, SchoolUncheckedCreateWithoutRegionInput> | SchoolCreateWithoutRegionInput[] | SchoolUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutRegionInput | SchoolCreateOrConnectWithoutRegionInput[]
    createMany?: SchoolCreateManyRegionInputEnvelope
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type SchoolUpdateManyWithoutRegionNestedInput = {
    create?: XOR<SchoolCreateWithoutRegionInput, SchoolUncheckedCreateWithoutRegionInput> | SchoolCreateWithoutRegionInput[] | SchoolUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutRegionInput | SchoolCreateOrConnectWithoutRegionInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutRegionInput | SchoolUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: SchoolCreateManyRegionInputEnvelope
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutRegionInput | SchoolUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutRegionInput | SchoolUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type SchoolUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<SchoolCreateWithoutRegionInput, SchoolUncheckedCreateWithoutRegionInput> | SchoolCreateWithoutRegionInput[] | SchoolUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutRegionInput | SchoolCreateOrConnectWithoutRegionInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutRegionInput | SchoolUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: SchoolCreateManyRegionInputEnvelope
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutRegionInput | SchoolUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutRegionInput | SchoolUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type ChoiceAnswerCreateNestedManyWithoutQuestionInput = {
    create?: XOR<ChoiceAnswerCreateWithoutQuestionInput, ChoiceAnswerUncheckedCreateWithoutQuestionInput> | ChoiceAnswerCreateWithoutQuestionInput[] | ChoiceAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: ChoiceAnswerCreateOrConnectWithoutQuestionInput | ChoiceAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: ChoiceAnswerCreateManyQuestionInputEnvelope
    connect?: ChoiceAnswerWhereUniqueInput | ChoiceAnswerWhereUniqueInput[]
  }

  export type ChoiceAnswerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<ChoiceAnswerCreateWithoutQuestionInput, ChoiceAnswerUncheckedCreateWithoutQuestionInput> | ChoiceAnswerCreateWithoutQuestionInput[] | ChoiceAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: ChoiceAnswerCreateOrConnectWithoutQuestionInput | ChoiceAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: ChoiceAnswerCreateManyQuestionInputEnvelope
    connect?: ChoiceAnswerWhereUniqueInput | ChoiceAnswerWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ChoiceAnswerUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<ChoiceAnswerCreateWithoutQuestionInput, ChoiceAnswerUncheckedCreateWithoutQuestionInput> | ChoiceAnswerCreateWithoutQuestionInput[] | ChoiceAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: ChoiceAnswerCreateOrConnectWithoutQuestionInput | ChoiceAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: ChoiceAnswerUpsertWithWhereUniqueWithoutQuestionInput | ChoiceAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: ChoiceAnswerCreateManyQuestionInputEnvelope
    set?: ChoiceAnswerWhereUniqueInput | ChoiceAnswerWhereUniqueInput[]
    disconnect?: ChoiceAnswerWhereUniqueInput | ChoiceAnswerWhereUniqueInput[]
    delete?: ChoiceAnswerWhereUniqueInput | ChoiceAnswerWhereUniqueInput[]
    connect?: ChoiceAnswerWhereUniqueInput | ChoiceAnswerWhereUniqueInput[]
    update?: ChoiceAnswerUpdateWithWhereUniqueWithoutQuestionInput | ChoiceAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: ChoiceAnswerUpdateManyWithWhereWithoutQuestionInput | ChoiceAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: ChoiceAnswerScalarWhereInput | ChoiceAnswerScalarWhereInput[]
  }

  export type ChoiceAnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<ChoiceAnswerCreateWithoutQuestionInput, ChoiceAnswerUncheckedCreateWithoutQuestionInput> | ChoiceAnswerCreateWithoutQuestionInput[] | ChoiceAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: ChoiceAnswerCreateOrConnectWithoutQuestionInput | ChoiceAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: ChoiceAnswerUpsertWithWhereUniqueWithoutQuestionInput | ChoiceAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: ChoiceAnswerCreateManyQuestionInputEnvelope
    set?: ChoiceAnswerWhereUniqueInput | ChoiceAnswerWhereUniqueInput[]
    disconnect?: ChoiceAnswerWhereUniqueInput | ChoiceAnswerWhereUniqueInput[]
    delete?: ChoiceAnswerWhereUniqueInput | ChoiceAnswerWhereUniqueInput[]
    connect?: ChoiceAnswerWhereUniqueInput | ChoiceAnswerWhereUniqueInput[]
    update?: ChoiceAnswerUpdateWithWhereUniqueWithoutQuestionInput | ChoiceAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: ChoiceAnswerUpdateManyWithWhereWithoutQuestionInput | ChoiceAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: ChoiceAnswerScalarWhereInput | ChoiceAnswerScalarWhereInput[]
  }

  export type ChoiceQuestionCreateNestedOneWithoutAnswersInput = {
    create?: XOR<ChoiceQuestionCreateWithoutAnswersInput, ChoiceQuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: ChoiceQuestionCreateOrConnectWithoutAnswersInput
    connect?: ChoiceQuestionWhereUniqueInput
  }

  export type ChoiceAnswerApplyCreateNestedManyWithoutAnswerInput = {
    create?: XOR<ChoiceAnswerApplyCreateWithoutAnswerInput, ChoiceAnswerApplyUncheckedCreateWithoutAnswerInput> | ChoiceAnswerApplyCreateWithoutAnswerInput[] | ChoiceAnswerApplyUncheckedCreateWithoutAnswerInput[]
    connectOrCreate?: ChoiceAnswerApplyCreateOrConnectWithoutAnswerInput | ChoiceAnswerApplyCreateOrConnectWithoutAnswerInput[]
    createMany?: ChoiceAnswerApplyCreateManyAnswerInputEnvelope
    connect?: ChoiceAnswerApplyWhereUniqueInput | ChoiceAnswerApplyWhereUniqueInput[]
  }

  export type ChoiceAnswerApplyUncheckedCreateNestedManyWithoutAnswerInput = {
    create?: XOR<ChoiceAnswerApplyCreateWithoutAnswerInput, ChoiceAnswerApplyUncheckedCreateWithoutAnswerInput> | ChoiceAnswerApplyCreateWithoutAnswerInput[] | ChoiceAnswerApplyUncheckedCreateWithoutAnswerInput[]
    connectOrCreate?: ChoiceAnswerApplyCreateOrConnectWithoutAnswerInput | ChoiceAnswerApplyCreateOrConnectWithoutAnswerInput[]
    createMany?: ChoiceAnswerApplyCreateManyAnswerInputEnvelope
    connect?: ChoiceAnswerApplyWhereUniqueInput | ChoiceAnswerApplyWhereUniqueInput[]
  }

  export type ChoiceQuestionUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<ChoiceQuestionCreateWithoutAnswersInput, ChoiceQuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: ChoiceQuestionCreateOrConnectWithoutAnswersInput
    upsert?: ChoiceQuestionUpsertWithoutAnswersInput
    connect?: ChoiceQuestionWhereUniqueInput
    update?: XOR<XOR<ChoiceQuestionUpdateToOneWithWhereWithoutAnswersInput, ChoiceQuestionUpdateWithoutAnswersInput>, ChoiceQuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type ChoiceAnswerApplyUpdateManyWithoutAnswerNestedInput = {
    create?: XOR<ChoiceAnswerApplyCreateWithoutAnswerInput, ChoiceAnswerApplyUncheckedCreateWithoutAnswerInput> | ChoiceAnswerApplyCreateWithoutAnswerInput[] | ChoiceAnswerApplyUncheckedCreateWithoutAnswerInput[]
    connectOrCreate?: ChoiceAnswerApplyCreateOrConnectWithoutAnswerInput | ChoiceAnswerApplyCreateOrConnectWithoutAnswerInput[]
    upsert?: ChoiceAnswerApplyUpsertWithWhereUniqueWithoutAnswerInput | ChoiceAnswerApplyUpsertWithWhereUniqueWithoutAnswerInput[]
    createMany?: ChoiceAnswerApplyCreateManyAnswerInputEnvelope
    set?: ChoiceAnswerApplyWhereUniqueInput | ChoiceAnswerApplyWhereUniqueInput[]
    disconnect?: ChoiceAnswerApplyWhereUniqueInput | ChoiceAnswerApplyWhereUniqueInput[]
    delete?: ChoiceAnswerApplyWhereUniqueInput | ChoiceAnswerApplyWhereUniqueInput[]
    connect?: ChoiceAnswerApplyWhereUniqueInput | ChoiceAnswerApplyWhereUniqueInput[]
    update?: ChoiceAnswerApplyUpdateWithWhereUniqueWithoutAnswerInput | ChoiceAnswerApplyUpdateWithWhereUniqueWithoutAnswerInput[]
    updateMany?: ChoiceAnswerApplyUpdateManyWithWhereWithoutAnswerInput | ChoiceAnswerApplyUpdateManyWithWhereWithoutAnswerInput[]
    deleteMany?: ChoiceAnswerApplyScalarWhereInput | ChoiceAnswerApplyScalarWhereInput[]
  }

  export type ChoiceAnswerApplyUncheckedUpdateManyWithoutAnswerNestedInput = {
    create?: XOR<ChoiceAnswerApplyCreateWithoutAnswerInput, ChoiceAnswerApplyUncheckedCreateWithoutAnswerInput> | ChoiceAnswerApplyCreateWithoutAnswerInput[] | ChoiceAnswerApplyUncheckedCreateWithoutAnswerInput[]
    connectOrCreate?: ChoiceAnswerApplyCreateOrConnectWithoutAnswerInput | ChoiceAnswerApplyCreateOrConnectWithoutAnswerInput[]
    upsert?: ChoiceAnswerApplyUpsertWithWhereUniqueWithoutAnswerInput | ChoiceAnswerApplyUpsertWithWhereUniqueWithoutAnswerInput[]
    createMany?: ChoiceAnswerApplyCreateManyAnswerInputEnvelope
    set?: ChoiceAnswerApplyWhereUniqueInput | ChoiceAnswerApplyWhereUniqueInput[]
    disconnect?: ChoiceAnswerApplyWhereUniqueInput | ChoiceAnswerApplyWhereUniqueInput[]
    delete?: ChoiceAnswerApplyWhereUniqueInput | ChoiceAnswerApplyWhereUniqueInput[]
    connect?: ChoiceAnswerApplyWhereUniqueInput | ChoiceAnswerApplyWhereUniqueInput[]
    update?: ChoiceAnswerApplyUpdateWithWhereUniqueWithoutAnswerInput | ChoiceAnswerApplyUpdateWithWhereUniqueWithoutAnswerInput[]
    updateMany?: ChoiceAnswerApplyUpdateManyWithWhereWithoutAnswerInput | ChoiceAnswerApplyUpdateManyWithWhereWithoutAnswerInput[]
    deleteMany?: ChoiceAnswerApplyScalarWhereInput | ChoiceAnswerApplyScalarWhereInput[]
  }

  export type TeacherCreateNestedOneWithoutChoice_answer_applysInput = {
    create?: XOR<TeacherCreateWithoutChoice_answer_applysInput, TeacherUncheckedCreateWithoutChoice_answer_applysInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutChoice_answer_applysInput
    connect?: TeacherWhereUniqueInput
  }

  export type ChoiceAnswerCreateNestedOneWithoutChoice_answer_applysInput = {
    create?: XOR<ChoiceAnswerCreateWithoutChoice_answer_applysInput, ChoiceAnswerUncheckedCreateWithoutChoice_answer_applysInput>
    connectOrCreate?: ChoiceAnswerCreateOrConnectWithoutChoice_answer_applysInput
    connect?: ChoiceAnswerWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type TeacherUpdateOneRequiredWithoutChoice_answer_applysNestedInput = {
    create?: XOR<TeacherCreateWithoutChoice_answer_applysInput, TeacherUncheckedCreateWithoutChoice_answer_applysInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutChoice_answer_applysInput
    upsert?: TeacherUpsertWithoutChoice_answer_applysInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutChoice_answer_applysInput, TeacherUpdateWithoutChoice_answer_applysInput>, TeacherUncheckedUpdateWithoutChoice_answer_applysInput>
  }

  export type ChoiceAnswerUpdateOneRequiredWithoutChoice_answer_applysNestedInput = {
    create?: XOR<ChoiceAnswerCreateWithoutChoice_answer_applysInput, ChoiceAnswerUncheckedCreateWithoutChoice_answer_applysInput>
    connectOrCreate?: ChoiceAnswerCreateOrConnectWithoutChoice_answer_applysInput
    upsert?: ChoiceAnswerUpsertWithoutChoice_answer_applysInput
    connect?: ChoiceAnswerWhereUniqueInput
    update?: XOR<XOR<ChoiceAnswerUpdateToOneWithWhereWithoutChoice_answer_applysInput, ChoiceAnswerUpdateWithoutChoice_answer_applysInput>, ChoiceAnswerUncheckedUpdateWithoutChoice_answer_applysInput>
  }

  export type WriteQuestionApplyCreateNestedManyWithoutQuestionInput = {
    create?: XOR<WriteQuestionApplyCreateWithoutQuestionInput, WriteQuestionApplyUncheckedCreateWithoutQuestionInput> | WriteQuestionApplyCreateWithoutQuestionInput[] | WriteQuestionApplyUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: WriteQuestionApplyCreateOrConnectWithoutQuestionInput | WriteQuestionApplyCreateOrConnectWithoutQuestionInput[]
    createMany?: WriteQuestionApplyCreateManyQuestionInputEnvelope
    connect?: WriteQuestionApplyWhereUniqueInput | WriteQuestionApplyWhereUniqueInput[]
  }

  export type WriteQuestionApplyUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<WriteQuestionApplyCreateWithoutQuestionInput, WriteQuestionApplyUncheckedCreateWithoutQuestionInput> | WriteQuestionApplyCreateWithoutQuestionInput[] | WriteQuestionApplyUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: WriteQuestionApplyCreateOrConnectWithoutQuestionInput | WriteQuestionApplyCreateOrConnectWithoutQuestionInput[]
    createMany?: WriteQuestionApplyCreateManyQuestionInputEnvelope
    connect?: WriteQuestionApplyWhereUniqueInput | WriteQuestionApplyWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type WriteQuestionApplyUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<WriteQuestionApplyCreateWithoutQuestionInput, WriteQuestionApplyUncheckedCreateWithoutQuestionInput> | WriteQuestionApplyCreateWithoutQuestionInput[] | WriteQuestionApplyUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: WriteQuestionApplyCreateOrConnectWithoutQuestionInput | WriteQuestionApplyCreateOrConnectWithoutQuestionInput[]
    upsert?: WriteQuestionApplyUpsertWithWhereUniqueWithoutQuestionInput | WriteQuestionApplyUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: WriteQuestionApplyCreateManyQuestionInputEnvelope
    set?: WriteQuestionApplyWhereUniqueInput | WriteQuestionApplyWhereUniqueInput[]
    disconnect?: WriteQuestionApplyWhereUniqueInput | WriteQuestionApplyWhereUniqueInput[]
    delete?: WriteQuestionApplyWhereUniqueInput | WriteQuestionApplyWhereUniqueInput[]
    connect?: WriteQuestionApplyWhereUniqueInput | WriteQuestionApplyWhereUniqueInput[]
    update?: WriteQuestionApplyUpdateWithWhereUniqueWithoutQuestionInput | WriteQuestionApplyUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: WriteQuestionApplyUpdateManyWithWhereWithoutQuestionInput | WriteQuestionApplyUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: WriteQuestionApplyScalarWhereInput | WriteQuestionApplyScalarWhereInput[]
  }

  export type WriteQuestionApplyUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<WriteQuestionApplyCreateWithoutQuestionInput, WriteQuestionApplyUncheckedCreateWithoutQuestionInput> | WriteQuestionApplyCreateWithoutQuestionInput[] | WriteQuestionApplyUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: WriteQuestionApplyCreateOrConnectWithoutQuestionInput | WriteQuestionApplyCreateOrConnectWithoutQuestionInput[]
    upsert?: WriteQuestionApplyUpsertWithWhereUniqueWithoutQuestionInput | WriteQuestionApplyUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: WriteQuestionApplyCreateManyQuestionInputEnvelope
    set?: WriteQuestionApplyWhereUniqueInput | WriteQuestionApplyWhereUniqueInput[]
    disconnect?: WriteQuestionApplyWhereUniqueInput | WriteQuestionApplyWhereUniqueInput[]
    delete?: WriteQuestionApplyWhereUniqueInput | WriteQuestionApplyWhereUniqueInput[]
    connect?: WriteQuestionApplyWhereUniqueInput | WriteQuestionApplyWhereUniqueInput[]
    update?: WriteQuestionApplyUpdateWithWhereUniqueWithoutQuestionInput | WriteQuestionApplyUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: WriteQuestionApplyUpdateManyWithWhereWithoutQuestionInput | WriteQuestionApplyUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: WriteQuestionApplyScalarWhereInput | WriteQuestionApplyScalarWhereInput[]
  }

  export type WriteQuestionCreateNestedOneWithoutQuestion_applysInput = {
    create?: XOR<WriteQuestionCreateWithoutQuestion_applysInput, WriteQuestionUncheckedCreateWithoutQuestion_applysInput>
    connectOrCreate?: WriteQuestionCreateOrConnectWithoutQuestion_applysInput
    connect?: WriteQuestionWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutWrite_question_applysInput = {
    create?: XOR<TeacherCreateWithoutWrite_question_applysInput, TeacherUncheckedCreateWithoutWrite_question_applysInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutWrite_question_applysInput
    connect?: TeacherWhereUniqueInput
  }

  export type WriteQuestionUpdateOneRequiredWithoutQuestion_applysNestedInput = {
    create?: XOR<WriteQuestionCreateWithoutQuestion_applysInput, WriteQuestionUncheckedCreateWithoutQuestion_applysInput>
    connectOrCreate?: WriteQuestionCreateOrConnectWithoutQuestion_applysInput
    upsert?: WriteQuestionUpsertWithoutQuestion_applysInput
    connect?: WriteQuestionWhereUniqueInput
    update?: XOR<XOR<WriteQuestionUpdateToOneWithWhereWithoutQuestion_applysInput, WriteQuestionUpdateWithoutQuestion_applysInput>, WriteQuestionUncheckedUpdateWithoutQuestion_applysInput>
  }

  export type TeacherUpdateOneRequiredWithoutWrite_question_applysNestedInput = {
    create?: XOR<TeacherCreateWithoutWrite_question_applysInput, TeacherUncheckedCreateWithoutWrite_question_applysInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutWrite_question_applysInput
    upsert?: TeacherUpsertWithoutWrite_question_applysInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutWrite_question_applysInput, TeacherUpdateWithoutWrite_question_applysInput>, TeacherUncheckedUpdateWithoutWrite_question_applysInput>
  }

  export type TrainingApplyCreateNestedManyWithoutTrainInput = {
    create?: XOR<TrainingApplyCreateWithoutTrainInput, TrainingApplyUncheckedCreateWithoutTrainInput> | TrainingApplyCreateWithoutTrainInput[] | TrainingApplyUncheckedCreateWithoutTrainInput[]
    connectOrCreate?: TrainingApplyCreateOrConnectWithoutTrainInput | TrainingApplyCreateOrConnectWithoutTrainInput[]
    createMany?: TrainingApplyCreateManyTrainInputEnvelope
    connect?: TrainingApplyWhereUniqueInput | TrainingApplyWhereUniqueInput[]
  }

  export type TrainingApplyUncheckedCreateNestedManyWithoutTrainInput = {
    create?: XOR<TrainingApplyCreateWithoutTrainInput, TrainingApplyUncheckedCreateWithoutTrainInput> | TrainingApplyCreateWithoutTrainInput[] | TrainingApplyUncheckedCreateWithoutTrainInput[]
    connectOrCreate?: TrainingApplyCreateOrConnectWithoutTrainInput | TrainingApplyCreateOrConnectWithoutTrainInput[]
    createMany?: TrainingApplyCreateManyTrainInputEnvelope
    connect?: TrainingApplyWhereUniqueInput | TrainingApplyWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TrainingApplyUpdateManyWithoutTrainNestedInput = {
    create?: XOR<TrainingApplyCreateWithoutTrainInput, TrainingApplyUncheckedCreateWithoutTrainInput> | TrainingApplyCreateWithoutTrainInput[] | TrainingApplyUncheckedCreateWithoutTrainInput[]
    connectOrCreate?: TrainingApplyCreateOrConnectWithoutTrainInput | TrainingApplyCreateOrConnectWithoutTrainInput[]
    upsert?: TrainingApplyUpsertWithWhereUniqueWithoutTrainInput | TrainingApplyUpsertWithWhereUniqueWithoutTrainInput[]
    createMany?: TrainingApplyCreateManyTrainInputEnvelope
    set?: TrainingApplyWhereUniqueInput | TrainingApplyWhereUniqueInput[]
    disconnect?: TrainingApplyWhereUniqueInput | TrainingApplyWhereUniqueInput[]
    delete?: TrainingApplyWhereUniqueInput | TrainingApplyWhereUniqueInput[]
    connect?: TrainingApplyWhereUniqueInput | TrainingApplyWhereUniqueInput[]
    update?: TrainingApplyUpdateWithWhereUniqueWithoutTrainInput | TrainingApplyUpdateWithWhereUniqueWithoutTrainInput[]
    updateMany?: TrainingApplyUpdateManyWithWhereWithoutTrainInput | TrainingApplyUpdateManyWithWhereWithoutTrainInput[]
    deleteMany?: TrainingApplyScalarWhereInput | TrainingApplyScalarWhereInput[]
  }

  export type TrainingApplyUncheckedUpdateManyWithoutTrainNestedInput = {
    create?: XOR<TrainingApplyCreateWithoutTrainInput, TrainingApplyUncheckedCreateWithoutTrainInput> | TrainingApplyCreateWithoutTrainInput[] | TrainingApplyUncheckedCreateWithoutTrainInput[]
    connectOrCreate?: TrainingApplyCreateOrConnectWithoutTrainInput | TrainingApplyCreateOrConnectWithoutTrainInput[]
    upsert?: TrainingApplyUpsertWithWhereUniqueWithoutTrainInput | TrainingApplyUpsertWithWhereUniqueWithoutTrainInput[]
    createMany?: TrainingApplyCreateManyTrainInputEnvelope
    set?: TrainingApplyWhereUniqueInput | TrainingApplyWhereUniqueInput[]
    disconnect?: TrainingApplyWhereUniqueInput | TrainingApplyWhereUniqueInput[]
    delete?: TrainingApplyWhereUniqueInput | TrainingApplyWhereUniqueInput[]
    connect?: TrainingApplyWhereUniqueInput | TrainingApplyWhereUniqueInput[]
    update?: TrainingApplyUpdateWithWhereUniqueWithoutTrainInput | TrainingApplyUpdateWithWhereUniqueWithoutTrainInput[]
    updateMany?: TrainingApplyUpdateManyWithWhereWithoutTrainInput | TrainingApplyUpdateManyWithWhereWithoutTrainInput[]
    deleteMany?: TrainingApplyScalarWhereInput | TrainingApplyScalarWhereInput[]
  }

  export type TrainingCreateNestedOneWithoutTraining_applysInput = {
    create?: XOR<TrainingCreateWithoutTraining_applysInput, TrainingUncheckedCreateWithoutTraining_applysInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutTraining_applysInput
    connect?: TrainingWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutTeacher_training_applysInput = {
    create?: XOR<TeacherCreateWithoutTeacher_training_applysInput, TeacherUncheckedCreateWithoutTeacher_training_applysInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutTeacher_training_applysInput
    connect?: TeacherWhereUniqueInput
  }

  export type CheckTrainingApplyCreateNestedManyWithoutTraining_applyInput = {
    create?: XOR<CheckTrainingApplyCreateWithoutTraining_applyInput, CheckTrainingApplyUncheckedCreateWithoutTraining_applyInput> | CheckTrainingApplyCreateWithoutTraining_applyInput[] | CheckTrainingApplyUncheckedCreateWithoutTraining_applyInput[]
    connectOrCreate?: CheckTrainingApplyCreateOrConnectWithoutTraining_applyInput | CheckTrainingApplyCreateOrConnectWithoutTraining_applyInput[]
    createMany?: CheckTrainingApplyCreateManyTraining_applyInputEnvelope
    connect?: CheckTrainingApplyWhereUniqueInput | CheckTrainingApplyWhereUniqueInput[]
  }

  export type CheckTrainingApplyUncheckedCreateNestedManyWithoutTraining_applyInput = {
    create?: XOR<CheckTrainingApplyCreateWithoutTraining_applyInput, CheckTrainingApplyUncheckedCreateWithoutTraining_applyInput> | CheckTrainingApplyCreateWithoutTraining_applyInput[] | CheckTrainingApplyUncheckedCreateWithoutTraining_applyInput[]
    connectOrCreate?: CheckTrainingApplyCreateOrConnectWithoutTraining_applyInput | CheckTrainingApplyCreateOrConnectWithoutTraining_applyInput[]
    createMany?: CheckTrainingApplyCreateManyTraining_applyInputEnvelope
    connect?: CheckTrainingApplyWhereUniqueInput | CheckTrainingApplyWhereUniqueInput[]
  }

  export type TrainingUpdateOneRequiredWithoutTraining_applysNestedInput = {
    create?: XOR<TrainingCreateWithoutTraining_applysInput, TrainingUncheckedCreateWithoutTraining_applysInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutTraining_applysInput
    upsert?: TrainingUpsertWithoutTraining_applysInput
    connect?: TrainingWhereUniqueInput
    update?: XOR<XOR<TrainingUpdateToOneWithWhereWithoutTraining_applysInput, TrainingUpdateWithoutTraining_applysInput>, TrainingUncheckedUpdateWithoutTraining_applysInput>
  }

  export type TeacherUpdateOneRequiredWithoutTeacher_training_applysNestedInput = {
    create?: XOR<TeacherCreateWithoutTeacher_training_applysInput, TeacherUncheckedCreateWithoutTeacher_training_applysInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutTeacher_training_applysInput
    upsert?: TeacherUpsertWithoutTeacher_training_applysInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutTeacher_training_applysInput, TeacherUpdateWithoutTeacher_training_applysInput>, TeacherUncheckedUpdateWithoutTeacher_training_applysInput>
  }

  export type CheckTrainingApplyUpdateManyWithoutTraining_applyNestedInput = {
    create?: XOR<CheckTrainingApplyCreateWithoutTraining_applyInput, CheckTrainingApplyUncheckedCreateWithoutTraining_applyInput> | CheckTrainingApplyCreateWithoutTraining_applyInput[] | CheckTrainingApplyUncheckedCreateWithoutTraining_applyInput[]
    connectOrCreate?: CheckTrainingApplyCreateOrConnectWithoutTraining_applyInput | CheckTrainingApplyCreateOrConnectWithoutTraining_applyInput[]
    upsert?: CheckTrainingApplyUpsertWithWhereUniqueWithoutTraining_applyInput | CheckTrainingApplyUpsertWithWhereUniqueWithoutTraining_applyInput[]
    createMany?: CheckTrainingApplyCreateManyTraining_applyInputEnvelope
    set?: CheckTrainingApplyWhereUniqueInput | CheckTrainingApplyWhereUniqueInput[]
    disconnect?: CheckTrainingApplyWhereUniqueInput | CheckTrainingApplyWhereUniqueInput[]
    delete?: CheckTrainingApplyWhereUniqueInput | CheckTrainingApplyWhereUniqueInput[]
    connect?: CheckTrainingApplyWhereUniqueInput | CheckTrainingApplyWhereUniqueInput[]
    update?: CheckTrainingApplyUpdateWithWhereUniqueWithoutTraining_applyInput | CheckTrainingApplyUpdateWithWhereUniqueWithoutTraining_applyInput[]
    updateMany?: CheckTrainingApplyUpdateManyWithWhereWithoutTraining_applyInput | CheckTrainingApplyUpdateManyWithWhereWithoutTraining_applyInput[]
    deleteMany?: CheckTrainingApplyScalarWhereInput | CheckTrainingApplyScalarWhereInput[]
  }

  export type CheckTrainingApplyUncheckedUpdateManyWithoutTraining_applyNestedInput = {
    create?: XOR<CheckTrainingApplyCreateWithoutTraining_applyInput, CheckTrainingApplyUncheckedCreateWithoutTraining_applyInput> | CheckTrainingApplyCreateWithoutTraining_applyInput[] | CheckTrainingApplyUncheckedCreateWithoutTraining_applyInput[]
    connectOrCreate?: CheckTrainingApplyCreateOrConnectWithoutTraining_applyInput | CheckTrainingApplyCreateOrConnectWithoutTraining_applyInput[]
    upsert?: CheckTrainingApplyUpsertWithWhereUniqueWithoutTraining_applyInput | CheckTrainingApplyUpsertWithWhereUniqueWithoutTraining_applyInput[]
    createMany?: CheckTrainingApplyCreateManyTraining_applyInputEnvelope
    set?: CheckTrainingApplyWhereUniqueInput | CheckTrainingApplyWhereUniqueInput[]
    disconnect?: CheckTrainingApplyWhereUniqueInput | CheckTrainingApplyWhereUniqueInput[]
    delete?: CheckTrainingApplyWhereUniqueInput | CheckTrainingApplyWhereUniqueInput[]
    connect?: CheckTrainingApplyWhereUniqueInput | CheckTrainingApplyWhereUniqueInput[]
    update?: CheckTrainingApplyUpdateWithWhereUniqueWithoutTraining_applyInput | CheckTrainingApplyUpdateWithWhereUniqueWithoutTraining_applyInput[]
    updateMany?: CheckTrainingApplyUpdateManyWithWhereWithoutTraining_applyInput | CheckTrainingApplyUpdateManyWithWhereWithoutTraining_applyInput[]
    deleteMany?: CheckTrainingApplyScalarWhereInput | CheckTrainingApplyScalarWhereInput[]
  }

  export type TrainingApplyCreateNestedOneWithoutChecking_applysInput = {
    create?: XOR<TrainingApplyCreateWithoutChecking_applysInput, TrainingApplyUncheckedCreateWithoutChecking_applysInput>
    connectOrCreate?: TrainingApplyCreateOrConnectWithoutChecking_applysInput
    connect?: TrainingApplyWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TrainingApplyUpdateOneRequiredWithoutChecking_applysNestedInput = {
    create?: XOR<TrainingApplyCreateWithoutChecking_applysInput, TrainingApplyUncheckedCreateWithoutChecking_applysInput>
    connectOrCreate?: TrainingApplyCreateOrConnectWithoutChecking_applysInput
    upsert?: TrainingApplyUpsertWithoutChecking_applysInput
    connect?: TrainingApplyWhereUniqueInput
    update?: XOR<XOR<TrainingApplyUpdateToOneWithWhereWithoutChecking_applysInput, TrainingApplyUpdateWithoutChecking_applysInput>, TrainingApplyUncheckedUpdateWithoutChecking_applysInput>
  }

  export type TaskCreateNestedManyWithoutLessonInput = {
    create?: XOR<TaskCreateWithoutLessonInput, TaskUncheckedCreateWithoutLessonInput> | TaskCreateWithoutLessonInput[] | TaskUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutLessonInput | TaskCreateOrConnectWithoutLessonInput[]
    createMany?: TaskCreateManyLessonInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<TaskCreateWithoutLessonInput, TaskUncheckedCreateWithoutLessonInput> | TaskCreateWithoutLessonInput[] | TaskUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutLessonInput | TaskCreateOrConnectWithoutLessonInput[]
    createMany?: TaskCreateManyLessonInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUpdateManyWithoutLessonNestedInput = {
    create?: XOR<TaskCreateWithoutLessonInput, TaskUncheckedCreateWithoutLessonInput> | TaskCreateWithoutLessonInput[] | TaskUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutLessonInput | TaskCreateOrConnectWithoutLessonInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutLessonInput | TaskUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: TaskCreateManyLessonInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutLessonInput | TaskUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutLessonInput | TaskUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<TaskCreateWithoutLessonInput, TaskUncheckedCreateWithoutLessonInput> | TaskCreateWithoutLessonInput[] | TaskUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutLessonInput | TaskCreateOrConnectWithoutLessonInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutLessonInput | TaskUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: TaskCreateManyLessonInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutLessonInput | TaskUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutLessonInput | TaskUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type LessonCreateNestedOneWithoutTasksInput = {
    create?: XOR<LessonCreateWithoutTasksInput, LessonUncheckedCreateWithoutTasksInput>
    connectOrCreate?: LessonCreateOrConnectWithoutTasksInput
    connect?: LessonWhereUniqueInput
  }

  export type TaskCriteriaCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskCriteriaCreateWithoutTaskInput, TaskCriteriaUncheckedCreateWithoutTaskInput> | TaskCriteriaCreateWithoutTaskInput[] | TaskCriteriaUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCriteriaCreateOrConnectWithoutTaskInput | TaskCriteriaCreateOrConnectWithoutTaskInput[]
    createMany?: TaskCriteriaCreateManyTaskInputEnvelope
    connect?: TaskCriteriaWhereUniqueInput | TaskCriteriaWhereUniqueInput[]
  }

  export type TaskApplyCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskApplyCreateWithoutTaskInput, TaskApplyUncheckedCreateWithoutTaskInput> | TaskApplyCreateWithoutTaskInput[] | TaskApplyUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskApplyCreateOrConnectWithoutTaskInput | TaskApplyCreateOrConnectWithoutTaskInput[]
    createMany?: TaskApplyCreateManyTaskInputEnvelope
    connect?: TaskApplyWhereUniqueInput | TaskApplyWhereUniqueInput[]
  }

  export type TaskCriteriaUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskCriteriaCreateWithoutTaskInput, TaskCriteriaUncheckedCreateWithoutTaskInput> | TaskCriteriaCreateWithoutTaskInput[] | TaskCriteriaUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCriteriaCreateOrConnectWithoutTaskInput | TaskCriteriaCreateOrConnectWithoutTaskInput[]
    createMany?: TaskCriteriaCreateManyTaskInputEnvelope
    connect?: TaskCriteriaWhereUniqueInput | TaskCriteriaWhereUniqueInput[]
  }

  export type TaskApplyUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskApplyCreateWithoutTaskInput, TaskApplyUncheckedCreateWithoutTaskInput> | TaskApplyCreateWithoutTaskInput[] | TaskApplyUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskApplyCreateOrConnectWithoutTaskInput | TaskApplyCreateOrConnectWithoutTaskInput[]
    createMany?: TaskApplyCreateManyTaskInputEnvelope
    connect?: TaskApplyWhereUniqueInput | TaskApplyWhereUniqueInput[]
  }

  export type LessonUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<LessonCreateWithoutTasksInput, LessonUncheckedCreateWithoutTasksInput>
    connectOrCreate?: LessonCreateOrConnectWithoutTasksInput
    upsert?: LessonUpsertWithoutTasksInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutTasksInput, LessonUpdateWithoutTasksInput>, LessonUncheckedUpdateWithoutTasksInput>
  }

  export type TaskCriteriaUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskCriteriaCreateWithoutTaskInput, TaskCriteriaUncheckedCreateWithoutTaskInput> | TaskCriteriaCreateWithoutTaskInput[] | TaskCriteriaUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCriteriaCreateOrConnectWithoutTaskInput | TaskCriteriaCreateOrConnectWithoutTaskInput[]
    upsert?: TaskCriteriaUpsertWithWhereUniqueWithoutTaskInput | TaskCriteriaUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskCriteriaCreateManyTaskInputEnvelope
    set?: TaskCriteriaWhereUniqueInput | TaskCriteriaWhereUniqueInput[]
    disconnect?: TaskCriteriaWhereUniqueInput | TaskCriteriaWhereUniqueInput[]
    delete?: TaskCriteriaWhereUniqueInput | TaskCriteriaWhereUniqueInput[]
    connect?: TaskCriteriaWhereUniqueInput | TaskCriteriaWhereUniqueInput[]
    update?: TaskCriteriaUpdateWithWhereUniqueWithoutTaskInput | TaskCriteriaUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskCriteriaUpdateManyWithWhereWithoutTaskInput | TaskCriteriaUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskCriteriaScalarWhereInput | TaskCriteriaScalarWhereInput[]
  }

  export type TaskApplyUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskApplyCreateWithoutTaskInput, TaskApplyUncheckedCreateWithoutTaskInput> | TaskApplyCreateWithoutTaskInput[] | TaskApplyUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskApplyCreateOrConnectWithoutTaskInput | TaskApplyCreateOrConnectWithoutTaskInput[]
    upsert?: TaskApplyUpsertWithWhereUniqueWithoutTaskInput | TaskApplyUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskApplyCreateManyTaskInputEnvelope
    set?: TaskApplyWhereUniqueInput | TaskApplyWhereUniqueInput[]
    disconnect?: TaskApplyWhereUniqueInput | TaskApplyWhereUniqueInput[]
    delete?: TaskApplyWhereUniqueInput | TaskApplyWhereUniqueInput[]
    connect?: TaskApplyWhereUniqueInput | TaskApplyWhereUniqueInput[]
    update?: TaskApplyUpdateWithWhereUniqueWithoutTaskInput | TaskApplyUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskApplyUpdateManyWithWhereWithoutTaskInput | TaskApplyUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskApplyScalarWhereInput | TaskApplyScalarWhereInput[]
  }

  export type TaskCriteriaUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskCriteriaCreateWithoutTaskInput, TaskCriteriaUncheckedCreateWithoutTaskInput> | TaskCriteriaCreateWithoutTaskInput[] | TaskCriteriaUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCriteriaCreateOrConnectWithoutTaskInput | TaskCriteriaCreateOrConnectWithoutTaskInput[]
    upsert?: TaskCriteriaUpsertWithWhereUniqueWithoutTaskInput | TaskCriteriaUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskCriteriaCreateManyTaskInputEnvelope
    set?: TaskCriteriaWhereUniqueInput | TaskCriteriaWhereUniqueInput[]
    disconnect?: TaskCriteriaWhereUniqueInput | TaskCriteriaWhereUniqueInput[]
    delete?: TaskCriteriaWhereUniqueInput | TaskCriteriaWhereUniqueInput[]
    connect?: TaskCriteriaWhereUniqueInput | TaskCriteriaWhereUniqueInput[]
    update?: TaskCriteriaUpdateWithWhereUniqueWithoutTaskInput | TaskCriteriaUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskCriteriaUpdateManyWithWhereWithoutTaskInput | TaskCriteriaUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskCriteriaScalarWhereInput | TaskCriteriaScalarWhereInput[]
  }

  export type TaskApplyUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskApplyCreateWithoutTaskInput, TaskApplyUncheckedCreateWithoutTaskInput> | TaskApplyCreateWithoutTaskInput[] | TaskApplyUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskApplyCreateOrConnectWithoutTaskInput | TaskApplyCreateOrConnectWithoutTaskInput[]
    upsert?: TaskApplyUpsertWithWhereUniqueWithoutTaskInput | TaskApplyUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskApplyCreateManyTaskInputEnvelope
    set?: TaskApplyWhereUniqueInput | TaskApplyWhereUniqueInput[]
    disconnect?: TaskApplyWhereUniqueInput | TaskApplyWhereUniqueInput[]
    delete?: TaskApplyWhereUniqueInput | TaskApplyWhereUniqueInput[]
    connect?: TaskApplyWhereUniqueInput | TaskApplyWhereUniqueInput[]
    update?: TaskApplyUpdateWithWhereUniqueWithoutTaskInput | TaskApplyUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskApplyUpdateManyWithWhereWithoutTaskInput | TaskApplyUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskApplyScalarWhereInput | TaskApplyScalarWhereInput[]
  }

  export type TaskCreateNestedOneWithoutCriteriasInput = {
    create?: XOR<TaskCreateWithoutCriteriasInput, TaskUncheckedCreateWithoutCriteriasInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCriteriasInput
    connect?: TaskWhereUniqueInput
  }

  export type CheckWithTaskCriteriasCreateNestedManyWithoutTask_criteriaInput = {
    create?: XOR<CheckWithTaskCriteriasCreateWithoutTask_criteriaInput, CheckWithTaskCriteriasUncheckedCreateWithoutTask_criteriaInput> | CheckWithTaskCriteriasCreateWithoutTask_criteriaInput[] | CheckWithTaskCriteriasUncheckedCreateWithoutTask_criteriaInput[]
    connectOrCreate?: CheckWithTaskCriteriasCreateOrConnectWithoutTask_criteriaInput | CheckWithTaskCriteriasCreateOrConnectWithoutTask_criteriaInput[]
    createMany?: CheckWithTaskCriteriasCreateManyTask_criteriaInputEnvelope
    connect?: CheckWithTaskCriteriasWhereUniqueInput | CheckWithTaskCriteriasWhereUniqueInput[]
  }

  export type CheckWithTaskCriteriasUncheckedCreateNestedManyWithoutTask_criteriaInput = {
    create?: XOR<CheckWithTaskCriteriasCreateWithoutTask_criteriaInput, CheckWithTaskCriteriasUncheckedCreateWithoutTask_criteriaInput> | CheckWithTaskCriteriasCreateWithoutTask_criteriaInput[] | CheckWithTaskCriteriasUncheckedCreateWithoutTask_criteriaInput[]
    connectOrCreate?: CheckWithTaskCriteriasCreateOrConnectWithoutTask_criteriaInput | CheckWithTaskCriteriasCreateOrConnectWithoutTask_criteriaInput[]
    createMany?: CheckWithTaskCriteriasCreateManyTask_criteriaInputEnvelope
    connect?: CheckWithTaskCriteriasWhereUniqueInput | CheckWithTaskCriteriasWhereUniqueInput[]
  }

  export type TaskUpdateOneRequiredWithoutCriteriasNestedInput = {
    create?: XOR<TaskCreateWithoutCriteriasInput, TaskUncheckedCreateWithoutCriteriasInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCriteriasInput
    upsert?: TaskUpsertWithoutCriteriasInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutCriteriasInput, TaskUpdateWithoutCriteriasInput>, TaskUncheckedUpdateWithoutCriteriasInput>
  }

  export type CheckWithTaskCriteriasUpdateManyWithoutTask_criteriaNestedInput = {
    create?: XOR<CheckWithTaskCriteriasCreateWithoutTask_criteriaInput, CheckWithTaskCriteriasUncheckedCreateWithoutTask_criteriaInput> | CheckWithTaskCriteriasCreateWithoutTask_criteriaInput[] | CheckWithTaskCriteriasUncheckedCreateWithoutTask_criteriaInput[]
    connectOrCreate?: CheckWithTaskCriteriasCreateOrConnectWithoutTask_criteriaInput | CheckWithTaskCriteriasCreateOrConnectWithoutTask_criteriaInput[]
    upsert?: CheckWithTaskCriteriasUpsertWithWhereUniqueWithoutTask_criteriaInput | CheckWithTaskCriteriasUpsertWithWhereUniqueWithoutTask_criteriaInput[]
    createMany?: CheckWithTaskCriteriasCreateManyTask_criteriaInputEnvelope
    set?: CheckWithTaskCriteriasWhereUniqueInput | CheckWithTaskCriteriasWhereUniqueInput[]
    disconnect?: CheckWithTaskCriteriasWhereUniqueInput | CheckWithTaskCriteriasWhereUniqueInput[]
    delete?: CheckWithTaskCriteriasWhereUniqueInput | CheckWithTaskCriteriasWhereUniqueInput[]
    connect?: CheckWithTaskCriteriasWhereUniqueInput | CheckWithTaskCriteriasWhereUniqueInput[]
    update?: CheckWithTaskCriteriasUpdateWithWhereUniqueWithoutTask_criteriaInput | CheckWithTaskCriteriasUpdateWithWhereUniqueWithoutTask_criteriaInput[]
    updateMany?: CheckWithTaskCriteriasUpdateManyWithWhereWithoutTask_criteriaInput | CheckWithTaskCriteriasUpdateManyWithWhereWithoutTask_criteriaInput[]
    deleteMany?: CheckWithTaskCriteriasScalarWhereInput | CheckWithTaskCriteriasScalarWhereInput[]
  }

  export type CheckWithTaskCriteriasUncheckedUpdateManyWithoutTask_criteriaNestedInput = {
    create?: XOR<CheckWithTaskCriteriasCreateWithoutTask_criteriaInput, CheckWithTaskCriteriasUncheckedCreateWithoutTask_criteriaInput> | CheckWithTaskCriteriasCreateWithoutTask_criteriaInput[] | CheckWithTaskCriteriasUncheckedCreateWithoutTask_criteriaInput[]
    connectOrCreate?: CheckWithTaskCriteriasCreateOrConnectWithoutTask_criteriaInput | CheckWithTaskCriteriasCreateOrConnectWithoutTask_criteriaInput[]
    upsert?: CheckWithTaskCriteriasUpsertWithWhereUniqueWithoutTask_criteriaInput | CheckWithTaskCriteriasUpsertWithWhereUniqueWithoutTask_criteriaInput[]
    createMany?: CheckWithTaskCriteriasCreateManyTask_criteriaInputEnvelope
    set?: CheckWithTaskCriteriasWhereUniqueInput | CheckWithTaskCriteriasWhereUniqueInput[]
    disconnect?: CheckWithTaskCriteriasWhereUniqueInput | CheckWithTaskCriteriasWhereUniqueInput[]
    delete?: CheckWithTaskCriteriasWhereUniqueInput | CheckWithTaskCriteriasWhereUniqueInput[]
    connect?: CheckWithTaskCriteriasWhereUniqueInput | CheckWithTaskCriteriasWhereUniqueInput[]
    update?: CheckWithTaskCriteriasUpdateWithWhereUniqueWithoutTask_criteriaInput | CheckWithTaskCriteriasUpdateWithWhereUniqueWithoutTask_criteriaInput[]
    updateMany?: CheckWithTaskCriteriasUpdateManyWithWhereWithoutTask_criteriaInput | CheckWithTaskCriteriasUpdateManyWithWhereWithoutTask_criteriaInput[]
    deleteMany?: CheckWithTaskCriteriasScalarWhereInput | CheckWithTaskCriteriasScalarWhereInput[]
  }

  export type TeacherCreateNestedOneWithoutTask_applysInput = {
    create?: XOR<TeacherCreateWithoutTask_applysInput, TeacherUncheckedCreateWithoutTask_applysInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutTask_applysInput
    connect?: TeacherWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutTask_applysInput = {
    create?: XOR<TaskCreateWithoutTask_applysInput, TaskUncheckedCreateWithoutTask_applysInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTask_applysInput
    connect?: TaskWhereUniqueInput
  }

  export type CheckWithTaskCriteriasCreateNestedManyWithoutTask_applyInput = {
    create?: XOR<CheckWithTaskCriteriasCreateWithoutTask_applyInput, CheckWithTaskCriteriasUncheckedCreateWithoutTask_applyInput> | CheckWithTaskCriteriasCreateWithoutTask_applyInput[] | CheckWithTaskCriteriasUncheckedCreateWithoutTask_applyInput[]
    connectOrCreate?: CheckWithTaskCriteriasCreateOrConnectWithoutTask_applyInput | CheckWithTaskCriteriasCreateOrConnectWithoutTask_applyInput[]
    createMany?: CheckWithTaskCriteriasCreateManyTask_applyInputEnvelope
    connect?: CheckWithTaskCriteriasWhereUniqueInput | CheckWithTaskCriteriasWhereUniqueInput[]
  }

  export type CheckWithTaskCriteriasUncheckedCreateNestedManyWithoutTask_applyInput = {
    create?: XOR<CheckWithTaskCriteriasCreateWithoutTask_applyInput, CheckWithTaskCriteriasUncheckedCreateWithoutTask_applyInput> | CheckWithTaskCriteriasCreateWithoutTask_applyInput[] | CheckWithTaskCriteriasUncheckedCreateWithoutTask_applyInput[]
    connectOrCreate?: CheckWithTaskCriteriasCreateOrConnectWithoutTask_applyInput | CheckWithTaskCriteriasCreateOrConnectWithoutTask_applyInput[]
    createMany?: CheckWithTaskCriteriasCreateManyTask_applyInputEnvelope
    connect?: CheckWithTaskCriteriasWhereUniqueInput | CheckWithTaskCriteriasWhereUniqueInput[]
  }

  export type TeacherUpdateOneRequiredWithoutTask_applysNestedInput = {
    create?: XOR<TeacherCreateWithoutTask_applysInput, TeacherUncheckedCreateWithoutTask_applysInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutTask_applysInput
    upsert?: TeacherUpsertWithoutTask_applysInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutTask_applysInput, TeacherUpdateWithoutTask_applysInput>, TeacherUncheckedUpdateWithoutTask_applysInput>
  }

  export type TaskUpdateOneRequiredWithoutTask_applysNestedInput = {
    create?: XOR<TaskCreateWithoutTask_applysInput, TaskUncheckedCreateWithoutTask_applysInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTask_applysInput
    upsert?: TaskUpsertWithoutTask_applysInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutTask_applysInput, TaskUpdateWithoutTask_applysInput>, TaskUncheckedUpdateWithoutTask_applysInput>
  }

  export type CheckWithTaskCriteriasUpdateManyWithoutTask_applyNestedInput = {
    create?: XOR<CheckWithTaskCriteriasCreateWithoutTask_applyInput, CheckWithTaskCriteriasUncheckedCreateWithoutTask_applyInput> | CheckWithTaskCriteriasCreateWithoutTask_applyInput[] | CheckWithTaskCriteriasUncheckedCreateWithoutTask_applyInput[]
    connectOrCreate?: CheckWithTaskCriteriasCreateOrConnectWithoutTask_applyInput | CheckWithTaskCriteriasCreateOrConnectWithoutTask_applyInput[]
    upsert?: CheckWithTaskCriteriasUpsertWithWhereUniqueWithoutTask_applyInput | CheckWithTaskCriteriasUpsertWithWhereUniqueWithoutTask_applyInput[]
    createMany?: CheckWithTaskCriteriasCreateManyTask_applyInputEnvelope
    set?: CheckWithTaskCriteriasWhereUniqueInput | CheckWithTaskCriteriasWhereUniqueInput[]
    disconnect?: CheckWithTaskCriteriasWhereUniqueInput | CheckWithTaskCriteriasWhereUniqueInput[]
    delete?: CheckWithTaskCriteriasWhereUniqueInput | CheckWithTaskCriteriasWhereUniqueInput[]
    connect?: CheckWithTaskCriteriasWhereUniqueInput | CheckWithTaskCriteriasWhereUniqueInput[]
    update?: CheckWithTaskCriteriasUpdateWithWhereUniqueWithoutTask_applyInput | CheckWithTaskCriteriasUpdateWithWhereUniqueWithoutTask_applyInput[]
    updateMany?: CheckWithTaskCriteriasUpdateManyWithWhereWithoutTask_applyInput | CheckWithTaskCriteriasUpdateManyWithWhereWithoutTask_applyInput[]
    deleteMany?: CheckWithTaskCriteriasScalarWhereInput | CheckWithTaskCriteriasScalarWhereInput[]
  }

  export type CheckWithTaskCriteriasUncheckedUpdateManyWithoutTask_applyNestedInput = {
    create?: XOR<CheckWithTaskCriteriasCreateWithoutTask_applyInput, CheckWithTaskCriteriasUncheckedCreateWithoutTask_applyInput> | CheckWithTaskCriteriasCreateWithoutTask_applyInput[] | CheckWithTaskCriteriasUncheckedCreateWithoutTask_applyInput[]
    connectOrCreate?: CheckWithTaskCriteriasCreateOrConnectWithoutTask_applyInput | CheckWithTaskCriteriasCreateOrConnectWithoutTask_applyInput[]
    upsert?: CheckWithTaskCriteriasUpsertWithWhereUniqueWithoutTask_applyInput | CheckWithTaskCriteriasUpsertWithWhereUniqueWithoutTask_applyInput[]
    createMany?: CheckWithTaskCriteriasCreateManyTask_applyInputEnvelope
    set?: CheckWithTaskCriteriasWhereUniqueInput | CheckWithTaskCriteriasWhereUniqueInput[]
    disconnect?: CheckWithTaskCriteriasWhereUniqueInput | CheckWithTaskCriteriasWhereUniqueInput[]
    delete?: CheckWithTaskCriteriasWhereUniqueInput | CheckWithTaskCriteriasWhereUniqueInput[]
    connect?: CheckWithTaskCriteriasWhereUniqueInput | CheckWithTaskCriteriasWhereUniqueInput[]
    update?: CheckWithTaskCriteriasUpdateWithWhereUniqueWithoutTask_applyInput | CheckWithTaskCriteriasUpdateWithWhereUniqueWithoutTask_applyInput[]
    updateMany?: CheckWithTaskCriteriasUpdateManyWithWhereWithoutTask_applyInput | CheckWithTaskCriteriasUpdateManyWithWhereWithoutTask_applyInput[]
    deleteMany?: CheckWithTaskCriteriasScalarWhereInput | CheckWithTaskCriteriasScalarWhereInput[]
  }

  export type TaskApplyCreateNestedOneWithoutCheck_task_criteriasInput = {
    create?: XOR<TaskApplyCreateWithoutCheck_task_criteriasInput, TaskApplyUncheckedCreateWithoutCheck_task_criteriasInput>
    connectOrCreate?: TaskApplyCreateOrConnectWithoutCheck_task_criteriasInput
    connect?: TaskApplyWhereUniqueInput
  }

  export type TaskCriteriaCreateNestedOneWithoutChecks_criteriasInput = {
    create?: XOR<TaskCriteriaCreateWithoutChecks_criteriasInput, TaskCriteriaUncheckedCreateWithoutChecks_criteriasInput>
    connectOrCreate?: TaskCriteriaCreateOrConnectWithoutChecks_criteriasInput
    connect?: TaskCriteriaWhereUniqueInput
  }

  export type TaskApplyUpdateOneRequiredWithoutCheck_task_criteriasNestedInput = {
    create?: XOR<TaskApplyCreateWithoutCheck_task_criteriasInput, TaskApplyUncheckedCreateWithoutCheck_task_criteriasInput>
    connectOrCreate?: TaskApplyCreateOrConnectWithoutCheck_task_criteriasInput
    upsert?: TaskApplyUpsertWithoutCheck_task_criteriasInput
    connect?: TaskApplyWhereUniqueInput
    update?: XOR<XOR<TaskApplyUpdateToOneWithWhereWithoutCheck_task_criteriasInput, TaskApplyUpdateWithoutCheck_task_criteriasInput>, TaskApplyUncheckedUpdateWithoutCheck_task_criteriasInput>
  }

  export type TaskCriteriaUpdateOneRequiredWithoutChecks_criteriasNestedInput = {
    create?: XOR<TaskCriteriaCreateWithoutChecks_criteriasInput, TaskCriteriaUncheckedCreateWithoutChecks_criteriasInput>
    connectOrCreate?: TaskCriteriaCreateOrConnectWithoutChecks_criteriasInput
    upsert?: TaskCriteriaUpsertWithoutChecks_criteriasInput
    connect?: TaskCriteriaWhereUniqueInput
    update?: XOR<XOR<TaskCriteriaUpdateToOneWithWhereWithoutChecks_criteriasInput, TaskCriteriaUpdateWithoutChecks_criteriasInput>, TaskCriteriaUncheckedUpdateWithoutChecks_criteriasInput>
  }

  export type TaskApplyCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TaskApplyCreateWithoutTeacherInput, TaskApplyUncheckedCreateWithoutTeacherInput> | TaskApplyCreateWithoutTeacherInput[] | TaskApplyUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TaskApplyCreateOrConnectWithoutTeacherInput | TaskApplyCreateOrConnectWithoutTeacherInput[]
    createMany?: TaskApplyCreateManyTeacherInputEnvelope
    connect?: TaskApplyWhereUniqueInput | TaskApplyWhereUniqueInput[]
  }

  export type TrainingApplyCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TrainingApplyCreateWithoutTeacherInput, TrainingApplyUncheckedCreateWithoutTeacherInput> | TrainingApplyCreateWithoutTeacherInput[] | TrainingApplyUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TrainingApplyCreateOrConnectWithoutTeacherInput | TrainingApplyCreateOrConnectWithoutTeacherInput[]
    createMany?: TrainingApplyCreateManyTeacherInputEnvelope
    connect?: TrainingApplyWhereUniqueInput | TrainingApplyWhereUniqueInput[]
  }

  export type WriteQuestionApplyCreateNestedManyWithoutTeacherInput = {
    create?: XOR<WriteQuestionApplyCreateWithoutTeacherInput, WriteQuestionApplyUncheckedCreateWithoutTeacherInput> | WriteQuestionApplyCreateWithoutTeacherInput[] | WriteQuestionApplyUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: WriteQuestionApplyCreateOrConnectWithoutTeacherInput | WriteQuestionApplyCreateOrConnectWithoutTeacherInput[]
    createMany?: WriteQuestionApplyCreateManyTeacherInputEnvelope
    connect?: WriteQuestionApplyWhereUniqueInput | WriteQuestionApplyWhereUniqueInput[]
  }

  export type ChoiceAnswerApplyCreateNestedManyWithoutTeacherInput = {
    create?: XOR<ChoiceAnswerApplyCreateWithoutTeacherInput, ChoiceAnswerApplyUncheckedCreateWithoutTeacherInput> | ChoiceAnswerApplyCreateWithoutTeacherInput[] | ChoiceAnswerApplyUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ChoiceAnswerApplyCreateOrConnectWithoutTeacherInput | ChoiceAnswerApplyCreateOrConnectWithoutTeacherInput[]
    createMany?: ChoiceAnswerApplyCreateManyTeacherInputEnvelope
    connect?: ChoiceAnswerApplyWhereUniqueInput | ChoiceAnswerApplyWhereUniqueInput[]
  }

  export type TeacherPersonalInfoCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherPersonalInfoCreateWithoutTeacherInput, TeacherPersonalInfoUncheckedCreateWithoutTeacherInput> | TeacherPersonalInfoCreateWithoutTeacherInput[] | TeacherPersonalInfoUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherPersonalInfoCreateOrConnectWithoutTeacherInput | TeacherPersonalInfoCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherPersonalInfoCreateManyTeacherInputEnvelope
    connect?: TeacherPersonalInfoWhereUniqueInput | TeacherPersonalInfoWhereUniqueInput[]
  }

  export type TeacherWorkplaceCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherWorkplaceCreateWithoutTeacherInput, TeacherWorkplaceUncheckedCreateWithoutTeacherInput> | TeacherWorkplaceCreateWithoutTeacherInput[] | TeacherWorkplaceUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherWorkplaceCreateOrConnectWithoutTeacherInput | TeacherWorkplaceCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherWorkplaceCreateManyTeacherInputEnvelope
    connect?: TeacherWorkplaceWhereUniqueInput | TeacherWorkplaceWhereUniqueInput[]
  }

  export type TaskApplyUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TaskApplyCreateWithoutTeacherInput, TaskApplyUncheckedCreateWithoutTeacherInput> | TaskApplyCreateWithoutTeacherInput[] | TaskApplyUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TaskApplyCreateOrConnectWithoutTeacherInput | TaskApplyCreateOrConnectWithoutTeacherInput[]
    createMany?: TaskApplyCreateManyTeacherInputEnvelope
    connect?: TaskApplyWhereUniqueInput | TaskApplyWhereUniqueInput[]
  }

  export type TrainingApplyUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TrainingApplyCreateWithoutTeacherInput, TrainingApplyUncheckedCreateWithoutTeacherInput> | TrainingApplyCreateWithoutTeacherInput[] | TrainingApplyUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TrainingApplyCreateOrConnectWithoutTeacherInput | TrainingApplyCreateOrConnectWithoutTeacherInput[]
    createMany?: TrainingApplyCreateManyTeacherInputEnvelope
    connect?: TrainingApplyWhereUniqueInput | TrainingApplyWhereUniqueInput[]
  }

  export type WriteQuestionApplyUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<WriteQuestionApplyCreateWithoutTeacherInput, WriteQuestionApplyUncheckedCreateWithoutTeacherInput> | WriteQuestionApplyCreateWithoutTeacherInput[] | WriteQuestionApplyUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: WriteQuestionApplyCreateOrConnectWithoutTeacherInput | WriteQuestionApplyCreateOrConnectWithoutTeacherInput[]
    createMany?: WriteQuestionApplyCreateManyTeacherInputEnvelope
    connect?: WriteQuestionApplyWhereUniqueInput | WriteQuestionApplyWhereUniqueInput[]
  }

  export type ChoiceAnswerApplyUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<ChoiceAnswerApplyCreateWithoutTeacherInput, ChoiceAnswerApplyUncheckedCreateWithoutTeacherInput> | ChoiceAnswerApplyCreateWithoutTeacherInput[] | ChoiceAnswerApplyUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ChoiceAnswerApplyCreateOrConnectWithoutTeacherInput | ChoiceAnswerApplyCreateOrConnectWithoutTeacherInput[]
    createMany?: ChoiceAnswerApplyCreateManyTeacherInputEnvelope
    connect?: ChoiceAnswerApplyWhereUniqueInput | ChoiceAnswerApplyWhereUniqueInput[]
  }

  export type TeacherPersonalInfoUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherPersonalInfoCreateWithoutTeacherInput, TeacherPersonalInfoUncheckedCreateWithoutTeacherInput> | TeacherPersonalInfoCreateWithoutTeacherInput[] | TeacherPersonalInfoUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherPersonalInfoCreateOrConnectWithoutTeacherInput | TeacherPersonalInfoCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherPersonalInfoCreateManyTeacherInputEnvelope
    connect?: TeacherPersonalInfoWhereUniqueInput | TeacherPersonalInfoWhereUniqueInput[]
  }

  export type TeacherWorkplaceUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherWorkplaceCreateWithoutTeacherInput, TeacherWorkplaceUncheckedCreateWithoutTeacherInput> | TeacherWorkplaceCreateWithoutTeacherInput[] | TeacherWorkplaceUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherWorkplaceCreateOrConnectWithoutTeacherInput | TeacherWorkplaceCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherWorkplaceCreateManyTeacherInputEnvelope
    connect?: TeacherWorkplaceWhereUniqueInput | TeacherWorkplaceWhereUniqueInput[]
  }

  export type TaskApplyUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TaskApplyCreateWithoutTeacherInput, TaskApplyUncheckedCreateWithoutTeacherInput> | TaskApplyCreateWithoutTeacherInput[] | TaskApplyUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TaskApplyCreateOrConnectWithoutTeacherInput | TaskApplyCreateOrConnectWithoutTeacherInput[]
    upsert?: TaskApplyUpsertWithWhereUniqueWithoutTeacherInput | TaskApplyUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TaskApplyCreateManyTeacherInputEnvelope
    set?: TaskApplyWhereUniqueInput | TaskApplyWhereUniqueInput[]
    disconnect?: TaskApplyWhereUniqueInput | TaskApplyWhereUniqueInput[]
    delete?: TaskApplyWhereUniqueInput | TaskApplyWhereUniqueInput[]
    connect?: TaskApplyWhereUniqueInput | TaskApplyWhereUniqueInput[]
    update?: TaskApplyUpdateWithWhereUniqueWithoutTeacherInput | TaskApplyUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TaskApplyUpdateManyWithWhereWithoutTeacherInput | TaskApplyUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TaskApplyScalarWhereInput | TaskApplyScalarWhereInput[]
  }

  export type TrainingApplyUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TrainingApplyCreateWithoutTeacherInput, TrainingApplyUncheckedCreateWithoutTeacherInput> | TrainingApplyCreateWithoutTeacherInput[] | TrainingApplyUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TrainingApplyCreateOrConnectWithoutTeacherInput | TrainingApplyCreateOrConnectWithoutTeacherInput[]
    upsert?: TrainingApplyUpsertWithWhereUniqueWithoutTeacherInput | TrainingApplyUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TrainingApplyCreateManyTeacherInputEnvelope
    set?: TrainingApplyWhereUniqueInput | TrainingApplyWhereUniqueInput[]
    disconnect?: TrainingApplyWhereUniqueInput | TrainingApplyWhereUniqueInput[]
    delete?: TrainingApplyWhereUniqueInput | TrainingApplyWhereUniqueInput[]
    connect?: TrainingApplyWhereUniqueInput | TrainingApplyWhereUniqueInput[]
    update?: TrainingApplyUpdateWithWhereUniqueWithoutTeacherInput | TrainingApplyUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TrainingApplyUpdateManyWithWhereWithoutTeacherInput | TrainingApplyUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TrainingApplyScalarWhereInput | TrainingApplyScalarWhereInput[]
  }

  export type WriteQuestionApplyUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<WriteQuestionApplyCreateWithoutTeacherInput, WriteQuestionApplyUncheckedCreateWithoutTeacherInput> | WriteQuestionApplyCreateWithoutTeacherInput[] | WriteQuestionApplyUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: WriteQuestionApplyCreateOrConnectWithoutTeacherInput | WriteQuestionApplyCreateOrConnectWithoutTeacherInput[]
    upsert?: WriteQuestionApplyUpsertWithWhereUniqueWithoutTeacherInput | WriteQuestionApplyUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: WriteQuestionApplyCreateManyTeacherInputEnvelope
    set?: WriteQuestionApplyWhereUniqueInput | WriteQuestionApplyWhereUniqueInput[]
    disconnect?: WriteQuestionApplyWhereUniqueInput | WriteQuestionApplyWhereUniqueInput[]
    delete?: WriteQuestionApplyWhereUniqueInput | WriteQuestionApplyWhereUniqueInput[]
    connect?: WriteQuestionApplyWhereUniqueInput | WriteQuestionApplyWhereUniqueInput[]
    update?: WriteQuestionApplyUpdateWithWhereUniqueWithoutTeacherInput | WriteQuestionApplyUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: WriteQuestionApplyUpdateManyWithWhereWithoutTeacherInput | WriteQuestionApplyUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: WriteQuestionApplyScalarWhereInput | WriteQuestionApplyScalarWhereInput[]
  }

  export type ChoiceAnswerApplyUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<ChoiceAnswerApplyCreateWithoutTeacherInput, ChoiceAnswerApplyUncheckedCreateWithoutTeacherInput> | ChoiceAnswerApplyCreateWithoutTeacherInput[] | ChoiceAnswerApplyUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ChoiceAnswerApplyCreateOrConnectWithoutTeacherInput | ChoiceAnswerApplyCreateOrConnectWithoutTeacherInput[]
    upsert?: ChoiceAnswerApplyUpsertWithWhereUniqueWithoutTeacherInput | ChoiceAnswerApplyUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: ChoiceAnswerApplyCreateManyTeacherInputEnvelope
    set?: ChoiceAnswerApplyWhereUniqueInput | ChoiceAnswerApplyWhereUniqueInput[]
    disconnect?: ChoiceAnswerApplyWhereUniqueInput | ChoiceAnswerApplyWhereUniqueInput[]
    delete?: ChoiceAnswerApplyWhereUniqueInput | ChoiceAnswerApplyWhereUniqueInput[]
    connect?: ChoiceAnswerApplyWhereUniqueInput | ChoiceAnswerApplyWhereUniqueInput[]
    update?: ChoiceAnswerApplyUpdateWithWhereUniqueWithoutTeacherInput | ChoiceAnswerApplyUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: ChoiceAnswerApplyUpdateManyWithWhereWithoutTeacherInput | ChoiceAnswerApplyUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: ChoiceAnswerApplyScalarWhereInput | ChoiceAnswerApplyScalarWhereInput[]
  }

  export type TeacherPersonalInfoUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherPersonalInfoCreateWithoutTeacherInput, TeacherPersonalInfoUncheckedCreateWithoutTeacherInput> | TeacherPersonalInfoCreateWithoutTeacherInput[] | TeacherPersonalInfoUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherPersonalInfoCreateOrConnectWithoutTeacherInput | TeacherPersonalInfoCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherPersonalInfoUpsertWithWhereUniqueWithoutTeacherInput | TeacherPersonalInfoUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherPersonalInfoCreateManyTeacherInputEnvelope
    set?: TeacherPersonalInfoWhereUniqueInput | TeacherPersonalInfoWhereUniqueInput[]
    disconnect?: TeacherPersonalInfoWhereUniqueInput | TeacherPersonalInfoWhereUniqueInput[]
    delete?: TeacherPersonalInfoWhereUniqueInput | TeacherPersonalInfoWhereUniqueInput[]
    connect?: TeacherPersonalInfoWhereUniqueInput | TeacherPersonalInfoWhereUniqueInput[]
    update?: TeacherPersonalInfoUpdateWithWhereUniqueWithoutTeacherInput | TeacherPersonalInfoUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherPersonalInfoUpdateManyWithWhereWithoutTeacherInput | TeacherPersonalInfoUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherPersonalInfoScalarWhereInput | TeacherPersonalInfoScalarWhereInput[]
  }

  export type TeacherWorkplaceUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherWorkplaceCreateWithoutTeacherInput, TeacherWorkplaceUncheckedCreateWithoutTeacherInput> | TeacherWorkplaceCreateWithoutTeacherInput[] | TeacherWorkplaceUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherWorkplaceCreateOrConnectWithoutTeacherInput | TeacherWorkplaceCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherWorkplaceUpsertWithWhereUniqueWithoutTeacherInput | TeacherWorkplaceUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherWorkplaceCreateManyTeacherInputEnvelope
    set?: TeacherWorkplaceWhereUniqueInput | TeacherWorkplaceWhereUniqueInput[]
    disconnect?: TeacherWorkplaceWhereUniqueInput | TeacherWorkplaceWhereUniqueInput[]
    delete?: TeacherWorkplaceWhereUniqueInput | TeacherWorkplaceWhereUniqueInput[]
    connect?: TeacherWorkplaceWhereUniqueInput | TeacherWorkplaceWhereUniqueInput[]
    update?: TeacherWorkplaceUpdateWithWhereUniqueWithoutTeacherInput | TeacherWorkplaceUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherWorkplaceUpdateManyWithWhereWithoutTeacherInput | TeacherWorkplaceUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherWorkplaceScalarWhereInput | TeacherWorkplaceScalarWhereInput[]
  }

  export type TaskApplyUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TaskApplyCreateWithoutTeacherInput, TaskApplyUncheckedCreateWithoutTeacherInput> | TaskApplyCreateWithoutTeacherInput[] | TaskApplyUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TaskApplyCreateOrConnectWithoutTeacherInput | TaskApplyCreateOrConnectWithoutTeacherInput[]
    upsert?: TaskApplyUpsertWithWhereUniqueWithoutTeacherInput | TaskApplyUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TaskApplyCreateManyTeacherInputEnvelope
    set?: TaskApplyWhereUniqueInput | TaskApplyWhereUniqueInput[]
    disconnect?: TaskApplyWhereUniqueInput | TaskApplyWhereUniqueInput[]
    delete?: TaskApplyWhereUniqueInput | TaskApplyWhereUniqueInput[]
    connect?: TaskApplyWhereUniqueInput | TaskApplyWhereUniqueInput[]
    update?: TaskApplyUpdateWithWhereUniqueWithoutTeacherInput | TaskApplyUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TaskApplyUpdateManyWithWhereWithoutTeacherInput | TaskApplyUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TaskApplyScalarWhereInput | TaskApplyScalarWhereInput[]
  }

  export type TrainingApplyUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TrainingApplyCreateWithoutTeacherInput, TrainingApplyUncheckedCreateWithoutTeacherInput> | TrainingApplyCreateWithoutTeacherInput[] | TrainingApplyUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TrainingApplyCreateOrConnectWithoutTeacherInput | TrainingApplyCreateOrConnectWithoutTeacherInput[]
    upsert?: TrainingApplyUpsertWithWhereUniqueWithoutTeacherInput | TrainingApplyUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TrainingApplyCreateManyTeacherInputEnvelope
    set?: TrainingApplyWhereUniqueInput | TrainingApplyWhereUniqueInput[]
    disconnect?: TrainingApplyWhereUniqueInput | TrainingApplyWhereUniqueInput[]
    delete?: TrainingApplyWhereUniqueInput | TrainingApplyWhereUniqueInput[]
    connect?: TrainingApplyWhereUniqueInput | TrainingApplyWhereUniqueInput[]
    update?: TrainingApplyUpdateWithWhereUniqueWithoutTeacherInput | TrainingApplyUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TrainingApplyUpdateManyWithWhereWithoutTeacherInput | TrainingApplyUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TrainingApplyScalarWhereInput | TrainingApplyScalarWhereInput[]
  }

  export type WriteQuestionApplyUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<WriteQuestionApplyCreateWithoutTeacherInput, WriteQuestionApplyUncheckedCreateWithoutTeacherInput> | WriteQuestionApplyCreateWithoutTeacherInput[] | WriteQuestionApplyUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: WriteQuestionApplyCreateOrConnectWithoutTeacherInput | WriteQuestionApplyCreateOrConnectWithoutTeacherInput[]
    upsert?: WriteQuestionApplyUpsertWithWhereUniqueWithoutTeacherInput | WriteQuestionApplyUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: WriteQuestionApplyCreateManyTeacherInputEnvelope
    set?: WriteQuestionApplyWhereUniqueInput | WriteQuestionApplyWhereUniqueInput[]
    disconnect?: WriteQuestionApplyWhereUniqueInput | WriteQuestionApplyWhereUniqueInput[]
    delete?: WriteQuestionApplyWhereUniqueInput | WriteQuestionApplyWhereUniqueInput[]
    connect?: WriteQuestionApplyWhereUniqueInput | WriteQuestionApplyWhereUniqueInput[]
    update?: WriteQuestionApplyUpdateWithWhereUniqueWithoutTeacherInput | WriteQuestionApplyUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: WriteQuestionApplyUpdateManyWithWhereWithoutTeacherInput | WriteQuestionApplyUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: WriteQuestionApplyScalarWhereInput | WriteQuestionApplyScalarWhereInput[]
  }

  export type ChoiceAnswerApplyUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<ChoiceAnswerApplyCreateWithoutTeacherInput, ChoiceAnswerApplyUncheckedCreateWithoutTeacherInput> | ChoiceAnswerApplyCreateWithoutTeacherInput[] | ChoiceAnswerApplyUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ChoiceAnswerApplyCreateOrConnectWithoutTeacherInput | ChoiceAnswerApplyCreateOrConnectWithoutTeacherInput[]
    upsert?: ChoiceAnswerApplyUpsertWithWhereUniqueWithoutTeacherInput | ChoiceAnswerApplyUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: ChoiceAnswerApplyCreateManyTeacherInputEnvelope
    set?: ChoiceAnswerApplyWhereUniqueInput | ChoiceAnswerApplyWhereUniqueInput[]
    disconnect?: ChoiceAnswerApplyWhereUniqueInput | ChoiceAnswerApplyWhereUniqueInput[]
    delete?: ChoiceAnswerApplyWhereUniqueInput | ChoiceAnswerApplyWhereUniqueInput[]
    connect?: ChoiceAnswerApplyWhereUniqueInput | ChoiceAnswerApplyWhereUniqueInput[]
    update?: ChoiceAnswerApplyUpdateWithWhereUniqueWithoutTeacherInput | ChoiceAnswerApplyUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: ChoiceAnswerApplyUpdateManyWithWhereWithoutTeacherInput | ChoiceAnswerApplyUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: ChoiceAnswerApplyScalarWhereInput | ChoiceAnswerApplyScalarWhereInput[]
  }

  export type TeacherPersonalInfoUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherPersonalInfoCreateWithoutTeacherInput, TeacherPersonalInfoUncheckedCreateWithoutTeacherInput> | TeacherPersonalInfoCreateWithoutTeacherInput[] | TeacherPersonalInfoUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherPersonalInfoCreateOrConnectWithoutTeacherInput | TeacherPersonalInfoCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherPersonalInfoUpsertWithWhereUniqueWithoutTeacherInput | TeacherPersonalInfoUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherPersonalInfoCreateManyTeacherInputEnvelope
    set?: TeacherPersonalInfoWhereUniqueInput | TeacherPersonalInfoWhereUniqueInput[]
    disconnect?: TeacherPersonalInfoWhereUniqueInput | TeacherPersonalInfoWhereUniqueInput[]
    delete?: TeacherPersonalInfoWhereUniqueInput | TeacherPersonalInfoWhereUniqueInput[]
    connect?: TeacherPersonalInfoWhereUniqueInput | TeacherPersonalInfoWhereUniqueInput[]
    update?: TeacherPersonalInfoUpdateWithWhereUniqueWithoutTeacherInput | TeacherPersonalInfoUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherPersonalInfoUpdateManyWithWhereWithoutTeacherInput | TeacherPersonalInfoUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherPersonalInfoScalarWhereInput | TeacherPersonalInfoScalarWhereInput[]
  }

  export type TeacherWorkplaceUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherWorkplaceCreateWithoutTeacherInput, TeacherWorkplaceUncheckedCreateWithoutTeacherInput> | TeacherWorkplaceCreateWithoutTeacherInput[] | TeacherWorkplaceUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherWorkplaceCreateOrConnectWithoutTeacherInput | TeacherWorkplaceCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherWorkplaceUpsertWithWhereUniqueWithoutTeacherInput | TeacherWorkplaceUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherWorkplaceCreateManyTeacherInputEnvelope
    set?: TeacherWorkplaceWhereUniqueInput | TeacherWorkplaceWhereUniqueInput[]
    disconnect?: TeacherWorkplaceWhereUniqueInput | TeacherWorkplaceWhereUniqueInput[]
    delete?: TeacherWorkplaceWhereUniqueInput | TeacherWorkplaceWhereUniqueInput[]
    connect?: TeacherWorkplaceWhereUniqueInput | TeacherWorkplaceWhereUniqueInput[]
    update?: TeacherWorkplaceUpdateWithWhereUniqueWithoutTeacherInput | TeacherWorkplaceUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherWorkplaceUpdateManyWithWhereWithoutTeacherInput | TeacherWorkplaceUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherWorkplaceScalarWhereInput | TeacherWorkplaceScalarWhereInput[]
  }

  export type TeacherCreateNestedOneWithoutTeacher_personal_infoInput = {
    create?: XOR<TeacherCreateWithoutTeacher_personal_infoInput, TeacherUncheckedCreateWithoutTeacher_personal_infoInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutTeacher_personal_infoInput
    connect?: TeacherWhereUniqueInput
  }

  export type TeacherUpdateOneRequiredWithoutTeacher_personal_infoNestedInput = {
    create?: XOR<TeacherCreateWithoutTeacher_personal_infoInput, TeacherUncheckedCreateWithoutTeacher_personal_infoInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutTeacher_personal_infoInput
    upsert?: TeacherUpsertWithoutTeacher_personal_infoInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutTeacher_personal_infoInput, TeacherUpdateWithoutTeacher_personal_infoInput>, TeacherUncheckedUpdateWithoutTeacher_personal_infoInput>
  }

  export type TeacherCreateNestedOneWithoutTeacher_workplaceInput = {
    create?: XOR<TeacherCreateWithoutTeacher_workplaceInput, TeacherUncheckedCreateWithoutTeacher_workplaceInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutTeacher_workplaceInput
    connect?: TeacherWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutTeachers_workplacesInput = {
    create?: XOR<SchoolCreateWithoutTeachers_workplacesInput, SchoolUncheckedCreateWithoutTeachers_workplacesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutTeachers_workplacesInput
    connect?: SchoolWhereUniqueInput
  }

  export type TeacherUpdateOneRequiredWithoutTeacher_workplaceNestedInput = {
    create?: XOR<TeacherCreateWithoutTeacher_workplaceInput, TeacherUncheckedCreateWithoutTeacher_workplaceInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutTeacher_workplaceInput
    upsert?: TeacherUpsertWithoutTeacher_workplaceInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutTeacher_workplaceInput, TeacherUpdateWithoutTeacher_workplaceInput>, TeacherUncheckedUpdateWithoutTeacher_workplaceInput>
  }

  export type SchoolUpdateOneRequiredWithoutTeachers_workplacesNestedInput = {
    create?: XOR<SchoolCreateWithoutTeachers_workplacesInput, SchoolUncheckedCreateWithoutTeachers_workplacesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutTeachers_workplacesInput
    upsert?: SchoolUpsertWithoutTeachers_workplacesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutTeachers_workplacesInput, SchoolUpdateWithoutTeachers_workplacesInput>, SchoolUncheckedUpdateWithoutTeachers_workplacesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type RegionCreateWithoutSchoolsInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RegionUncheckedCreateWithoutSchoolsInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RegionCreateOrConnectWithoutSchoolsInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutSchoolsInput, RegionUncheckedCreateWithoutSchoolsInput>
  }

  export type TeacherWorkplaceCreateWithoutSchoolInput = {
    id?: string
    position: string
    created_at?: Date | string
    updated_at?: Date | string
    teacher: TeacherCreateNestedOneWithoutTeacher_workplaceInput
  }

  export type TeacherWorkplaceUncheckedCreateWithoutSchoolInput = {
    id?: string
    position: string
    teacherId: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TeacherWorkplaceCreateOrConnectWithoutSchoolInput = {
    where: TeacherWorkplaceWhereUniqueInput
    create: XOR<TeacherWorkplaceCreateWithoutSchoolInput, TeacherWorkplaceUncheckedCreateWithoutSchoolInput>
  }

  export type TeacherWorkplaceCreateManySchoolInputEnvelope = {
    data: TeacherWorkplaceCreateManySchoolInput | TeacherWorkplaceCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type RegionUpsertWithoutSchoolsInput = {
    update: XOR<RegionUpdateWithoutSchoolsInput, RegionUncheckedUpdateWithoutSchoolsInput>
    create: XOR<RegionCreateWithoutSchoolsInput, RegionUncheckedCreateWithoutSchoolsInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutSchoolsInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutSchoolsInput, RegionUncheckedUpdateWithoutSchoolsInput>
  }

  export type RegionUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherWorkplaceUpsertWithWhereUniqueWithoutSchoolInput = {
    where: TeacherWorkplaceWhereUniqueInput
    update: XOR<TeacherWorkplaceUpdateWithoutSchoolInput, TeacherWorkplaceUncheckedUpdateWithoutSchoolInput>
    create: XOR<TeacherWorkplaceCreateWithoutSchoolInput, TeacherWorkplaceUncheckedCreateWithoutSchoolInput>
  }

  export type TeacherWorkplaceUpdateWithWhereUniqueWithoutSchoolInput = {
    where: TeacherWorkplaceWhereUniqueInput
    data: XOR<TeacherWorkplaceUpdateWithoutSchoolInput, TeacherWorkplaceUncheckedUpdateWithoutSchoolInput>
  }

  export type TeacherWorkplaceUpdateManyWithWhereWithoutSchoolInput = {
    where: TeacherWorkplaceScalarWhereInput
    data: XOR<TeacherWorkplaceUpdateManyMutationInput, TeacherWorkplaceUncheckedUpdateManyWithoutSchoolInput>
  }

  export type TeacherWorkplaceScalarWhereInput = {
    AND?: TeacherWorkplaceScalarWhereInput | TeacherWorkplaceScalarWhereInput[]
    OR?: TeacherWorkplaceScalarWhereInput[]
    NOT?: TeacherWorkplaceScalarWhereInput | TeacherWorkplaceScalarWhereInput[]
    id?: StringFilter<"TeacherWorkplace"> | string
    position?: StringFilter<"TeacherWorkplace"> | string
    teacherId?: StringFilter<"TeacherWorkplace"> | string
    schoolId?: StringFilter<"TeacherWorkplace"> | string
    created_at?: DateTimeFilter<"TeacherWorkplace"> | Date | string
    updated_at?: DateTimeFilter<"TeacherWorkplace"> | Date | string
  }

  export type SchoolCreateWithoutRegionInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    teachers_workplaces?: TeacherWorkplaceCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutRegionInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    teachers_workplaces?: TeacherWorkplaceUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutRegionInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutRegionInput, SchoolUncheckedCreateWithoutRegionInput>
  }

  export type SchoolCreateManyRegionInputEnvelope = {
    data: SchoolCreateManyRegionInput | SchoolCreateManyRegionInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithWhereUniqueWithoutRegionInput = {
    where: SchoolWhereUniqueInput
    update: XOR<SchoolUpdateWithoutRegionInput, SchoolUncheckedUpdateWithoutRegionInput>
    create: XOR<SchoolCreateWithoutRegionInput, SchoolUncheckedCreateWithoutRegionInput>
  }

  export type SchoolUpdateWithWhereUniqueWithoutRegionInput = {
    where: SchoolWhereUniqueInput
    data: XOR<SchoolUpdateWithoutRegionInput, SchoolUncheckedUpdateWithoutRegionInput>
  }

  export type SchoolUpdateManyWithWhereWithoutRegionInput = {
    where: SchoolScalarWhereInput
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyWithoutRegionInput>
  }

  export type SchoolScalarWhereInput = {
    AND?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
    OR?: SchoolScalarWhereInput[]
    NOT?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
    id?: StringFilter<"School"> | string
    name?: StringFilter<"School"> | string
    region_id?: StringFilter<"School"> | string
    created_at?: DateTimeFilter<"School"> | Date | string
    updated_at?: DateTimeFilter<"School"> | Date | string
  }

  export type ChoiceAnswerCreateWithoutQuestionInput = {
    id?: string
    key: string
    value: string
    created_at?: Date | string
    updated_at?: Date | string
    choice_answer_applys?: ChoiceAnswerApplyCreateNestedManyWithoutAnswerInput
  }

  export type ChoiceAnswerUncheckedCreateWithoutQuestionInput = {
    id?: string
    key: string
    value: string
    created_at?: Date | string
    updated_at?: Date | string
    choice_answer_applys?: ChoiceAnswerApplyUncheckedCreateNestedManyWithoutAnswerInput
  }

  export type ChoiceAnswerCreateOrConnectWithoutQuestionInput = {
    where: ChoiceAnswerWhereUniqueInput
    create: XOR<ChoiceAnswerCreateWithoutQuestionInput, ChoiceAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type ChoiceAnswerCreateManyQuestionInputEnvelope = {
    data: ChoiceAnswerCreateManyQuestionInput | ChoiceAnswerCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type ChoiceAnswerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: ChoiceAnswerWhereUniqueInput
    update: XOR<ChoiceAnswerUpdateWithoutQuestionInput, ChoiceAnswerUncheckedUpdateWithoutQuestionInput>
    create: XOR<ChoiceAnswerCreateWithoutQuestionInput, ChoiceAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type ChoiceAnswerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: ChoiceAnswerWhereUniqueInput
    data: XOR<ChoiceAnswerUpdateWithoutQuestionInput, ChoiceAnswerUncheckedUpdateWithoutQuestionInput>
  }

  export type ChoiceAnswerUpdateManyWithWhereWithoutQuestionInput = {
    where: ChoiceAnswerScalarWhereInput
    data: XOR<ChoiceAnswerUpdateManyMutationInput, ChoiceAnswerUncheckedUpdateManyWithoutQuestionInput>
  }

  export type ChoiceAnswerScalarWhereInput = {
    AND?: ChoiceAnswerScalarWhereInput | ChoiceAnswerScalarWhereInput[]
    OR?: ChoiceAnswerScalarWhereInput[]
    NOT?: ChoiceAnswerScalarWhereInput | ChoiceAnswerScalarWhereInput[]
    id?: StringFilter<"ChoiceAnswer"> | string
    questionId?: StringFilter<"ChoiceAnswer"> | string
    key?: StringFilter<"ChoiceAnswer"> | string
    value?: StringFilter<"ChoiceAnswer"> | string
    created_at?: DateTimeFilter<"ChoiceAnswer"> | Date | string
    updated_at?: DateTimeFilter<"ChoiceAnswer"> | Date | string
  }

  export type ChoiceQuestionCreateWithoutAnswersInput = {
    id?: string
    text: string
    description?: string | null
    correct_choice: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChoiceQuestionUncheckedCreateWithoutAnswersInput = {
    id?: string
    text: string
    description?: string | null
    correct_choice: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChoiceQuestionCreateOrConnectWithoutAnswersInput = {
    where: ChoiceQuestionWhereUniqueInput
    create: XOR<ChoiceQuestionCreateWithoutAnswersInput, ChoiceQuestionUncheckedCreateWithoutAnswersInput>
  }

  export type ChoiceAnswerApplyCreateWithoutAnswerInput = {
    id?: string
    key: string
    is_correct?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    teacher: TeacherCreateNestedOneWithoutChoice_answer_applysInput
  }

  export type ChoiceAnswerApplyUncheckedCreateWithoutAnswerInput = {
    id?: string
    teacherId: string
    key: string
    is_correct?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChoiceAnswerApplyCreateOrConnectWithoutAnswerInput = {
    where: ChoiceAnswerApplyWhereUniqueInput
    create: XOR<ChoiceAnswerApplyCreateWithoutAnswerInput, ChoiceAnswerApplyUncheckedCreateWithoutAnswerInput>
  }

  export type ChoiceAnswerApplyCreateManyAnswerInputEnvelope = {
    data: ChoiceAnswerApplyCreateManyAnswerInput | ChoiceAnswerApplyCreateManyAnswerInput[]
    skipDuplicates?: boolean
  }

  export type ChoiceQuestionUpsertWithoutAnswersInput = {
    update: XOR<ChoiceQuestionUpdateWithoutAnswersInput, ChoiceQuestionUncheckedUpdateWithoutAnswersInput>
    create: XOR<ChoiceQuestionCreateWithoutAnswersInput, ChoiceQuestionUncheckedCreateWithoutAnswersInput>
    where?: ChoiceQuestionWhereInput
  }

  export type ChoiceQuestionUpdateToOneWithWhereWithoutAnswersInput = {
    where?: ChoiceQuestionWhereInput
    data: XOR<ChoiceQuestionUpdateWithoutAnswersInput, ChoiceQuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type ChoiceQuestionUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    correct_choice?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceQuestionUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    correct_choice?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceAnswerApplyUpsertWithWhereUniqueWithoutAnswerInput = {
    where: ChoiceAnswerApplyWhereUniqueInput
    update: XOR<ChoiceAnswerApplyUpdateWithoutAnswerInput, ChoiceAnswerApplyUncheckedUpdateWithoutAnswerInput>
    create: XOR<ChoiceAnswerApplyCreateWithoutAnswerInput, ChoiceAnswerApplyUncheckedCreateWithoutAnswerInput>
  }

  export type ChoiceAnswerApplyUpdateWithWhereUniqueWithoutAnswerInput = {
    where: ChoiceAnswerApplyWhereUniqueInput
    data: XOR<ChoiceAnswerApplyUpdateWithoutAnswerInput, ChoiceAnswerApplyUncheckedUpdateWithoutAnswerInput>
  }

  export type ChoiceAnswerApplyUpdateManyWithWhereWithoutAnswerInput = {
    where: ChoiceAnswerApplyScalarWhereInput
    data: XOR<ChoiceAnswerApplyUpdateManyMutationInput, ChoiceAnswerApplyUncheckedUpdateManyWithoutAnswerInput>
  }

  export type ChoiceAnswerApplyScalarWhereInput = {
    AND?: ChoiceAnswerApplyScalarWhereInput | ChoiceAnswerApplyScalarWhereInput[]
    OR?: ChoiceAnswerApplyScalarWhereInput[]
    NOT?: ChoiceAnswerApplyScalarWhereInput | ChoiceAnswerApplyScalarWhereInput[]
    id?: StringFilter<"ChoiceAnswerApply"> | string
    teacherId?: StringFilter<"ChoiceAnswerApply"> | string
    answerId?: StringFilter<"ChoiceAnswerApply"> | string
    key?: StringFilter<"ChoiceAnswerApply"> | string
    is_correct?: BoolNullableFilter<"ChoiceAnswerApply"> | boolean | null
    created_at?: DateTimeFilter<"ChoiceAnswerApply"> | Date | string
    updated_at?: DateTimeFilter<"ChoiceAnswerApply"> | Date | string
  }

  export type TeacherCreateWithoutChoice_answer_applysInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    username: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    task_applys?: TaskApplyCreateNestedManyWithoutTeacherInput
    teacher_training_applys?: TrainingApplyCreateNestedManyWithoutTeacherInput
    write_question_applys?: WriteQuestionApplyCreateNestedManyWithoutTeacherInput
    teacher_personal_info?: TeacherPersonalInfoCreateNestedManyWithoutTeacherInput
    teacher_workplace?: TeacherWorkplaceCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutChoice_answer_applysInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    username: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    task_applys?: TaskApplyUncheckedCreateNestedManyWithoutTeacherInput
    teacher_training_applys?: TrainingApplyUncheckedCreateNestedManyWithoutTeacherInput
    write_question_applys?: WriteQuestionApplyUncheckedCreateNestedManyWithoutTeacherInput
    teacher_personal_info?: TeacherPersonalInfoUncheckedCreateNestedManyWithoutTeacherInput
    teacher_workplace?: TeacherWorkplaceUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutChoice_answer_applysInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutChoice_answer_applysInput, TeacherUncheckedCreateWithoutChoice_answer_applysInput>
  }

  export type ChoiceAnswerCreateWithoutChoice_answer_applysInput = {
    id?: string
    key: string
    value: string
    created_at?: Date | string
    updated_at?: Date | string
    question: ChoiceQuestionCreateNestedOneWithoutAnswersInput
  }

  export type ChoiceAnswerUncheckedCreateWithoutChoice_answer_applysInput = {
    id?: string
    questionId: string
    key: string
    value: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChoiceAnswerCreateOrConnectWithoutChoice_answer_applysInput = {
    where: ChoiceAnswerWhereUniqueInput
    create: XOR<ChoiceAnswerCreateWithoutChoice_answer_applysInput, ChoiceAnswerUncheckedCreateWithoutChoice_answer_applysInput>
  }

  export type TeacherUpsertWithoutChoice_answer_applysInput = {
    update: XOR<TeacherUpdateWithoutChoice_answer_applysInput, TeacherUncheckedUpdateWithoutChoice_answer_applysInput>
    create: XOR<TeacherCreateWithoutChoice_answer_applysInput, TeacherUncheckedCreateWithoutChoice_answer_applysInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutChoice_answer_applysInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutChoice_answer_applysInput, TeacherUncheckedUpdateWithoutChoice_answer_applysInput>
  }

  export type TeacherUpdateWithoutChoice_answer_applysInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_applys?: TaskApplyUpdateManyWithoutTeacherNestedInput
    teacher_training_applys?: TrainingApplyUpdateManyWithoutTeacherNestedInput
    write_question_applys?: WriteQuestionApplyUpdateManyWithoutTeacherNestedInput
    teacher_personal_info?: TeacherPersonalInfoUpdateManyWithoutTeacherNestedInput
    teacher_workplace?: TeacherWorkplaceUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutChoice_answer_applysInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_applys?: TaskApplyUncheckedUpdateManyWithoutTeacherNestedInput
    teacher_training_applys?: TrainingApplyUncheckedUpdateManyWithoutTeacherNestedInput
    write_question_applys?: WriteQuestionApplyUncheckedUpdateManyWithoutTeacherNestedInput
    teacher_personal_info?: TeacherPersonalInfoUncheckedUpdateManyWithoutTeacherNestedInput
    teacher_workplace?: TeacherWorkplaceUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type ChoiceAnswerUpsertWithoutChoice_answer_applysInput = {
    update: XOR<ChoiceAnswerUpdateWithoutChoice_answer_applysInput, ChoiceAnswerUncheckedUpdateWithoutChoice_answer_applysInput>
    create: XOR<ChoiceAnswerCreateWithoutChoice_answer_applysInput, ChoiceAnswerUncheckedCreateWithoutChoice_answer_applysInput>
    where?: ChoiceAnswerWhereInput
  }

  export type ChoiceAnswerUpdateToOneWithWhereWithoutChoice_answer_applysInput = {
    where?: ChoiceAnswerWhereInput
    data: XOR<ChoiceAnswerUpdateWithoutChoice_answer_applysInput, ChoiceAnswerUncheckedUpdateWithoutChoice_answer_applysInput>
  }

  export type ChoiceAnswerUpdateWithoutChoice_answer_applysInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: ChoiceQuestionUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type ChoiceAnswerUncheckedUpdateWithoutChoice_answer_applysInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WriteQuestionApplyCreateWithoutQuestionInput = {
    id?: string
    value: string
    is_correct?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    teacher: TeacherCreateNestedOneWithoutWrite_question_applysInput
  }

  export type WriteQuestionApplyUncheckedCreateWithoutQuestionInput = {
    id?: string
    teacherId: string
    value: string
    is_correct?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WriteQuestionApplyCreateOrConnectWithoutQuestionInput = {
    where: WriteQuestionApplyWhereUniqueInput
    create: XOR<WriteQuestionApplyCreateWithoutQuestionInput, WriteQuestionApplyUncheckedCreateWithoutQuestionInput>
  }

  export type WriteQuestionApplyCreateManyQuestionInputEnvelope = {
    data: WriteQuestionApplyCreateManyQuestionInput | WriteQuestionApplyCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type WriteQuestionApplyUpsertWithWhereUniqueWithoutQuestionInput = {
    where: WriteQuestionApplyWhereUniqueInput
    update: XOR<WriteQuestionApplyUpdateWithoutQuestionInput, WriteQuestionApplyUncheckedUpdateWithoutQuestionInput>
    create: XOR<WriteQuestionApplyCreateWithoutQuestionInput, WriteQuestionApplyUncheckedCreateWithoutQuestionInput>
  }

  export type WriteQuestionApplyUpdateWithWhereUniqueWithoutQuestionInput = {
    where: WriteQuestionApplyWhereUniqueInput
    data: XOR<WriteQuestionApplyUpdateWithoutQuestionInput, WriteQuestionApplyUncheckedUpdateWithoutQuestionInput>
  }

  export type WriteQuestionApplyUpdateManyWithWhereWithoutQuestionInput = {
    where: WriteQuestionApplyScalarWhereInput
    data: XOR<WriteQuestionApplyUpdateManyMutationInput, WriteQuestionApplyUncheckedUpdateManyWithoutQuestionInput>
  }

  export type WriteQuestionApplyScalarWhereInput = {
    AND?: WriteQuestionApplyScalarWhereInput | WriteQuestionApplyScalarWhereInput[]
    OR?: WriteQuestionApplyScalarWhereInput[]
    NOT?: WriteQuestionApplyScalarWhereInput | WriteQuestionApplyScalarWhereInput[]
    id?: StringFilter<"WriteQuestionApply"> | string
    questionId?: StringFilter<"WriteQuestionApply"> | string
    teacherId?: StringFilter<"WriteQuestionApply"> | string
    value?: StringFilter<"WriteQuestionApply"> | string
    is_correct?: BoolNullableFilter<"WriteQuestionApply"> | boolean | null
    created_at?: DateTimeFilter<"WriteQuestionApply"> | Date | string
    updated_at?: DateTimeFilter<"WriteQuestionApply"> | Date | string
  }

  export type WriteQuestionCreateWithoutQuestion_applysInput = {
    id?: string
    text: string
    correct_answer: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WriteQuestionUncheckedCreateWithoutQuestion_applysInput = {
    id?: string
    text: string
    correct_answer: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WriteQuestionCreateOrConnectWithoutQuestion_applysInput = {
    where: WriteQuestionWhereUniqueInput
    create: XOR<WriteQuestionCreateWithoutQuestion_applysInput, WriteQuestionUncheckedCreateWithoutQuestion_applysInput>
  }

  export type TeacherCreateWithoutWrite_question_applysInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    username: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    task_applys?: TaskApplyCreateNestedManyWithoutTeacherInput
    teacher_training_applys?: TrainingApplyCreateNestedManyWithoutTeacherInput
    choice_answer_applys?: ChoiceAnswerApplyCreateNestedManyWithoutTeacherInput
    teacher_personal_info?: TeacherPersonalInfoCreateNestedManyWithoutTeacherInput
    teacher_workplace?: TeacherWorkplaceCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutWrite_question_applysInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    username: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    task_applys?: TaskApplyUncheckedCreateNestedManyWithoutTeacherInput
    teacher_training_applys?: TrainingApplyUncheckedCreateNestedManyWithoutTeacherInput
    choice_answer_applys?: ChoiceAnswerApplyUncheckedCreateNestedManyWithoutTeacherInput
    teacher_personal_info?: TeacherPersonalInfoUncheckedCreateNestedManyWithoutTeacherInput
    teacher_workplace?: TeacherWorkplaceUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutWrite_question_applysInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutWrite_question_applysInput, TeacherUncheckedCreateWithoutWrite_question_applysInput>
  }

  export type WriteQuestionUpsertWithoutQuestion_applysInput = {
    update: XOR<WriteQuestionUpdateWithoutQuestion_applysInput, WriteQuestionUncheckedUpdateWithoutQuestion_applysInput>
    create: XOR<WriteQuestionCreateWithoutQuestion_applysInput, WriteQuestionUncheckedCreateWithoutQuestion_applysInput>
    where?: WriteQuestionWhereInput
  }

  export type WriteQuestionUpdateToOneWithWhereWithoutQuestion_applysInput = {
    where?: WriteQuestionWhereInput
    data: XOR<WriteQuestionUpdateWithoutQuestion_applysInput, WriteQuestionUncheckedUpdateWithoutQuestion_applysInput>
  }

  export type WriteQuestionUpdateWithoutQuestion_applysInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    correct_answer?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WriteQuestionUncheckedUpdateWithoutQuestion_applysInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    correct_answer?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherUpsertWithoutWrite_question_applysInput = {
    update: XOR<TeacherUpdateWithoutWrite_question_applysInput, TeacherUncheckedUpdateWithoutWrite_question_applysInput>
    create: XOR<TeacherCreateWithoutWrite_question_applysInput, TeacherUncheckedCreateWithoutWrite_question_applysInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutWrite_question_applysInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutWrite_question_applysInput, TeacherUncheckedUpdateWithoutWrite_question_applysInput>
  }

  export type TeacherUpdateWithoutWrite_question_applysInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_applys?: TaskApplyUpdateManyWithoutTeacherNestedInput
    teacher_training_applys?: TrainingApplyUpdateManyWithoutTeacherNestedInput
    choice_answer_applys?: ChoiceAnswerApplyUpdateManyWithoutTeacherNestedInput
    teacher_personal_info?: TeacherPersonalInfoUpdateManyWithoutTeacherNestedInput
    teacher_workplace?: TeacherWorkplaceUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutWrite_question_applysInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_applys?: TaskApplyUncheckedUpdateManyWithoutTeacherNestedInput
    teacher_training_applys?: TrainingApplyUncheckedUpdateManyWithoutTeacherNestedInput
    choice_answer_applys?: ChoiceAnswerApplyUncheckedUpdateManyWithoutTeacherNestedInput
    teacher_personal_info?: TeacherPersonalInfoUncheckedUpdateManyWithoutTeacherNestedInput
    teacher_workplace?: TeacherWorkplaceUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TrainingApplyCreateWithoutTrainInput = {
    id?: string
    text?: string | null
    file?: string | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    teacher: TeacherCreateNestedOneWithoutTeacher_training_applysInput
    checking_applys?: CheckTrainingApplyCreateNestedManyWithoutTraining_applyInput
  }

  export type TrainingApplyUncheckedCreateWithoutTrainInput = {
    id?: string
    teacherId: string
    text?: string | null
    file?: string | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    checking_applys?: CheckTrainingApplyUncheckedCreateNestedManyWithoutTraining_applyInput
  }

  export type TrainingApplyCreateOrConnectWithoutTrainInput = {
    where: TrainingApplyWhereUniqueInput
    create: XOR<TrainingApplyCreateWithoutTrainInput, TrainingApplyUncheckedCreateWithoutTrainInput>
  }

  export type TrainingApplyCreateManyTrainInputEnvelope = {
    data: TrainingApplyCreateManyTrainInput | TrainingApplyCreateManyTrainInput[]
    skipDuplicates?: boolean
  }

  export type TrainingApplyUpsertWithWhereUniqueWithoutTrainInput = {
    where: TrainingApplyWhereUniqueInput
    update: XOR<TrainingApplyUpdateWithoutTrainInput, TrainingApplyUncheckedUpdateWithoutTrainInput>
    create: XOR<TrainingApplyCreateWithoutTrainInput, TrainingApplyUncheckedCreateWithoutTrainInput>
  }

  export type TrainingApplyUpdateWithWhereUniqueWithoutTrainInput = {
    where: TrainingApplyWhereUniqueInput
    data: XOR<TrainingApplyUpdateWithoutTrainInput, TrainingApplyUncheckedUpdateWithoutTrainInput>
  }

  export type TrainingApplyUpdateManyWithWhereWithoutTrainInput = {
    where: TrainingApplyScalarWhereInput
    data: XOR<TrainingApplyUpdateManyMutationInput, TrainingApplyUncheckedUpdateManyWithoutTrainInput>
  }

  export type TrainingApplyScalarWhereInput = {
    AND?: TrainingApplyScalarWhereInput | TrainingApplyScalarWhereInput[]
    OR?: TrainingApplyScalarWhereInput[]
    NOT?: TrainingApplyScalarWhereInput | TrainingApplyScalarWhereInput[]
    id?: StringFilter<"TrainingApply"> | string
    trainingId?: StringFilter<"TrainingApply"> | string
    teacherId?: StringFilter<"TrainingApply"> | string
    text?: StringNullableFilter<"TrainingApply"> | string | null
    file?: StringNullableFilter<"TrainingApply"> | string | null
    is_seen?: BoolNullableFilter<"TrainingApply"> | boolean | null
    created_at?: DateTimeFilter<"TrainingApply"> | Date | string
    updated_at?: DateTimeFilter<"TrainingApply"> | Date | string
  }

  export type TrainingCreateWithoutTraining_applysInput = {
    id?: string
    title: string
    description?: string | null
    subject?: string | null
    max_score?: number | null
    pass_score?: number | null
    file?: string | null
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TrainingUncheckedCreateWithoutTraining_applysInput = {
    id?: string
    title: string
    description?: string | null
    subject?: string | null
    max_score?: number | null
    pass_score?: number | null
    file?: string | null
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TrainingCreateOrConnectWithoutTraining_applysInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutTraining_applysInput, TrainingUncheckedCreateWithoutTraining_applysInput>
  }

  export type TeacherCreateWithoutTeacher_training_applysInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    username: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    task_applys?: TaskApplyCreateNestedManyWithoutTeacherInput
    write_question_applys?: WriteQuestionApplyCreateNestedManyWithoutTeacherInput
    choice_answer_applys?: ChoiceAnswerApplyCreateNestedManyWithoutTeacherInput
    teacher_personal_info?: TeacherPersonalInfoCreateNestedManyWithoutTeacherInput
    teacher_workplace?: TeacherWorkplaceCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutTeacher_training_applysInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    username: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    task_applys?: TaskApplyUncheckedCreateNestedManyWithoutTeacherInput
    write_question_applys?: WriteQuestionApplyUncheckedCreateNestedManyWithoutTeacherInput
    choice_answer_applys?: ChoiceAnswerApplyUncheckedCreateNestedManyWithoutTeacherInput
    teacher_personal_info?: TeacherPersonalInfoUncheckedCreateNestedManyWithoutTeacherInput
    teacher_workplace?: TeacherWorkplaceUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutTeacher_training_applysInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutTeacher_training_applysInput, TeacherUncheckedCreateWithoutTeacher_training_applysInput>
  }

  export type CheckTrainingApplyCreateWithoutTraining_applyInput = {
    id?: string
    description?: string | null
    score?: number
    is_active?: boolean | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CheckTrainingApplyUncheckedCreateWithoutTraining_applyInput = {
    id?: string
    description?: string | null
    score?: number
    is_active?: boolean | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CheckTrainingApplyCreateOrConnectWithoutTraining_applyInput = {
    where: CheckTrainingApplyWhereUniqueInput
    create: XOR<CheckTrainingApplyCreateWithoutTraining_applyInput, CheckTrainingApplyUncheckedCreateWithoutTraining_applyInput>
  }

  export type CheckTrainingApplyCreateManyTraining_applyInputEnvelope = {
    data: CheckTrainingApplyCreateManyTraining_applyInput | CheckTrainingApplyCreateManyTraining_applyInput[]
    skipDuplicates?: boolean
  }

  export type TrainingUpsertWithoutTraining_applysInput = {
    update: XOR<TrainingUpdateWithoutTraining_applysInput, TrainingUncheckedUpdateWithoutTraining_applysInput>
    create: XOR<TrainingCreateWithoutTraining_applysInput, TrainingUncheckedCreateWithoutTraining_applysInput>
    where?: TrainingWhereInput
  }

  export type TrainingUpdateToOneWithWhereWithoutTraining_applysInput = {
    where?: TrainingWhereInput
    data: XOR<TrainingUpdateWithoutTraining_applysInput, TrainingUncheckedUpdateWithoutTraining_applysInput>
  }

  export type TrainingUpdateWithoutTraining_applysInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    max_score?: NullableIntFieldUpdateOperationsInput | number | null
    pass_score?: NullableIntFieldUpdateOperationsInput | number | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingUncheckedUpdateWithoutTraining_applysInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    max_score?: NullableIntFieldUpdateOperationsInput | number | null
    pass_score?: NullableIntFieldUpdateOperationsInput | number | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherUpsertWithoutTeacher_training_applysInput = {
    update: XOR<TeacherUpdateWithoutTeacher_training_applysInput, TeacherUncheckedUpdateWithoutTeacher_training_applysInput>
    create: XOR<TeacherCreateWithoutTeacher_training_applysInput, TeacherUncheckedCreateWithoutTeacher_training_applysInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutTeacher_training_applysInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutTeacher_training_applysInput, TeacherUncheckedUpdateWithoutTeacher_training_applysInput>
  }

  export type TeacherUpdateWithoutTeacher_training_applysInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_applys?: TaskApplyUpdateManyWithoutTeacherNestedInput
    write_question_applys?: WriteQuestionApplyUpdateManyWithoutTeacherNestedInput
    choice_answer_applys?: ChoiceAnswerApplyUpdateManyWithoutTeacherNestedInput
    teacher_personal_info?: TeacherPersonalInfoUpdateManyWithoutTeacherNestedInput
    teacher_workplace?: TeacherWorkplaceUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutTeacher_training_applysInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_applys?: TaskApplyUncheckedUpdateManyWithoutTeacherNestedInput
    write_question_applys?: WriteQuestionApplyUncheckedUpdateManyWithoutTeacherNestedInput
    choice_answer_applys?: ChoiceAnswerApplyUncheckedUpdateManyWithoutTeacherNestedInput
    teacher_personal_info?: TeacherPersonalInfoUncheckedUpdateManyWithoutTeacherNestedInput
    teacher_workplace?: TeacherWorkplaceUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type CheckTrainingApplyUpsertWithWhereUniqueWithoutTraining_applyInput = {
    where: CheckTrainingApplyWhereUniqueInput
    update: XOR<CheckTrainingApplyUpdateWithoutTraining_applyInput, CheckTrainingApplyUncheckedUpdateWithoutTraining_applyInput>
    create: XOR<CheckTrainingApplyCreateWithoutTraining_applyInput, CheckTrainingApplyUncheckedCreateWithoutTraining_applyInput>
  }

  export type CheckTrainingApplyUpdateWithWhereUniqueWithoutTraining_applyInput = {
    where: CheckTrainingApplyWhereUniqueInput
    data: XOR<CheckTrainingApplyUpdateWithoutTraining_applyInput, CheckTrainingApplyUncheckedUpdateWithoutTraining_applyInput>
  }

  export type CheckTrainingApplyUpdateManyWithWhereWithoutTraining_applyInput = {
    where: CheckTrainingApplyScalarWhereInput
    data: XOR<CheckTrainingApplyUpdateManyMutationInput, CheckTrainingApplyUncheckedUpdateManyWithoutTraining_applyInput>
  }

  export type CheckTrainingApplyScalarWhereInput = {
    AND?: CheckTrainingApplyScalarWhereInput | CheckTrainingApplyScalarWhereInput[]
    OR?: CheckTrainingApplyScalarWhereInput[]
    NOT?: CheckTrainingApplyScalarWhereInput | CheckTrainingApplyScalarWhereInput[]
    id?: StringFilter<"CheckTrainingApply"> | string
    training_applyId?: StringFilter<"CheckTrainingApply"> | string
    description?: StringNullableFilter<"CheckTrainingApply"> | string | null
    score?: IntFilter<"CheckTrainingApply"> | number
    is_active?: BoolNullableFilter<"CheckTrainingApply"> | boolean | null
    is_seen?: BoolNullableFilter<"CheckTrainingApply"> | boolean | null
    created_at?: DateTimeFilter<"CheckTrainingApply"> | Date | string
    updated_at?: DateTimeFilter<"CheckTrainingApply"> | Date | string
  }

  export type TrainingApplyCreateWithoutChecking_applysInput = {
    id?: string
    text?: string | null
    file?: string | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    train: TrainingCreateNestedOneWithoutTraining_applysInput
    teacher: TeacherCreateNestedOneWithoutTeacher_training_applysInput
  }

  export type TrainingApplyUncheckedCreateWithoutChecking_applysInput = {
    id?: string
    trainingId: string
    teacherId: string
    text?: string | null
    file?: string | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TrainingApplyCreateOrConnectWithoutChecking_applysInput = {
    where: TrainingApplyWhereUniqueInput
    create: XOR<TrainingApplyCreateWithoutChecking_applysInput, TrainingApplyUncheckedCreateWithoutChecking_applysInput>
  }

  export type TrainingApplyUpsertWithoutChecking_applysInput = {
    update: XOR<TrainingApplyUpdateWithoutChecking_applysInput, TrainingApplyUncheckedUpdateWithoutChecking_applysInput>
    create: XOR<TrainingApplyCreateWithoutChecking_applysInput, TrainingApplyUncheckedCreateWithoutChecking_applysInput>
    where?: TrainingApplyWhereInput
  }

  export type TrainingApplyUpdateToOneWithWhereWithoutChecking_applysInput = {
    where?: TrainingApplyWhereInput
    data: XOR<TrainingApplyUpdateWithoutChecking_applysInput, TrainingApplyUncheckedUpdateWithoutChecking_applysInput>
  }

  export type TrainingApplyUpdateWithoutChecking_applysInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    train?: TrainingUpdateOneRequiredWithoutTraining_applysNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutTeacher_training_applysNestedInput
  }

  export type TrainingApplyUncheckedUpdateWithoutChecking_applysInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateWithoutLessonInput = {
    id?: string
    title: string
    description?: string | null
    file?: string | null
    score?: number
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    criterias?: TaskCriteriaCreateNestedManyWithoutTaskInput
    task_applys?: TaskApplyCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutLessonInput = {
    id?: string
    title: string
    description?: string | null
    file?: string | null
    score?: number
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    criterias?: TaskCriteriaUncheckedCreateNestedManyWithoutTaskInput
    task_applys?: TaskApplyUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutLessonInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutLessonInput, TaskUncheckedCreateWithoutLessonInput>
  }

  export type TaskCreateManyLessonInputEnvelope = {
    data: TaskCreateManyLessonInput | TaskCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type TaskUpsertWithWhereUniqueWithoutLessonInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutLessonInput, TaskUncheckedUpdateWithoutLessonInput>
    create: XOR<TaskCreateWithoutLessonInput, TaskUncheckedCreateWithoutLessonInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutLessonInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutLessonInput, TaskUncheckedUpdateWithoutLessonInput>
  }

  export type TaskUpdateManyWithWhereWithoutLessonInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutLessonInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    file?: StringNullableFilter<"Task"> | string | null
    score?: IntFilter<"Task"> | number
    is_active?: BoolNullableFilter<"Task"> | boolean | null
    lessonId?: StringFilter<"Task"> | string
    created_at?: DateTimeFilter<"Task"> | Date | string
    updated_at?: DateTimeFilter<"Task"> | Date | string
  }

  export type LessonCreateWithoutTasksInput = {
    id?: string
    title: string
    description?: string | null
    file?: string | null
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LessonUncheckedCreateWithoutTasksInput = {
    id?: string
    title: string
    description?: string | null
    file?: string | null
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LessonCreateOrConnectWithoutTasksInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutTasksInput, LessonUncheckedCreateWithoutTasksInput>
  }

  export type TaskCriteriaCreateWithoutTaskInput = {
    id?: string
    key: string
    value: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    checks_criterias?: CheckWithTaskCriteriasCreateNestedManyWithoutTask_criteriaInput
  }

  export type TaskCriteriaUncheckedCreateWithoutTaskInput = {
    id?: string
    key: string
    value: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    checks_criterias?: CheckWithTaskCriteriasUncheckedCreateNestedManyWithoutTask_criteriaInput
  }

  export type TaskCriteriaCreateOrConnectWithoutTaskInput = {
    where: TaskCriteriaWhereUniqueInput
    create: XOR<TaskCriteriaCreateWithoutTaskInput, TaskCriteriaUncheckedCreateWithoutTaskInput>
  }

  export type TaskCriteriaCreateManyTaskInputEnvelope = {
    data: TaskCriteriaCreateManyTaskInput | TaskCriteriaCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskApplyCreateWithoutTaskInput = {
    id?: string
    overall_score?: number | null
    description: string
    file?: string | null
    is_active?: boolean | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    teacher: TeacherCreateNestedOneWithoutTask_applysInput
    check_task_criterias?: CheckWithTaskCriteriasCreateNestedManyWithoutTask_applyInput
  }

  export type TaskApplyUncheckedCreateWithoutTaskInput = {
    id?: string
    teacherId: string
    overall_score?: number | null
    description: string
    file?: string | null
    is_active?: boolean | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    check_task_criterias?: CheckWithTaskCriteriasUncheckedCreateNestedManyWithoutTask_applyInput
  }

  export type TaskApplyCreateOrConnectWithoutTaskInput = {
    where: TaskApplyWhereUniqueInput
    create: XOR<TaskApplyCreateWithoutTaskInput, TaskApplyUncheckedCreateWithoutTaskInput>
  }

  export type TaskApplyCreateManyTaskInputEnvelope = {
    data: TaskApplyCreateManyTaskInput | TaskApplyCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type LessonUpsertWithoutTasksInput = {
    update: XOR<LessonUpdateWithoutTasksInput, LessonUncheckedUpdateWithoutTasksInput>
    create: XOR<LessonCreateWithoutTasksInput, LessonUncheckedCreateWithoutTasksInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutTasksInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutTasksInput, LessonUncheckedUpdateWithoutTasksInput>
  }

  export type LessonUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCriteriaUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskCriteriaWhereUniqueInput
    update: XOR<TaskCriteriaUpdateWithoutTaskInput, TaskCriteriaUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskCriteriaCreateWithoutTaskInput, TaskCriteriaUncheckedCreateWithoutTaskInput>
  }

  export type TaskCriteriaUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskCriteriaWhereUniqueInput
    data: XOR<TaskCriteriaUpdateWithoutTaskInput, TaskCriteriaUncheckedUpdateWithoutTaskInput>
  }

  export type TaskCriteriaUpdateManyWithWhereWithoutTaskInput = {
    where: TaskCriteriaScalarWhereInput
    data: XOR<TaskCriteriaUpdateManyMutationInput, TaskCriteriaUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskCriteriaScalarWhereInput = {
    AND?: TaskCriteriaScalarWhereInput | TaskCriteriaScalarWhereInput[]
    OR?: TaskCriteriaScalarWhereInput[]
    NOT?: TaskCriteriaScalarWhereInput | TaskCriteriaScalarWhereInput[]
    id?: StringFilter<"TaskCriteria"> | string
    key?: StringFilter<"TaskCriteria"> | string
    value?: IntFilter<"TaskCriteria"> | number
    description?: StringNullableFilter<"TaskCriteria"> | string | null
    taskId?: StringFilter<"TaskCriteria"> | string
    created_at?: DateTimeFilter<"TaskCriteria"> | Date | string
    updated_at?: DateTimeFilter<"TaskCriteria"> | Date | string
  }

  export type TaskApplyUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskApplyWhereUniqueInput
    update: XOR<TaskApplyUpdateWithoutTaskInput, TaskApplyUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskApplyCreateWithoutTaskInput, TaskApplyUncheckedCreateWithoutTaskInput>
  }

  export type TaskApplyUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskApplyWhereUniqueInput
    data: XOR<TaskApplyUpdateWithoutTaskInput, TaskApplyUncheckedUpdateWithoutTaskInput>
  }

  export type TaskApplyUpdateManyWithWhereWithoutTaskInput = {
    where: TaskApplyScalarWhereInput
    data: XOR<TaskApplyUpdateManyMutationInput, TaskApplyUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskApplyScalarWhereInput = {
    AND?: TaskApplyScalarWhereInput | TaskApplyScalarWhereInput[]
    OR?: TaskApplyScalarWhereInput[]
    NOT?: TaskApplyScalarWhereInput | TaskApplyScalarWhereInput[]
    id?: StringFilter<"TaskApply"> | string
    teacherId?: StringFilter<"TaskApply"> | string
    taskId?: StringFilter<"TaskApply"> | string
    overall_score?: IntNullableFilter<"TaskApply"> | number | null
    description?: StringFilter<"TaskApply"> | string
    file?: StringNullableFilter<"TaskApply"> | string | null
    is_active?: BoolNullableFilter<"TaskApply"> | boolean | null
    is_seen?: BoolNullableFilter<"TaskApply"> | boolean | null
    created_at?: DateTimeFilter<"TaskApply"> | Date | string
    updated_at?: DateTimeFilter<"TaskApply"> | Date | string
  }

  export type TaskCreateWithoutCriteriasInput = {
    id?: string
    title: string
    description?: string | null
    file?: string | null
    score?: number
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    lesson: LessonCreateNestedOneWithoutTasksInput
    task_applys?: TaskApplyCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutCriteriasInput = {
    id?: string
    title: string
    description?: string | null
    file?: string | null
    score?: number
    is_active?: boolean | null
    lessonId: string
    created_at?: Date | string
    updated_at?: Date | string
    task_applys?: TaskApplyUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutCriteriasInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCriteriasInput, TaskUncheckedCreateWithoutCriteriasInput>
  }

  export type CheckWithTaskCriteriasCreateWithoutTask_criteriaInput = {
    id?: string
    criteria_score?: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    task_apply: TaskApplyCreateNestedOneWithoutCheck_task_criteriasInput
  }

  export type CheckWithTaskCriteriasUncheckedCreateWithoutTask_criteriaInput = {
    id?: string
    task_applyId: string
    criteria_score?: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CheckWithTaskCriteriasCreateOrConnectWithoutTask_criteriaInput = {
    where: CheckWithTaskCriteriasWhereUniqueInput
    create: XOR<CheckWithTaskCriteriasCreateWithoutTask_criteriaInput, CheckWithTaskCriteriasUncheckedCreateWithoutTask_criteriaInput>
  }

  export type CheckWithTaskCriteriasCreateManyTask_criteriaInputEnvelope = {
    data: CheckWithTaskCriteriasCreateManyTask_criteriaInput | CheckWithTaskCriteriasCreateManyTask_criteriaInput[]
    skipDuplicates?: boolean
  }

  export type TaskUpsertWithoutCriteriasInput = {
    update: XOR<TaskUpdateWithoutCriteriasInput, TaskUncheckedUpdateWithoutCriteriasInput>
    create: XOR<TaskCreateWithoutCriteriasInput, TaskUncheckedCreateWithoutCriteriasInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutCriteriasInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutCriteriasInput, TaskUncheckedUpdateWithoutCriteriasInput>
  }

  export type TaskUpdateWithoutCriteriasInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutTasksNestedInput
    task_applys?: TaskApplyUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutCriteriasInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lessonId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_applys?: TaskApplyUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type CheckWithTaskCriteriasUpsertWithWhereUniqueWithoutTask_criteriaInput = {
    where: CheckWithTaskCriteriasWhereUniqueInput
    update: XOR<CheckWithTaskCriteriasUpdateWithoutTask_criteriaInput, CheckWithTaskCriteriasUncheckedUpdateWithoutTask_criteriaInput>
    create: XOR<CheckWithTaskCriteriasCreateWithoutTask_criteriaInput, CheckWithTaskCriteriasUncheckedCreateWithoutTask_criteriaInput>
  }

  export type CheckWithTaskCriteriasUpdateWithWhereUniqueWithoutTask_criteriaInput = {
    where: CheckWithTaskCriteriasWhereUniqueInput
    data: XOR<CheckWithTaskCriteriasUpdateWithoutTask_criteriaInput, CheckWithTaskCriteriasUncheckedUpdateWithoutTask_criteriaInput>
  }

  export type CheckWithTaskCriteriasUpdateManyWithWhereWithoutTask_criteriaInput = {
    where: CheckWithTaskCriteriasScalarWhereInput
    data: XOR<CheckWithTaskCriteriasUpdateManyMutationInput, CheckWithTaskCriteriasUncheckedUpdateManyWithoutTask_criteriaInput>
  }

  export type CheckWithTaskCriteriasScalarWhereInput = {
    AND?: CheckWithTaskCriteriasScalarWhereInput | CheckWithTaskCriteriasScalarWhereInput[]
    OR?: CheckWithTaskCriteriasScalarWhereInput[]
    NOT?: CheckWithTaskCriteriasScalarWhereInput | CheckWithTaskCriteriasScalarWhereInput[]
    id?: StringFilter<"CheckWithTaskCriterias"> | string
    task_applyId?: StringFilter<"CheckWithTaskCriterias"> | string
    task_criteriaId?: StringFilter<"CheckWithTaskCriterias"> | string
    criteria_score?: IntFilter<"CheckWithTaskCriterias"> | number
    description?: StringNullableFilter<"CheckWithTaskCriterias"> | string | null
    created_at?: DateTimeFilter<"CheckWithTaskCriterias"> | Date | string
    updated_at?: DateTimeFilter<"CheckWithTaskCriterias"> | Date | string
  }

  export type TeacherCreateWithoutTask_applysInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    username: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    teacher_training_applys?: TrainingApplyCreateNestedManyWithoutTeacherInput
    write_question_applys?: WriteQuestionApplyCreateNestedManyWithoutTeacherInput
    choice_answer_applys?: ChoiceAnswerApplyCreateNestedManyWithoutTeacherInput
    teacher_personal_info?: TeacherPersonalInfoCreateNestedManyWithoutTeacherInput
    teacher_workplace?: TeacherWorkplaceCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutTask_applysInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    username: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    teacher_training_applys?: TrainingApplyUncheckedCreateNestedManyWithoutTeacherInput
    write_question_applys?: WriteQuestionApplyUncheckedCreateNestedManyWithoutTeacherInput
    choice_answer_applys?: ChoiceAnswerApplyUncheckedCreateNestedManyWithoutTeacherInput
    teacher_personal_info?: TeacherPersonalInfoUncheckedCreateNestedManyWithoutTeacherInput
    teacher_workplace?: TeacherWorkplaceUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutTask_applysInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutTask_applysInput, TeacherUncheckedCreateWithoutTask_applysInput>
  }

  export type TaskCreateWithoutTask_applysInput = {
    id?: string
    title: string
    description?: string | null
    file?: string | null
    score?: number
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    lesson: LessonCreateNestedOneWithoutTasksInput
    criterias?: TaskCriteriaCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutTask_applysInput = {
    id?: string
    title: string
    description?: string | null
    file?: string | null
    score?: number
    is_active?: boolean | null
    lessonId: string
    created_at?: Date | string
    updated_at?: Date | string
    criterias?: TaskCriteriaUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutTask_applysInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTask_applysInput, TaskUncheckedCreateWithoutTask_applysInput>
  }

  export type CheckWithTaskCriteriasCreateWithoutTask_applyInput = {
    id?: string
    criteria_score?: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    task_criteria: TaskCriteriaCreateNestedOneWithoutChecks_criteriasInput
  }

  export type CheckWithTaskCriteriasUncheckedCreateWithoutTask_applyInput = {
    id?: string
    task_criteriaId: string
    criteria_score?: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CheckWithTaskCriteriasCreateOrConnectWithoutTask_applyInput = {
    where: CheckWithTaskCriteriasWhereUniqueInput
    create: XOR<CheckWithTaskCriteriasCreateWithoutTask_applyInput, CheckWithTaskCriteriasUncheckedCreateWithoutTask_applyInput>
  }

  export type CheckWithTaskCriteriasCreateManyTask_applyInputEnvelope = {
    data: CheckWithTaskCriteriasCreateManyTask_applyInput | CheckWithTaskCriteriasCreateManyTask_applyInput[]
    skipDuplicates?: boolean
  }

  export type TeacherUpsertWithoutTask_applysInput = {
    update: XOR<TeacherUpdateWithoutTask_applysInput, TeacherUncheckedUpdateWithoutTask_applysInput>
    create: XOR<TeacherCreateWithoutTask_applysInput, TeacherUncheckedCreateWithoutTask_applysInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutTask_applysInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutTask_applysInput, TeacherUncheckedUpdateWithoutTask_applysInput>
  }

  export type TeacherUpdateWithoutTask_applysInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher_training_applys?: TrainingApplyUpdateManyWithoutTeacherNestedInput
    write_question_applys?: WriteQuestionApplyUpdateManyWithoutTeacherNestedInput
    choice_answer_applys?: ChoiceAnswerApplyUpdateManyWithoutTeacherNestedInput
    teacher_personal_info?: TeacherPersonalInfoUpdateManyWithoutTeacherNestedInput
    teacher_workplace?: TeacherWorkplaceUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutTask_applysInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher_training_applys?: TrainingApplyUncheckedUpdateManyWithoutTeacherNestedInput
    write_question_applys?: WriteQuestionApplyUncheckedUpdateManyWithoutTeacherNestedInput
    choice_answer_applys?: ChoiceAnswerApplyUncheckedUpdateManyWithoutTeacherNestedInput
    teacher_personal_info?: TeacherPersonalInfoUncheckedUpdateManyWithoutTeacherNestedInput
    teacher_workplace?: TeacherWorkplaceUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TaskUpsertWithoutTask_applysInput = {
    update: XOR<TaskUpdateWithoutTask_applysInput, TaskUncheckedUpdateWithoutTask_applysInput>
    create: XOR<TaskCreateWithoutTask_applysInput, TaskUncheckedCreateWithoutTask_applysInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutTask_applysInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutTask_applysInput, TaskUncheckedUpdateWithoutTask_applysInput>
  }

  export type TaskUpdateWithoutTask_applysInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutTasksNestedInput
    criterias?: TaskCriteriaUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutTask_applysInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lessonId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    criterias?: TaskCriteriaUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type CheckWithTaskCriteriasUpsertWithWhereUniqueWithoutTask_applyInput = {
    where: CheckWithTaskCriteriasWhereUniqueInput
    update: XOR<CheckWithTaskCriteriasUpdateWithoutTask_applyInput, CheckWithTaskCriteriasUncheckedUpdateWithoutTask_applyInput>
    create: XOR<CheckWithTaskCriteriasCreateWithoutTask_applyInput, CheckWithTaskCriteriasUncheckedCreateWithoutTask_applyInput>
  }

  export type CheckWithTaskCriteriasUpdateWithWhereUniqueWithoutTask_applyInput = {
    where: CheckWithTaskCriteriasWhereUniqueInput
    data: XOR<CheckWithTaskCriteriasUpdateWithoutTask_applyInput, CheckWithTaskCriteriasUncheckedUpdateWithoutTask_applyInput>
  }

  export type CheckWithTaskCriteriasUpdateManyWithWhereWithoutTask_applyInput = {
    where: CheckWithTaskCriteriasScalarWhereInput
    data: XOR<CheckWithTaskCriteriasUpdateManyMutationInput, CheckWithTaskCriteriasUncheckedUpdateManyWithoutTask_applyInput>
  }

  export type TaskApplyCreateWithoutCheck_task_criteriasInput = {
    id?: string
    overall_score?: number | null
    description: string
    file?: string | null
    is_active?: boolean | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    teacher: TeacherCreateNestedOneWithoutTask_applysInput
    task: TaskCreateNestedOneWithoutTask_applysInput
  }

  export type TaskApplyUncheckedCreateWithoutCheck_task_criteriasInput = {
    id?: string
    teacherId: string
    taskId: string
    overall_score?: number | null
    description: string
    file?: string | null
    is_active?: boolean | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TaskApplyCreateOrConnectWithoutCheck_task_criteriasInput = {
    where: TaskApplyWhereUniqueInput
    create: XOR<TaskApplyCreateWithoutCheck_task_criteriasInput, TaskApplyUncheckedCreateWithoutCheck_task_criteriasInput>
  }

  export type TaskCriteriaCreateWithoutChecks_criteriasInput = {
    id?: string
    key: string
    value: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    task: TaskCreateNestedOneWithoutCriteriasInput
  }

  export type TaskCriteriaUncheckedCreateWithoutChecks_criteriasInput = {
    id?: string
    key: string
    value: number
    description?: string | null
    taskId: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TaskCriteriaCreateOrConnectWithoutChecks_criteriasInput = {
    where: TaskCriteriaWhereUniqueInput
    create: XOR<TaskCriteriaCreateWithoutChecks_criteriasInput, TaskCriteriaUncheckedCreateWithoutChecks_criteriasInput>
  }

  export type TaskApplyUpsertWithoutCheck_task_criteriasInput = {
    update: XOR<TaskApplyUpdateWithoutCheck_task_criteriasInput, TaskApplyUncheckedUpdateWithoutCheck_task_criteriasInput>
    create: XOR<TaskApplyCreateWithoutCheck_task_criteriasInput, TaskApplyUncheckedCreateWithoutCheck_task_criteriasInput>
    where?: TaskApplyWhereInput
  }

  export type TaskApplyUpdateToOneWithWhereWithoutCheck_task_criteriasInput = {
    where?: TaskApplyWhereInput
    data: XOR<TaskApplyUpdateWithoutCheck_task_criteriasInput, TaskApplyUncheckedUpdateWithoutCheck_task_criteriasInput>
  }

  export type TaskApplyUpdateWithoutCheck_task_criteriasInput = {
    id?: StringFieldUpdateOperationsInput | string
    overall_score?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutTask_applysNestedInput
    task?: TaskUpdateOneRequiredWithoutTask_applysNestedInput
  }

  export type TaskApplyUncheckedUpdateWithoutCheck_task_criteriasInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    overall_score?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCriteriaUpsertWithoutChecks_criteriasInput = {
    update: XOR<TaskCriteriaUpdateWithoutChecks_criteriasInput, TaskCriteriaUncheckedUpdateWithoutChecks_criteriasInput>
    create: XOR<TaskCriteriaCreateWithoutChecks_criteriasInput, TaskCriteriaUncheckedCreateWithoutChecks_criteriasInput>
    where?: TaskCriteriaWhereInput
  }

  export type TaskCriteriaUpdateToOneWithWhereWithoutChecks_criteriasInput = {
    where?: TaskCriteriaWhereInput
    data: XOR<TaskCriteriaUpdateWithoutChecks_criteriasInput, TaskCriteriaUncheckedUpdateWithoutChecks_criteriasInput>
  }

  export type TaskCriteriaUpdateWithoutChecks_criteriasInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutCriteriasNestedInput
  }

  export type TaskCriteriaUncheckedUpdateWithoutChecks_criteriasInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskApplyCreateWithoutTeacherInput = {
    id?: string
    overall_score?: number | null
    description: string
    file?: string | null
    is_active?: boolean | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    task: TaskCreateNestedOneWithoutTask_applysInput
    check_task_criterias?: CheckWithTaskCriteriasCreateNestedManyWithoutTask_applyInput
  }

  export type TaskApplyUncheckedCreateWithoutTeacherInput = {
    id?: string
    taskId: string
    overall_score?: number | null
    description: string
    file?: string | null
    is_active?: boolean | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    check_task_criterias?: CheckWithTaskCriteriasUncheckedCreateNestedManyWithoutTask_applyInput
  }

  export type TaskApplyCreateOrConnectWithoutTeacherInput = {
    where: TaskApplyWhereUniqueInput
    create: XOR<TaskApplyCreateWithoutTeacherInput, TaskApplyUncheckedCreateWithoutTeacherInput>
  }

  export type TaskApplyCreateManyTeacherInputEnvelope = {
    data: TaskApplyCreateManyTeacherInput | TaskApplyCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type TrainingApplyCreateWithoutTeacherInput = {
    id?: string
    text?: string | null
    file?: string | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    train: TrainingCreateNestedOneWithoutTraining_applysInput
    checking_applys?: CheckTrainingApplyCreateNestedManyWithoutTraining_applyInput
  }

  export type TrainingApplyUncheckedCreateWithoutTeacherInput = {
    id?: string
    trainingId: string
    text?: string | null
    file?: string | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    checking_applys?: CheckTrainingApplyUncheckedCreateNestedManyWithoutTraining_applyInput
  }

  export type TrainingApplyCreateOrConnectWithoutTeacherInput = {
    where: TrainingApplyWhereUniqueInput
    create: XOR<TrainingApplyCreateWithoutTeacherInput, TrainingApplyUncheckedCreateWithoutTeacherInput>
  }

  export type TrainingApplyCreateManyTeacherInputEnvelope = {
    data: TrainingApplyCreateManyTeacherInput | TrainingApplyCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type WriteQuestionApplyCreateWithoutTeacherInput = {
    id?: string
    value: string
    is_correct?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    question: WriteQuestionCreateNestedOneWithoutQuestion_applysInput
  }

  export type WriteQuestionApplyUncheckedCreateWithoutTeacherInput = {
    id?: string
    questionId: string
    value: string
    is_correct?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WriteQuestionApplyCreateOrConnectWithoutTeacherInput = {
    where: WriteQuestionApplyWhereUniqueInput
    create: XOR<WriteQuestionApplyCreateWithoutTeacherInput, WriteQuestionApplyUncheckedCreateWithoutTeacherInput>
  }

  export type WriteQuestionApplyCreateManyTeacherInputEnvelope = {
    data: WriteQuestionApplyCreateManyTeacherInput | WriteQuestionApplyCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type ChoiceAnswerApplyCreateWithoutTeacherInput = {
    id?: string
    key: string
    is_correct?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    answer: ChoiceAnswerCreateNestedOneWithoutChoice_answer_applysInput
  }

  export type ChoiceAnswerApplyUncheckedCreateWithoutTeacherInput = {
    id?: string
    answerId: string
    key: string
    is_correct?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChoiceAnswerApplyCreateOrConnectWithoutTeacherInput = {
    where: ChoiceAnswerApplyWhereUniqueInput
    create: XOR<ChoiceAnswerApplyCreateWithoutTeacherInput, ChoiceAnswerApplyUncheckedCreateWithoutTeacherInput>
  }

  export type ChoiceAnswerApplyCreateManyTeacherInputEnvelope = {
    data: ChoiceAnswerApplyCreateManyTeacherInput | ChoiceAnswerApplyCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type TeacherPersonalInfoCreateWithoutTeacherInput = {
    id?: string
    nationality?: string | null
    gender?: string | null
    birthDate?: string | null
    passport_serial?: string | null
    is_active?: boolean
    photo?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TeacherPersonalInfoUncheckedCreateWithoutTeacherInput = {
    id?: string
    nationality?: string | null
    gender?: string | null
    birthDate?: string | null
    passport_serial?: string | null
    is_active?: boolean
    photo?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TeacherPersonalInfoCreateOrConnectWithoutTeacherInput = {
    where: TeacherPersonalInfoWhereUniqueInput
    create: XOR<TeacherPersonalInfoCreateWithoutTeacherInput, TeacherPersonalInfoUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherPersonalInfoCreateManyTeacherInputEnvelope = {
    data: TeacherPersonalInfoCreateManyTeacherInput | TeacherPersonalInfoCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type TeacherWorkplaceCreateWithoutTeacherInput = {
    id?: string
    position: string
    created_at?: Date | string
    updated_at?: Date | string
    school: SchoolCreateNestedOneWithoutTeachers_workplacesInput
  }

  export type TeacherWorkplaceUncheckedCreateWithoutTeacherInput = {
    id?: string
    position: string
    schoolId: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TeacherWorkplaceCreateOrConnectWithoutTeacherInput = {
    where: TeacherWorkplaceWhereUniqueInput
    create: XOR<TeacherWorkplaceCreateWithoutTeacherInput, TeacherWorkplaceUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherWorkplaceCreateManyTeacherInputEnvelope = {
    data: TeacherWorkplaceCreateManyTeacherInput | TeacherWorkplaceCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type TaskApplyUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TaskApplyWhereUniqueInput
    update: XOR<TaskApplyUpdateWithoutTeacherInput, TaskApplyUncheckedUpdateWithoutTeacherInput>
    create: XOR<TaskApplyCreateWithoutTeacherInput, TaskApplyUncheckedCreateWithoutTeacherInput>
  }

  export type TaskApplyUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TaskApplyWhereUniqueInput
    data: XOR<TaskApplyUpdateWithoutTeacherInput, TaskApplyUncheckedUpdateWithoutTeacherInput>
  }

  export type TaskApplyUpdateManyWithWhereWithoutTeacherInput = {
    where: TaskApplyScalarWhereInput
    data: XOR<TaskApplyUpdateManyMutationInput, TaskApplyUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TrainingApplyUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TrainingApplyWhereUniqueInput
    update: XOR<TrainingApplyUpdateWithoutTeacherInput, TrainingApplyUncheckedUpdateWithoutTeacherInput>
    create: XOR<TrainingApplyCreateWithoutTeacherInput, TrainingApplyUncheckedCreateWithoutTeacherInput>
  }

  export type TrainingApplyUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TrainingApplyWhereUniqueInput
    data: XOR<TrainingApplyUpdateWithoutTeacherInput, TrainingApplyUncheckedUpdateWithoutTeacherInput>
  }

  export type TrainingApplyUpdateManyWithWhereWithoutTeacherInput = {
    where: TrainingApplyScalarWhereInput
    data: XOR<TrainingApplyUpdateManyMutationInput, TrainingApplyUncheckedUpdateManyWithoutTeacherInput>
  }

  export type WriteQuestionApplyUpsertWithWhereUniqueWithoutTeacherInput = {
    where: WriteQuestionApplyWhereUniqueInput
    update: XOR<WriteQuestionApplyUpdateWithoutTeacherInput, WriteQuestionApplyUncheckedUpdateWithoutTeacherInput>
    create: XOR<WriteQuestionApplyCreateWithoutTeacherInput, WriteQuestionApplyUncheckedCreateWithoutTeacherInput>
  }

  export type WriteQuestionApplyUpdateWithWhereUniqueWithoutTeacherInput = {
    where: WriteQuestionApplyWhereUniqueInput
    data: XOR<WriteQuestionApplyUpdateWithoutTeacherInput, WriteQuestionApplyUncheckedUpdateWithoutTeacherInput>
  }

  export type WriteQuestionApplyUpdateManyWithWhereWithoutTeacherInput = {
    where: WriteQuestionApplyScalarWhereInput
    data: XOR<WriteQuestionApplyUpdateManyMutationInput, WriteQuestionApplyUncheckedUpdateManyWithoutTeacherInput>
  }

  export type ChoiceAnswerApplyUpsertWithWhereUniqueWithoutTeacherInput = {
    where: ChoiceAnswerApplyWhereUniqueInput
    update: XOR<ChoiceAnswerApplyUpdateWithoutTeacherInput, ChoiceAnswerApplyUncheckedUpdateWithoutTeacherInput>
    create: XOR<ChoiceAnswerApplyCreateWithoutTeacherInput, ChoiceAnswerApplyUncheckedCreateWithoutTeacherInput>
  }

  export type ChoiceAnswerApplyUpdateWithWhereUniqueWithoutTeacherInput = {
    where: ChoiceAnswerApplyWhereUniqueInput
    data: XOR<ChoiceAnswerApplyUpdateWithoutTeacherInput, ChoiceAnswerApplyUncheckedUpdateWithoutTeacherInput>
  }

  export type ChoiceAnswerApplyUpdateManyWithWhereWithoutTeacherInput = {
    where: ChoiceAnswerApplyScalarWhereInput
    data: XOR<ChoiceAnswerApplyUpdateManyMutationInput, ChoiceAnswerApplyUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TeacherPersonalInfoUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TeacherPersonalInfoWhereUniqueInput
    update: XOR<TeacherPersonalInfoUpdateWithoutTeacherInput, TeacherPersonalInfoUncheckedUpdateWithoutTeacherInput>
    create: XOR<TeacherPersonalInfoCreateWithoutTeacherInput, TeacherPersonalInfoUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherPersonalInfoUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TeacherPersonalInfoWhereUniqueInput
    data: XOR<TeacherPersonalInfoUpdateWithoutTeacherInput, TeacherPersonalInfoUncheckedUpdateWithoutTeacherInput>
  }

  export type TeacherPersonalInfoUpdateManyWithWhereWithoutTeacherInput = {
    where: TeacherPersonalInfoScalarWhereInput
    data: XOR<TeacherPersonalInfoUpdateManyMutationInput, TeacherPersonalInfoUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TeacherPersonalInfoScalarWhereInput = {
    AND?: TeacherPersonalInfoScalarWhereInput | TeacherPersonalInfoScalarWhereInput[]
    OR?: TeacherPersonalInfoScalarWhereInput[]
    NOT?: TeacherPersonalInfoScalarWhereInput | TeacherPersonalInfoScalarWhereInput[]
    id?: StringFilter<"TeacherPersonalInfo"> | string
    teacherId?: StringFilter<"TeacherPersonalInfo"> | string
    nationality?: StringNullableFilter<"TeacherPersonalInfo"> | string | null
    gender?: StringNullableFilter<"TeacherPersonalInfo"> | string | null
    birthDate?: StringNullableFilter<"TeacherPersonalInfo"> | string | null
    passport_serial?: StringNullableFilter<"TeacherPersonalInfo"> | string | null
    is_active?: BoolFilter<"TeacherPersonalInfo"> | boolean
    photo?: StringNullableFilter<"TeacherPersonalInfo"> | string | null
    created_at?: DateTimeFilter<"TeacherPersonalInfo"> | Date | string
    updated_at?: DateTimeFilter<"TeacherPersonalInfo"> | Date | string
  }

  export type TeacherWorkplaceUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TeacherWorkplaceWhereUniqueInput
    update: XOR<TeacherWorkplaceUpdateWithoutTeacherInput, TeacherWorkplaceUncheckedUpdateWithoutTeacherInput>
    create: XOR<TeacherWorkplaceCreateWithoutTeacherInput, TeacherWorkplaceUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherWorkplaceUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TeacherWorkplaceWhereUniqueInput
    data: XOR<TeacherWorkplaceUpdateWithoutTeacherInput, TeacherWorkplaceUncheckedUpdateWithoutTeacherInput>
  }

  export type TeacherWorkplaceUpdateManyWithWhereWithoutTeacherInput = {
    where: TeacherWorkplaceScalarWhereInput
    data: XOR<TeacherWorkplaceUpdateManyMutationInput, TeacherWorkplaceUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TeacherCreateWithoutTeacher_personal_infoInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    username: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    task_applys?: TaskApplyCreateNestedManyWithoutTeacherInput
    teacher_training_applys?: TrainingApplyCreateNestedManyWithoutTeacherInput
    write_question_applys?: WriteQuestionApplyCreateNestedManyWithoutTeacherInput
    choice_answer_applys?: ChoiceAnswerApplyCreateNestedManyWithoutTeacherInput
    teacher_workplace?: TeacherWorkplaceCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutTeacher_personal_infoInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    username: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    task_applys?: TaskApplyUncheckedCreateNestedManyWithoutTeacherInput
    teacher_training_applys?: TrainingApplyUncheckedCreateNestedManyWithoutTeacherInput
    write_question_applys?: WriteQuestionApplyUncheckedCreateNestedManyWithoutTeacherInput
    choice_answer_applys?: ChoiceAnswerApplyUncheckedCreateNestedManyWithoutTeacherInput
    teacher_workplace?: TeacherWorkplaceUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutTeacher_personal_infoInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutTeacher_personal_infoInput, TeacherUncheckedCreateWithoutTeacher_personal_infoInput>
  }

  export type TeacherUpsertWithoutTeacher_personal_infoInput = {
    update: XOR<TeacherUpdateWithoutTeacher_personal_infoInput, TeacherUncheckedUpdateWithoutTeacher_personal_infoInput>
    create: XOR<TeacherCreateWithoutTeacher_personal_infoInput, TeacherUncheckedCreateWithoutTeacher_personal_infoInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutTeacher_personal_infoInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutTeacher_personal_infoInput, TeacherUncheckedUpdateWithoutTeacher_personal_infoInput>
  }

  export type TeacherUpdateWithoutTeacher_personal_infoInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_applys?: TaskApplyUpdateManyWithoutTeacherNestedInput
    teacher_training_applys?: TrainingApplyUpdateManyWithoutTeacherNestedInput
    write_question_applys?: WriteQuestionApplyUpdateManyWithoutTeacherNestedInput
    choice_answer_applys?: ChoiceAnswerApplyUpdateManyWithoutTeacherNestedInput
    teacher_workplace?: TeacherWorkplaceUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutTeacher_personal_infoInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_applys?: TaskApplyUncheckedUpdateManyWithoutTeacherNestedInput
    teacher_training_applys?: TrainingApplyUncheckedUpdateManyWithoutTeacherNestedInput
    write_question_applys?: WriteQuestionApplyUncheckedUpdateManyWithoutTeacherNestedInput
    choice_answer_applys?: ChoiceAnswerApplyUncheckedUpdateManyWithoutTeacherNestedInput
    teacher_workplace?: TeacherWorkplaceUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherCreateWithoutTeacher_workplaceInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    username: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    task_applys?: TaskApplyCreateNestedManyWithoutTeacherInput
    teacher_training_applys?: TrainingApplyCreateNestedManyWithoutTeacherInput
    write_question_applys?: WriteQuestionApplyCreateNestedManyWithoutTeacherInput
    choice_answer_applys?: ChoiceAnswerApplyCreateNestedManyWithoutTeacherInput
    teacher_personal_info?: TeacherPersonalInfoCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutTeacher_workplaceInput = {
    id?: string
    first_name: string
    last_name: string
    email: string
    username: string
    hashed_password: string
    hashed_refresh_token?: string | null
    activation_link?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    task_applys?: TaskApplyUncheckedCreateNestedManyWithoutTeacherInput
    teacher_training_applys?: TrainingApplyUncheckedCreateNestedManyWithoutTeacherInput
    write_question_applys?: WriteQuestionApplyUncheckedCreateNestedManyWithoutTeacherInput
    choice_answer_applys?: ChoiceAnswerApplyUncheckedCreateNestedManyWithoutTeacherInput
    teacher_personal_info?: TeacherPersonalInfoUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutTeacher_workplaceInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutTeacher_workplaceInput, TeacherUncheckedCreateWithoutTeacher_workplaceInput>
  }

  export type SchoolCreateWithoutTeachers_workplacesInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    region: RegionCreateNestedOneWithoutSchoolsInput
  }

  export type SchoolUncheckedCreateWithoutTeachers_workplacesInput = {
    id?: string
    name: string
    region_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SchoolCreateOrConnectWithoutTeachers_workplacesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutTeachers_workplacesInput, SchoolUncheckedCreateWithoutTeachers_workplacesInput>
  }

  export type TeacherUpsertWithoutTeacher_workplaceInput = {
    update: XOR<TeacherUpdateWithoutTeacher_workplaceInput, TeacherUncheckedUpdateWithoutTeacher_workplaceInput>
    create: XOR<TeacherCreateWithoutTeacher_workplaceInput, TeacherUncheckedCreateWithoutTeacher_workplaceInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutTeacher_workplaceInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutTeacher_workplaceInput, TeacherUncheckedUpdateWithoutTeacher_workplaceInput>
  }

  export type TeacherUpdateWithoutTeacher_workplaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_applys?: TaskApplyUpdateManyWithoutTeacherNestedInput
    teacher_training_applys?: TrainingApplyUpdateManyWithoutTeacherNestedInput
    write_question_applys?: WriteQuestionApplyUpdateManyWithoutTeacherNestedInput
    choice_answer_applys?: ChoiceAnswerApplyUpdateManyWithoutTeacherNestedInput
    teacher_personal_info?: TeacherPersonalInfoUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutTeacher_workplaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    hashed_password?: StringFieldUpdateOperationsInput | string
    hashed_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    activation_link?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_applys?: TaskApplyUncheckedUpdateManyWithoutTeacherNestedInput
    teacher_training_applys?: TrainingApplyUncheckedUpdateManyWithoutTeacherNestedInput
    write_question_applys?: WriteQuestionApplyUncheckedUpdateManyWithoutTeacherNestedInput
    choice_answer_applys?: ChoiceAnswerApplyUncheckedUpdateManyWithoutTeacherNestedInput
    teacher_personal_info?: TeacherPersonalInfoUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type SchoolUpsertWithoutTeachers_workplacesInput = {
    update: XOR<SchoolUpdateWithoutTeachers_workplacesInput, SchoolUncheckedUpdateWithoutTeachers_workplacesInput>
    create: XOR<SchoolCreateWithoutTeachers_workplacesInput, SchoolUncheckedCreateWithoutTeachers_workplacesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutTeachers_workplacesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutTeachers_workplacesInput, SchoolUncheckedUpdateWithoutTeachers_workplacesInput>
  }

  export type SchoolUpdateWithoutTeachers_workplacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    region?: RegionUpdateOneRequiredWithoutSchoolsNestedInput
  }

  export type SchoolUncheckedUpdateWithoutTeachers_workplacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherWorkplaceCreateManySchoolInput = {
    id?: string
    position: string
    teacherId: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TeacherWorkplaceUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutTeacher_workplaceNestedInput
  }

  export type TeacherWorkplaceUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherWorkplaceUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolCreateManyRegionInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SchoolUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers_workplaces?: TeacherWorkplaceUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers_workplaces?: TeacherWorkplaceUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateManyWithoutRegionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceAnswerCreateManyQuestionInput = {
    id?: string
    key: string
    value: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChoiceAnswerUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    choice_answer_applys?: ChoiceAnswerApplyUpdateManyWithoutAnswerNestedInput
  }

  export type ChoiceAnswerUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    choice_answer_applys?: ChoiceAnswerApplyUncheckedUpdateManyWithoutAnswerNestedInput
  }

  export type ChoiceAnswerUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceAnswerApplyCreateManyAnswerInput = {
    id?: string
    teacherId: string
    key: string
    is_correct?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChoiceAnswerApplyUpdateWithoutAnswerInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutChoice_answer_applysNestedInput
  }

  export type ChoiceAnswerApplyUncheckedUpdateWithoutAnswerInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceAnswerApplyUncheckedUpdateManyWithoutAnswerInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WriteQuestionApplyCreateManyQuestionInput = {
    id?: string
    teacherId: string
    value: string
    is_correct?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WriteQuestionApplyUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutWrite_question_applysNestedInput
  }

  export type WriteQuestionApplyUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WriteQuestionApplyUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingApplyCreateManyTrainInput = {
    id?: string
    teacherId: string
    text?: string | null
    file?: string | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TrainingApplyUpdateWithoutTrainInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutTeacher_training_applysNestedInput
    checking_applys?: CheckTrainingApplyUpdateManyWithoutTraining_applyNestedInput
  }

  export type TrainingApplyUncheckedUpdateWithoutTrainInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    checking_applys?: CheckTrainingApplyUncheckedUpdateManyWithoutTraining_applyNestedInput
  }

  export type TrainingApplyUncheckedUpdateManyWithoutTrainInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckTrainingApplyCreateManyTraining_applyInput = {
    id?: string
    description?: string | null
    score?: number
    is_active?: boolean | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CheckTrainingApplyUpdateWithoutTraining_applyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckTrainingApplyUncheckedUpdateWithoutTraining_applyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckTrainingApplyUncheckedUpdateManyWithoutTraining_applyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyLessonInput = {
    id?: string
    title: string
    description?: string | null
    file?: string | null
    score?: number
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TaskUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    criterias?: TaskCriteriaUpdateManyWithoutTaskNestedInput
    task_applys?: TaskApplyUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    criterias?: TaskCriteriaUncheckedUpdateManyWithoutTaskNestedInput
    task_applys?: TaskApplyUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCriteriaCreateManyTaskInput = {
    id?: string
    key: string
    value: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TaskApplyCreateManyTaskInput = {
    id?: string
    teacherId: string
    overall_score?: number | null
    description: string
    file?: string | null
    is_active?: boolean | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TaskCriteriaUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    checks_criterias?: CheckWithTaskCriteriasUpdateManyWithoutTask_criteriaNestedInput
  }

  export type TaskCriteriaUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    checks_criterias?: CheckWithTaskCriteriasUncheckedUpdateManyWithoutTask_criteriaNestedInput
  }

  export type TaskCriteriaUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskApplyUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    overall_score?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutTask_applysNestedInput
    check_task_criterias?: CheckWithTaskCriteriasUpdateManyWithoutTask_applyNestedInput
  }

  export type TaskApplyUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    overall_score?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    check_task_criterias?: CheckWithTaskCriteriasUncheckedUpdateManyWithoutTask_applyNestedInput
  }

  export type TaskApplyUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    overall_score?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckWithTaskCriteriasCreateManyTask_criteriaInput = {
    id?: string
    task_applyId: string
    criteria_score?: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CheckWithTaskCriteriasUpdateWithoutTask_criteriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    criteria_score?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_apply?: TaskApplyUpdateOneRequiredWithoutCheck_task_criteriasNestedInput
  }

  export type CheckWithTaskCriteriasUncheckedUpdateWithoutTask_criteriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    task_applyId?: StringFieldUpdateOperationsInput | string
    criteria_score?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckWithTaskCriteriasUncheckedUpdateManyWithoutTask_criteriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    task_applyId?: StringFieldUpdateOperationsInput | string
    criteria_score?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckWithTaskCriteriasCreateManyTask_applyInput = {
    id?: string
    task_criteriaId: string
    criteria_score?: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CheckWithTaskCriteriasUpdateWithoutTask_applyInput = {
    id?: StringFieldUpdateOperationsInput | string
    criteria_score?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task_criteria?: TaskCriteriaUpdateOneRequiredWithoutChecks_criteriasNestedInput
  }

  export type CheckWithTaskCriteriasUncheckedUpdateWithoutTask_applyInput = {
    id?: StringFieldUpdateOperationsInput | string
    task_criteriaId?: StringFieldUpdateOperationsInput | string
    criteria_score?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckWithTaskCriteriasUncheckedUpdateManyWithoutTask_applyInput = {
    id?: StringFieldUpdateOperationsInput | string
    task_criteriaId?: StringFieldUpdateOperationsInput | string
    criteria_score?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskApplyCreateManyTeacherInput = {
    id?: string
    taskId: string
    overall_score?: number | null
    description: string
    file?: string | null
    is_active?: boolean | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TrainingApplyCreateManyTeacherInput = {
    id?: string
    trainingId: string
    text?: string | null
    file?: string | null
    is_seen?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WriteQuestionApplyCreateManyTeacherInput = {
    id?: string
    questionId: string
    value: string
    is_correct?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChoiceAnswerApplyCreateManyTeacherInput = {
    id?: string
    answerId: string
    key: string
    is_correct?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TeacherPersonalInfoCreateManyTeacherInput = {
    id?: string
    nationality?: string | null
    gender?: string | null
    birthDate?: string | null
    passport_serial?: string | null
    is_active?: boolean
    photo?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TeacherWorkplaceCreateManyTeacherInput = {
    id?: string
    position: string
    schoolId: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TaskApplyUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    overall_score?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutTask_applysNestedInput
    check_task_criterias?: CheckWithTaskCriteriasUpdateManyWithoutTask_applyNestedInput
  }

  export type TaskApplyUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    overall_score?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    check_task_criterias?: CheckWithTaskCriteriasUncheckedUpdateManyWithoutTask_applyNestedInput
  }

  export type TaskApplyUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    overall_score?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingApplyUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    train?: TrainingUpdateOneRequiredWithoutTraining_applysNestedInput
    checking_applys?: CheckTrainingApplyUpdateManyWithoutTraining_applyNestedInput
  }

  export type TrainingApplyUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    checking_applys?: CheckTrainingApplyUncheckedUpdateManyWithoutTraining_applyNestedInput
  }

  export type TrainingApplyUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    file?: NullableStringFieldUpdateOperationsInput | string | null
    is_seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WriteQuestionApplyUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: WriteQuestionUpdateOneRequiredWithoutQuestion_applysNestedInput
  }

  export type WriteQuestionApplyUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WriteQuestionApplyUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceAnswerApplyUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: ChoiceAnswerUpdateOneRequiredWithoutChoice_answer_applysNestedInput
  }

  export type ChoiceAnswerApplyUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoiceAnswerApplyUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherPersonalInfoUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    passport_serial?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherPersonalInfoUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    passport_serial?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherPersonalInfoUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableStringFieldUpdateOperationsInput | string | null
    passport_serial?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherWorkplaceUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutTeachers_workplacesNestedInput
  }

  export type TeacherWorkplaceUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherWorkplaceUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use SchoolCountOutputTypeDefaultArgs instead
     */
    export type SchoolCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RegionCountOutputTypeDefaultArgs instead
     */
    export type RegionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RegionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChoiceQuestionCountOutputTypeDefaultArgs instead
     */
    export type ChoiceQuestionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChoiceQuestionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChoiceAnswerCountOutputTypeDefaultArgs instead
     */
    export type ChoiceAnswerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChoiceAnswerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WriteQuestionCountOutputTypeDefaultArgs instead
     */
    export type WriteQuestionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WriteQuestionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainingCountOutputTypeDefaultArgs instead
     */
    export type TrainingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainingApplyCountOutputTypeDefaultArgs instead
     */
    export type TrainingApplyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainingApplyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LessonCountOutputTypeDefaultArgs instead
     */
    export type LessonCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LessonCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskCountOutputTypeDefaultArgs instead
     */
    export type TaskCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskCriteriaCountOutputTypeDefaultArgs instead
     */
    export type TaskCriteriaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskCriteriaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskApplyCountOutputTypeDefaultArgs instead
     */
    export type TaskApplyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskApplyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeacherCountOutputTypeDefaultArgs instead
     */
    export type TeacherCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeacherCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolDefaultArgs instead
     */
    export type SchoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RegionDefaultArgs instead
     */
    export type RegionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RegionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChoiceQuestionDefaultArgs instead
     */
    export type ChoiceQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChoiceQuestionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChoiceAnswerDefaultArgs instead
     */
    export type ChoiceAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChoiceAnswerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChoiceAnswerApplyDefaultArgs instead
     */
    export type ChoiceAnswerApplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChoiceAnswerApplyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WriteQuestionDefaultArgs instead
     */
    export type WriteQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WriteQuestionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WriteQuestionApplyDefaultArgs instead
     */
    export type WriteQuestionApplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WriteQuestionApplyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainingDefaultArgs instead
     */
    export type TrainingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainingApplyDefaultArgs instead
     */
    export type TrainingApplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainingApplyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CheckTrainingApplyDefaultArgs instead
     */
    export type CheckTrainingApplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CheckTrainingApplyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LessonDefaultArgs instead
     */
    export type LessonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LessonDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskDefaultArgs instead
     */
    export type TaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskCriteriaDefaultArgs instead
     */
    export type TaskCriteriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskCriteriaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskApplyDefaultArgs instead
     */
    export type TaskApplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskApplyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CheckWithTaskCriteriasDefaultArgs instead
     */
    export type CheckWithTaskCriteriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CheckWithTaskCriteriasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeacherDefaultArgs instead
     */
    export type TeacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeacherDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeacherPersonalInfoDefaultArgs instead
     */
    export type TeacherPersonalInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeacherPersonalInfoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeacherWorkplaceDefaultArgs instead
     */
    export type TeacherWorkplaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeacherWorkplaceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminDefaultArgs instead
     */
    export type AdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}